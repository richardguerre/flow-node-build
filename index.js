// @bun
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// ../../node_modules/@whatwg-node/fetch/dist/shouldSkipPonyfill.js
var require_shouldSkipPonyfill = __commonJS((exports, module) => {
  var isNextJs = function() {
    return Object.keys(globalThis).some((key) => key.startsWith("__NEXT"));
  };
  module.exports = function shouldSkipPonyfill() {
    if (globalThis.Deno) {
      return true;
    }
    if (process.versions.bun) {
      return true;
    }
    if (isNextJs()) {
      return true;
    }
    return false;
  };
});

// ../../node_modules/urlpattern-polyfill/dist/urlpattern.cjs
var require_urlpattern = __commonJS((exports, module) => {
  var we = function(e, t) {
    return (t ? /^[\x00-\xFF]*$/ : /^[\x00-\x7F]*$/).test(e);
  };
  var D = function(e, t = false) {
    let r = [], n = 0;
    for (;n < e.length; ) {
      let a = e[n], c = function(l) {
        if (!t)
          throw new TypeError(l);
        r.push({ type: "INVALID_CHAR", index: n, value: e[n++] });
      };
      if (a === "*") {
        r.push({ type: "ASTERISK", index: n, value: e[n++] });
        continue;
      }
      if (a === "+" || a === "?") {
        r.push({ type: "OTHER_MODIFIER", index: n, value: e[n++] });
        continue;
      }
      if (a === "\\") {
        r.push({ type: "ESCAPED_CHAR", index: n++, value: e[n++] });
        continue;
      }
      if (a === "{") {
        r.push({ type: "OPEN", index: n, value: e[n++] });
        continue;
      }
      if (a === "}") {
        r.push({ type: "CLOSE", index: n, value: e[n++] });
        continue;
      }
      if (a === ":") {
        let l = "", s = n + 1;
        for (;s < e.length; ) {
          let i = e.substr(s, 1);
          if (s === n + 1 && Ae.test(i) || s !== n + 1 && ye.test(i)) {
            l += e[s++];
            continue;
          }
          break;
        }
        if (!l) {
          c(`Missing parameter name at ${n}`);
          continue;
        }
        r.push({ type: "NAME", index: n, value: l }), n = s;
        continue;
      }
      if (a === "(") {
        let l = 1, s = "", i = n + 1, o = false;
        if (e[i] === "?") {
          c(`Pattern cannot start with "?" at ${i}`);
          continue;
        }
        for (;i < e.length; ) {
          if (!we(e[i], false)) {
            c(`Invalid character '${e[i]}' at ${i}.`), o = true;
            break;
          }
          if (e[i] === "\\") {
            s += e[i++] + e[i++];
            continue;
          }
          if (e[i] === ")") {
            if (l--, l === 0) {
              i++;
              break;
            }
          } else if (e[i] === "(" && (l++, e[i + 1] !== "?")) {
            c(`Capturing groups are not allowed at ${i}`), o = true;
            break;
          }
          s += e[i++];
        }
        if (o)
          continue;
        if (l) {
          c(`Unbalanced pattern at ${n}`);
          continue;
        }
        if (!s) {
          c(`Missing pattern at ${n}`);
          continue;
        }
        r.push({ type: "REGEX", index: n, value: s }), n = i;
        continue;
      }
      r.push({ type: "CHAR", index: n, value: e[n++] });
    }
    return r.push({ type: "END", index: n, value: "" }), r;
  };
  var F = function(e, t = {}) {
    let r = D(e);
    t.delimiter ??= "/#?", t.prefixes ??= "./";
    let n = `[^${S(t.delimiter)}]+?`, a = [], c = 0, l = 0, s = "", i = new Set, o = (h) => {
      if (l < r.length && r[l].type === h)
        return r[l++].value;
    }, f = () => o("OTHER_MODIFIER") ?? o("ASTERISK"), d = (h) => {
      let u = o(h);
      if (u !== undefined)
        return u;
      let { type: p, index: A } = r[l];
      throw new TypeError(`Unexpected ${p} at ${A}, expected ${h}`);
    }, T = () => {
      let h = "", u;
      for (;u = o("CHAR") ?? o("ESCAPED_CHAR"); )
        h += u;
      return h;
    }, xe = (h) => h, L = t.encodePart || xe, I = "", U = (h) => {
      I += h;
    }, $ = () => {
      I.length && (a.push(new R(3, "", "", L(I), "", 3)), I = "");
    }, X = (h, u, p, A, Z) => {
      let g = 3;
      switch (Z) {
        case "?":
          g = 1;
          break;
        case "*":
          g = 0;
          break;
        case "+":
          g = 2;
          break;
      }
      if (!u && !p && g === 3) {
        U(h);
        return;
      }
      if ($(), !u && !p) {
        if (!h)
          return;
        a.push(new R(3, "", "", L(h), "", g));
        return;
      }
      let m;
      p ? p === "*" ? m = v : m = p : m = n;
      let O = 2;
      m === n ? (O = 1, m = "") : m === v && (O = 0, m = "");
      let P;
      if (u ? P = u : p && (P = c++), i.has(P))
        throw new TypeError(`Duplicate name '${P}'.`);
      i.add(P), a.push(new R(O, P, L(h), m, L(A), g));
    };
    for (;l < r.length; ) {
      let h = o("CHAR"), u = o("NAME"), p = o("REGEX");
      if (!u && !p && (p = o("ASTERISK")), u || p) {
        let g = h ?? "";
        t.prefixes.indexOf(g) === -1 && (U(g), g = ""), $();
        let m = f();
        X(g, u, p, "", m);
        continue;
      }
      let A = h ?? o("ESCAPED_CHAR");
      if (A) {
        U(A);
        continue;
      }
      if (o("OPEN")) {
        let g = T(), m = o("NAME"), O = o("REGEX");
        !m && !O && (O = o("ASTERISK"));
        let P = T();
        d("CLOSE");
        let be = f();
        X(g, m, O, P, be);
        continue;
      }
      $(), d("END");
    }
    return a;
  };
  var S = function(e) {
    return e.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
  };
  var B = function(e) {
    return e && e.ignoreCase ? "ui" : "u";
  };
  var q = function(e, t, r) {
    return W(F(e, r), t, r);
  };
  var k = function(e) {
    switch (e) {
      case 0:
        return "*";
      case 1:
        return "?";
      case 2:
        return "+";
      case 3:
        return "";
    }
  };
  var W = function(e, t, r = {}) {
    r.delimiter ??= "/#?", r.prefixes ??= "./", r.sensitive ??= false, r.strict ??= false, r.end ??= true, r.start ??= true, r.endsWith = "";
    let n = r.start ? "^" : "";
    for (let s of e) {
      if (s.type === 3) {
        s.modifier === 3 ? n += S(s.value) : n += `(?:${S(s.value)})${k(s.modifier)}`;
        continue;
      }
      t && t.push(s.name);
      let i = `[^${S(r.delimiter)}]+?`, o = s.value;
      if (s.type === 1 ? o = i : s.type === 0 && (o = v), !s.prefix.length && !s.suffix.length) {
        s.modifier === 3 || s.modifier === 1 ? n += `(${o})${k(s.modifier)}` : n += `((?:${o})${k(s.modifier)})`;
        continue;
      }
      if (s.modifier === 3 || s.modifier === 1) {
        n += `(?:${S(s.prefix)}(${o})${S(s.suffix)})`, n += k(s.modifier);
        continue;
      }
      n += `(?:${S(s.prefix)}`, n += `((?:${o})(?:`, n += S(s.suffix), n += S(s.prefix), n += `(?:${o}))*)${S(s.suffix)})`, s.modifier === 0 && (n += "?");
    }
    let a = `[${S(r.endsWith)}]|\$`, c = `[${S(r.delimiter)}]`;
    if (r.end)
      return r.strict || (n += `${c}?`), r.endsWith.length ? n += `(?=${a})` : n += "$", new RegExp(n, B(r));
    r.strict || (n += `(?:${c}(?=${a}))?`);
    let l = false;
    if (e.length) {
      let s = e[e.length - 1];
      s.type === 3 && s.modifier === 3 && (l = r.delimiter.indexOf(s) > -1);
    }
    return l || (n += `(?=${c}|${a})`), new RegExp(n, B(r));
  };
  var ee = function(e, t) {
    return e.length ? e[0] === "/" ? true : !t || e.length < 2 ? false : (e[0] == "\\" || e[0] == "{") && e[1] == "/" : false;
  };
  var te = function(e, t) {
    return e.startsWith(t) ? e.substring(t.length, e.length) : e;
  };
  var Ce = function(e, t) {
    return e.endsWith(t) ? e.substr(0, e.length - t.length) : e;
  };
  var _ = function(e) {
    return !e || e.length < 2 ? false : e[0] === "[" || (e[0] === "\\" || e[0] === "{") && e[1] === "[";
  };
  var N = function(e) {
    if (!e)
      return true;
    for (let t of re)
      if (e.test(t))
        return true;
    return false;
  };
  var ne = function(e, t) {
    if (e = te(e, "#"), t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.hash = e, r.hash ? r.hash.substring(1, r.hash.length) : "";
  };
  var se = function(e, t) {
    if (e = te(e, "?"), t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.search = e, r.search ? r.search.substring(1, r.search.length) : "";
  };
  var ie = function(e, t) {
    return t || e === "" ? e : _(e) ? K(e) : j(e);
  };
  var ae = function(e, t) {
    if (t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.password = e, r.password;
  };
  var oe = function(e, t) {
    if (t || e === "")
      return e;
    let r = new URL("https://example.com");
    return r.username = e, r.username;
  };
  var ce = function(e, t, r) {
    if (r || e === "")
      return e;
    if (t && !re.includes(t))
      return new URL(`${t}:${e}`).pathname;
    let n = e[0] == "/";
    return e = new URL(n ? e : "/-" + e, "https://example.com").pathname, n || (e = e.substring(2, e.length)), e;
  };
  var le = function(e, t, r) {
    return z(t) === e && (e = ""), r || e === "" ? e : G(e);
  };
  var fe = function(e, t) {
    return e = Ce(e, ":"), t || e === "" ? e : y(e);
  };
  var z = function(e) {
    switch (e) {
      case "ws":
      case "http":
        return "80";
      case "wws":
      case "https":
        return "443";
      case "ftp":
        return "21";
      default:
        return "";
    }
  };
  var y = function(e) {
    if (e === "")
      return e;
    if (/^[-+.A-Za-z0-9]*$/.test(e))
      return e.toLowerCase();
    throw new TypeError(`Invalid protocol '${e}'.`);
  };
  var he = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.username = e, t.username;
  };
  var ue = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.password = e, t.password;
  };
  var j = function(e) {
    if (e === "")
      return e;
    if (/[\t\n\r #%/:<>?@[\]^\\|]/g.test(e))
      throw new TypeError(`Invalid hostname '${e}'`);
    let t = new URL("https://example.com");
    return t.hostname = e, t.hostname;
  };
  var K = function(e) {
    if (e === "")
      return e;
    if (/[^0-9a-fA-F[\]:]/g.test(e))
      throw new TypeError(`Invalid IPv6 hostname '${e}'`);
    return e.toLowerCase();
  };
  var G = function(e) {
    if (e === "" || /^[0-9]*$/.test(e) && parseInt(e) <= 65535)
      return e;
    throw new TypeError(`Invalid port '${e}'.`);
  };
  var de = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.pathname = e[0] !== "/" ? "/-" + e : e, e[0] !== "/" ? t.pathname.substring(2, t.pathname.length) : t.pathname;
  };
  var pe = function(e) {
    return e === "" ? e : new URL(`data:${e}`).pathname;
  };
  var ge = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.search = e, t.search.substring(1, t.search.length);
  };
  var me = function(e) {
    if (e === "")
      return e;
    let t = new URL("https://example.com");
    return t.hash = e, t.hash.substring(1, t.hash.length);
  };
  var Se = function(e, t) {
    if (typeof e != "string")
      throw new TypeError("parameter 1 is not of type 'string'.");
    let r = new URL(e, t);
    return { protocol: r.protocol.substring(0, r.protocol.length - 1), username: r.username, password: r.password, hostname: r.hostname, port: r.port, pathname: r.pathname, search: r.search !== "" ? r.search.substring(1, r.search.length) : undefined, hash: r.hash !== "" ? r.hash.substring(1, r.hash.length) : undefined };
  };
  var b = function(e, t) {
    return t ? C(e) : e;
  };
  var w = function(e, t, r) {
    let n;
    if (typeof t.baseURL == "string")
      try {
        n = new URL(t.baseURL), t.protocol === undefined && (e.protocol = b(n.protocol.substring(0, n.protocol.length - 1), r)), !r && t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.username === undefined && (e.username = b(n.username, r)), !r && t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.username === undefined && t.password === undefined && (e.password = b(n.password, r)), t.protocol === undefined && t.hostname === undefined && (e.hostname = b(n.hostname, r)), t.protocol === undefined && t.hostname === undefined && t.port === undefined && (e.port = b(n.port, r)), t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.pathname === undefined && (e.pathname = b(n.pathname, r)), t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.pathname === undefined && t.search === undefined && (e.search = b(n.search.substring(1, n.search.length), r)), t.protocol === undefined && t.hostname === undefined && t.port === undefined && t.pathname === undefined && t.search === undefined && t.hash === undefined && (e.hash = b(n.hash.substring(1, n.hash.length), r));
      } catch {
        throw new TypeError(`invalid baseURL '${t.baseURL}'.`);
      }
    if (typeof t.protocol == "string" && (e.protocol = fe(t.protocol, r)), typeof t.username == "string" && (e.username = oe(t.username, r)), typeof t.password == "string" && (e.password = ae(t.password, r)), typeof t.hostname == "string" && (e.hostname = ie(t.hostname, r)), typeof t.port == "string" && (e.port = le(t.port, e.protocol, r)), typeof t.pathname == "string") {
      if (e.pathname = t.pathname, n && !ee(e.pathname, r)) {
        let a = n.pathname.lastIndexOf("/");
        a >= 0 && (e.pathname = b(n.pathname.substring(0, a + 1), r) + e.pathname);
      }
      e.pathname = ce(e.pathname, e.protocol, r);
    }
    return typeof t.search == "string" && (e.search = se(t.search, r)), typeof t.hash == "string" && (e.hash = ne(t.hash, r)), e;
  };
  var C = function(e) {
    return e.replace(/([+*?:{}()\\])/g, "\\$1");
  };
  var Le = function(e) {
    return e.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
  };
  var Ie = function(e, t) {
    t.delimiter ??= "/#?", t.prefixes ??= "./", t.sensitive ??= false, t.strict ??= false, t.end ??= true, t.start ??= true, t.endsWith = "";
    let r = ".*", n = `[^${Le(t.delimiter)}]+?`, a = /[$_\u200C\u200D\p{ID_Continue}]/u, c = "";
    for (let l = 0;l < e.length; ++l) {
      let s = e[l];
      if (s.type === 3) {
        if (s.modifier === 3) {
          c += C(s.value);
          continue;
        }
        c += `{${C(s.value)}}${k(s.modifier)}`;
        continue;
      }
      let i = s.hasCustomName(), o = !!s.suffix.length || !!s.prefix.length && (s.prefix.length !== 1 || !t.prefixes.includes(s.prefix)), f = l > 0 ? e[l - 1] : null, d = l < e.length - 1 ? e[l + 1] : null;
      if (!o && i && s.type === 1 && s.modifier === 3 && d && !d.prefix.length && !d.suffix.length)
        if (d.type === 3) {
          let T = d.value.length > 0 ? d.value[0] : "";
          o = a.test(T);
        } else
          o = !d.hasCustomName();
      if (!o && !s.prefix.length && f && f.type === 3) {
        let T = f.value[f.value.length - 1];
        o = t.prefixes.includes(T);
      }
      o && (c += "{"), c += C(s.prefix), i && (c += `:${s.name}`), s.type === 2 ? c += `(${s.value})` : s.type === 1 ? i || (c += `(${n})`) : s.type === 0 && (!i && (!f || f.type === 3 || f.modifier !== 3 || o || s.prefix !== "") ? c += "*" : c += `(${r})`), s.type === 1 && i && s.suffix.length && a.test(s.suffix[0]) && (c += "\\"), c += C(s.suffix), o && (c += "}"), s.modifier !== 3 && (c += k(s.modifier));
    }
    return c;
  };
  var M = Object.defineProperty;
  var Pe = Object.getOwnPropertyDescriptor;
  var Re = Object.getOwnPropertyNames;
  var Ee = Object.prototype.hasOwnProperty;
  var Oe = (e, t) => {
    for (var r in t)
      M(e, r, { get: t[r], enumerable: true });
  };
  var ke = (e, t, r, n) => {
    if (t && typeof t == "object" || typeof t == "function")
      for (let a of Re(t))
        !Ee.call(e, a) && a !== r && M(e, a, { get: () => t[a], enumerable: !(n = Pe(t, a)) || n.enumerable });
    return e;
  };
  var Te = (e) => ke(M({}, "__esModule", { value: true }), e);
  var Ne = {};
  Oe(Ne, { URLPattern: () => Y });
  module.exports = Te(Ne);
  var R = class {
    type = 3;
    name = "";
    prefix = "";
    value = "";
    suffix = "";
    modifier = 3;
    constructor(t, r, n, a, c, l) {
      this.type = t, this.name = r, this.prefix = n, this.value = a, this.suffix = c, this.modifier = l;
    }
    hasCustomName() {
      return this.name !== "" && typeof this.name != "number";
    }
  };
  var Ae = /[$_\p{ID_Start}]/u;
  var ye = /[$_\u200C\u200D\p{ID_Continue}]/u;
  var v = ".*";
  var x = { delimiter: "", prefixes: "", sensitive: true, strict: true };
  var J = { delimiter: ".", prefixes: "", sensitive: true, strict: true };
  var Q = { delimiter: "/", prefixes: "/", sensitive: true, strict: true };
  var re = ["ftp", "file", "http", "https", "ws", "wss"];
  var H = class {
    #i;
    #n = [];
    #t = {};
    #e = 0;
    #s = 1;
    #l = 0;
    #o = 0;
    #d = 0;
    #p = 0;
    #g = false;
    constructor(t) {
      this.#i = t;
    }
    get result() {
      return this.#t;
    }
    parse() {
      for (this.#n = D(this.#i, true);this.#e < this.#n.length; this.#e += this.#s) {
        if (this.#s = 1, this.#n[this.#e].type === "END") {
          if (this.#o === 0) {
            this.#b(), this.#f() ? this.#r(9, 1) : this.#h() ? this.#r(8, 1) : this.#r(7, 0);
            continue;
          } else if (this.#o === 2) {
            this.#u(5);
            continue;
          }
          this.#r(10, 0);
          break;
        }
        if (this.#d > 0)
          if (this.#A())
            this.#d -= 1;
          else
            continue;
        if (this.#T()) {
          this.#d += 1;
          continue;
        }
        switch (this.#o) {
          case 0:
            this.#P() && this.#u(1);
            break;
          case 1:
            if (this.#P()) {
              this.#C();
              let t = 7, r = 1;
              this.#E() ? (t = 2, r = 3) : this.#g && (t = 2), this.#r(t, r);
            }
            break;
          case 2:
            this.#S() ? this.#u(3) : (this.#x() || this.#h() || this.#f()) && this.#u(5);
            break;
          case 3:
            this.#O() ? this.#r(4, 1) : this.#S() && this.#r(5, 1);
            break;
          case 4:
            this.#S() && this.#r(5, 1);
            break;
          case 5:
            this.#y() ? this.#p += 1 : this.#w() && (this.#p -= 1), this.#k() && !this.#p ? this.#r(6, 1) : this.#x() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#f() && this.#r(9, 1);
            break;
          case 6:
            this.#x() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#f() && this.#r(9, 1);
            break;
          case 7:
            this.#h() ? this.#r(8, 1) : this.#f() && this.#r(9, 1);
            break;
          case 8:
            this.#f() && this.#r(9, 1);
            break;
          case 9:
            break;
          case 10:
            break;
        }
      }
      this.#t.hostname !== undefined && this.#t.port === undefined && (this.#t.port = "");
    }
    #r(t, r) {
      switch (this.#o) {
        case 0:
          break;
        case 1:
          this.#t.protocol = this.#c();
          break;
        case 2:
          break;
        case 3:
          this.#t.username = this.#c();
          break;
        case 4:
          this.#t.password = this.#c();
          break;
        case 5:
          this.#t.hostname = this.#c();
          break;
        case 6:
          this.#t.port = this.#c();
          break;
        case 7:
          this.#t.pathname = this.#c();
          break;
        case 8:
          this.#t.search = this.#c();
          break;
        case 9:
          this.#t.hash = this.#c();
          break;
        case 10:
          break;
      }
      this.#o !== 0 && t !== 10 && ([1, 2, 3, 4].includes(this.#o) && [6, 7, 8, 9].includes(t) && (this.#t.hostname ??= ""), [1, 2, 3, 4, 5, 6].includes(this.#o) && [8, 9].includes(t) && (this.#t.pathname ??= this.#g ? "/" : ""), [1, 2, 3, 4, 5, 6, 7].includes(this.#o) && t === 9 && (this.#t.search ??= "")), this.#R(t, r);
    }
    #R(t, r) {
      this.#o = t, this.#l = this.#e + r, this.#e += r, this.#s = 0;
    }
    #b() {
      this.#e = this.#l, this.#s = 0;
    }
    #u(t) {
      this.#b(), this.#o = t;
    }
    #m(t) {
      return t < 0 && (t = this.#n.length - t), t < this.#n.length ? this.#n[t] : this.#n[this.#n.length - 1];
    }
    #a(t, r) {
      let n = this.#m(t);
      return n.value === r && (n.type === "CHAR" || n.type === "ESCAPED_CHAR" || n.type === "INVALID_CHAR");
    }
    #P() {
      return this.#a(this.#e, ":");
    }
    #E() {
      return this.#a(this.#e + 1, "/") && this.#a(this.#e + 2, "/");
    }
    #S() {
      return this.#a(this.#e, "@");
    }
    #O() {
      return this.#a(this.#e, ":");
    }
    #k() {
      return this.#a(this.#e, ":");
    }
    #x() {
      return this.#a(this.#e, "/");
    }
    #h() {
      if (this.#a(this.#e, "?"))
        return true;
      if (this.#n[this.#e].value !== "?")
        return false;
      let t = this.#m(this.#e - 1);
      return t.type !== "NAME" && t.type !== "REGEX" && t.type !== "CLOSE" && t.type !== "ASTERISK";
    }
    #f() {
      return this.#a(this.#e, "#");
    }
    #T() {
      return this.#n[this.#e].type == "OPEN";
    }
    #A() {
      return this.#n[this.#e].type == "CLOSE";
    }
    #y() {
      return this.#a(this.#e, "[");
    }
    #w() {
      return this.#a(this.#e, "]");
    }
    #c() {
      let t = this.#n[this.#e], r = this.#m(this.#l).index;
      return this.#i.substring(r, t.index);
    }
    #C() {
      let t = {};
      Object.assign(t, x), t.encodePart = y;
      let r = q(this.#c(), undefined, t);
      this.#g = N(r);
    }
  };
  var V = ["protocol", "username", "password", "hostname", "port", "pathname", "search", "hash"];
  var E = "*";
  var Y = class {
    #i;
    #n = {};
    #t = {};
    #e = {};
    #s = {};
    #l = false;
    constructor(t = {}, r, n) {
      try {
        let a;
        if (typeof r == "string" ? a = r : n = r, typeof t == "string") {
          let i = new H(t);
          if (i.parse(), t = i.result, a === undefined && typeof t.protocol != "string")
            throw new TypeError("A base URL must be provided for a relative constructor string.");
          t.baseURL = a;
        } else {
          if (!t || typeof t != "object")
            throw new TypeError("parameter 1 is not of type 'string' and cannot convert to dictionary.");
          if (a)
            throw new TypeError("parameter 1 is not of type 'string'.");
        }
        typeof n > "u" && (n = { ignoreCase: false });
        let c = { ignoreCase: n.ignoreCase === true }, l = { pathname: E, protocol: E, username: E, password: E, hostname: E, port: E, search: E, hash: E };
        this.#i = w(l, t, true), z(this.#i.protocol) === this.#i.port && (this.#i.port = "");
        let s;
        for (s of V) {
          if (!(s in this.#i))
            continue;
          let i = {}, o = this.#i[s];
          switch (this.#t[s] = [], s) {
            case "protocol":
              Object.assign(i, x), i.encodePart = y;
              break;
            case "username":
              Object.assign(i, x), i.encodePart = he;
              break;
            case "password":
              Object.assign(i, x), i.encodePart = ue;
              break;
            case "hostname":
              Object.assign(i, J), _(o) ? i.encodePart = K : i.encodePart = j;
              break;
            case "port":
              Object.assign(i, x), i.encodePart = G;
              break;
            case "pathname":
              N(this.#n.protocol) ? (Object.assign(i, Q, c), i.encodePart = de) : (Object.assign(i, x, c), i.encodePart = pe);
              break;
            case "search":
              Object.assign(i, x, c), i.encodePart = ge;
              break;
            case "hash":
              Object.assign(i, x, c), i.encodePart = me;
              break;
          }
          try {
            this.#s[s] = F(o, i), this.#n[s] = W(this.#s[s], this.#t[s], i), this.#e[s] = Ie(this.#s[s], i), this.#l = this.#l || this.#s[s].some((f) => f.type === 2);
          } catch {
            throw new TypeError(`invalid ${s} pattern '${this.#i[s]}'.`);
          }
        }
      } catch (a) {
        throw new TypeError(`Failed to construct 'URLPattern': ${a.message}`);
      }
    }
    test(t = {}, r) {
      let n = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };
      if (typeof t != "string" && r)
        throw new TypeError("parameter 1 is not of type 'string'.");
      if (typeof t > "u")
        return false;
      try {
        typeof t == "object" ? n = w(n, t, false) : n = w(n, Se(t, r), false);
      } catch {
        return false;
      }
      let a;
      for (a of V)
        if (!this.#n[a].exec(n[a]))
          return false;
      return true;
    }
    exec(t = {}, r) {
      let n = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };
      if (typeof t != "string" && r)
        throw new TypeError("parameter 1 is not of type 'string'.");
      if (typeof t > "u")
        return;
      try {
        typeof t == "object" ? n = w(n, t, false) : n = w(n, Se(t, r), false);
      } catch {
        return null;
      }
      let a = {};
      r ? a.inputs = [t, r] : a.inputs = [t];
      let c;
      for (c of V) {
        let l = this.#n[c].exec(n[c]);
        if (!l)
          return null;
        let s = {};
        for (let [i, o] of this.#t[c].entries())
          if (typeof o == "string" || typeof o == "number") {
            let f = l[i + 1];
            s[o] = f;
          }
        a[c] = { input: n[c] ?? "", groups: s };
      }
      return a;
    }
    static compareComponent(t, r, n) {
      let a = (i, o) => {
        for (let f of ["type", "modifier", "prefix", "value", "suffix"]) {
          if (i[f] < o[f])
            return -1;
          if (i[f] === o[f])
            continue;
          return 1;
        }
        return 0;
      }, c = new R(3, "", "", "", "", 3), l = new R(0, "", "", "", "", 3), s = (i, o) => {
        let f = 0;
        for (;f < Math.min(i.length, o.length); ++f) {
          let d = a(i[f], o[f]);
          if (d)
            return d;
        }
        return i.length === o.length ? 0 : a(i[f] ?? c, o[f] ?? c);
      };
      return !r.#e[t] && !n.#e[t] ? 0 : r.#e[t] && !n.#e[t] ? s(r.#s[t], [l]) : !r.#e[t] && n.#e[t] ? s([l], n.#s[t]) : s(r.#s[t], n.#s[t]);
    }
    get protocol() {
      return this.#e.protocol;
    }
    get username() {
      return this.#e.username;
    }
    get password() {
      return this.#e.password;
    }
    get hostname() {
      return this.#e.hostname;
    }
    get port() {
      return this.#e.port;
    }
    get pathname() {
      return this.#e.pathname;
    }
    get search() {
      return this.#e.search;
    }
    get hash() {
      return this.#e.hash;
    }
    get hasRegExpGroups() {
      return this.#l;
    }
  };
});

// ../../node_modules/urlpattern-polyfill/index.cjs
var require_urlpattern_polyfill = __commonJS((exports, module) => {
  var { URLPattern } = require_urlpattern();
  module.exports = { URLPattern };
  if (!globalThis.URLPattern) {
    globalThis.URLPattern = URLPattern;
  }
});

// ../../node_modules/@whatwg-node/node-fetch/node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async });
      } else if (async) {
        env.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env) {
      function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
  });
});

// ../../node_modules/busboy/lib/utils.js
var require_utils = __commonJS((exports, module) => {
  var parseContentType = function(str) {
    if (str.length === 0)
      return;
    const params = Object.create(null);
    let i = 0;
    for (;i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (code !== 47 || i === 0)
          return;
        break;
      }
    }
    if (i === str.length)
      return;
    const type2 = str.slice(0, i).toLowerCase();
    const subtypeStart = ++i;
    for (;i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (i === subtypeStart)
          return;
        if (parseContentTypeParams(str, i, params) === undefined)
          return;
        break;
      }
    }
    if (i === subtypeStart)
      return;
    const subtype = str.slice(subtypeStart, i).toLowerCase();
    return { type: type2, subtype, params };
  };
  var parseContentTypeParams = function(str, i, params) {
    while (i < str.length) {
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        break;
      if (str.charCodeAt(i++) !== 59)
        return;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        return;
      let name;
      const nameStart = i;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (code !== 61)
            return;
          break;
        }
      }
      if (i === str.length)
        return;
      name = str.slice(nameStart, i);
      ++i;
      if (i === str.length)
        return;
      let value = "";
      let valueStart;
      if (str.charCodeAt(i) === 34) {
        valueStart = ++i;
        let escaping = false;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code === 92) {
            if (escaping) {
              valueStart = i;
              escaping = false;
            } else {
              value += str.slice(valueStart, i);
              escaping = true;
            }
            continue;
          }
          if (code === 34) {
            if (escaping) {
              valueStart = i;
              escaping = false;
              continue;
            }
            value += str.slice(valueStart, i);
            break;
          }
          if (escaping) {
            valueStart = i - 1;
            escaping = false;
          }
          if (QDTEXT[code] !== 1)
            return;
        }
        if (i === str.length)
          return;
        ++i;
      } else {
        valueStart = i;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (TOKEN[code] !== 1) {
            if (i === valueStart)
              return;
            break;
          }
        }
        value = str.slice(valueStart, i);
      }
      name = name.toLowerCase();
      if (params[name] === undefined)
        params[name] = value;
    }
    return params;
  };
  var parseDisposition = function(str, defDecoder) {
    if (str.length === 0)
      return;
    const params = Object.create(null);
    let i = 0;
    for (;i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (parseDispositionParams(str, i, params, defDecoder) === undefined)
          return;
        break;
      }
    }
    const type2 = str.slice(0, i).toLowerCase();
    return { type: type2, params };
  };
  var parseDispositionParams = function(str, i, params, defDecoder) {
    while (i < str.length) {
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        break;
      if (str.charCodeAt(i++) !== 59)
        return;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        return;
      let name;
      const nameStart = i;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (code === 61)
            break;
          return;
        }
      }
      if (i === str.length)
        return;
      let value = "";
      let valueStart;
      let charset;
      name = str.slice(nameStart, i);
      if (name.charCodeAt(name.length - 1) === 42) {
        const charsetStart = ++i;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (CHARSET[code] !== 1) {
            if (code !== 39)
              return;
            break;
          }
        }
        if (i === str.length)
          return;
        charset = str.slice(charsetStart, i);
        ++i;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code === 39)
            break;
        }
        if (i === str.length)
          return;
        ++i;
        if (i === str.length)
          return;
        valueStart = i;
        let encode = 0;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (EXTENDED_VALUE[code] !== 1) {
            if (code === 37) {
              let hexUpper;
              let hexLower;
              if (i + 2 < str.length && (hexUpper = HEX_VALUES[str.charCodeAt(i + 1)]) !== -1 && (hexLower = HEX_VALUES[str.charCodeAt(i + 2)]) !== -1) {
                const byteVal = (hexUpper << 4) + hexLower;
                value += str.slice(valueStart, i);
                value += String.fromCharCode(byteVal);
                i += 2;
                valueStart = i + 1;
                if (byteVal >= 128)
                  encode = 2;
                else if (encode === 0)
                  encode = 1;
                continue;
              }
              return;
            }
            break;
          }
        }
        value += str.slice(valueStart, i);
        value = convertToUTF8(value, charset, encode);
        if (value === undefined)
          return;
      } else {
        ++i;
        if (i === str.length)
          return;
        if (str.charCodeAt(i) === 34) {
          valueStart = ++i;
          let escaping = false;
          for (;i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (code === 92) {
              if (escaping) {
                valueStart = i;
                escaping = false;
              } else {
                value += str.slice(valueStart, i);
                escaping = true;
              }
              continue;
            }
            if (code === 34) {
              if (escaping) {
                valueStart = i;
                escaping = false;
                continue;
              }
              value += str.slice(valueStart, i);
              break;
            }
            if (escaping) {
              valueStart = i - 1;
              escaping = false;
            }
            if (QDTEXT[code] !== 1)
              return;
          }
          if (i === str.length)
            return;
          ++i;
        } else {
          valueStart = i;
          for (;i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (TOKEN[code] !== 1) {
              if (i === valueStart)
                return;
              break;
            }
          }
          value = str.slice(valueStart, i);
        }
        value = defDecoder(value, 2);
        if (value === undefined)
          return;
      }
      name = name.toLowerCase();
      if (params[name] === undefined)
        params[name] = value;
    }
    return params;
  };
  var getDecoder = function(charset) {
    let lc;
    while (true) {
      switch (charset) {
        case "utf-8":
        case "utf8":
          return decoders.utf8;
        case "latin1":
        case "ascii":
        case "us-ascii":
        case "iso-8859-1":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "windows-1252":
        case "iso_8859-1:1987":
        case "cp1252":
        case "x-cp1252":
          return decoders.latin1;
        case "utf16le":
        case "utf-16le":
        case "ucs2":
        case "ucs-2":
          return decoders.utf16le;
        case "base64":
          return decoders.base64;
        default:
          if (lc === undefined) {
            lc = true;
            charset = charset.toLowerCase();
            continue;
          }
          return decoders.other.bind(charset);
      }
    }
  };
  var convertToUTF8 = function(data, charset, hint) {
    const decode = getDecoder(charset);
    if (decode)
      return decode(data, hint);
  };
  var basename = function(path) {
    if (typeof path !== "string")
      return "";
    for (let i = path.length - 1;i >= 0; --i) {
      switch (path.charCodeAt(i)) {
        case 47:
        case 92:
          path = path.slice(i + 1);
          return path === ".." || path === "." ? "" : path;
      }
    }
    return path === ".." || path === "." ? "" : path;
  };
  var decoders = {
    utf8: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string") {
        if (hint < 2)
          return data;
        data = Buffer.from(data, "latin1");
      }
      return data.utf8Slice(0, data.length);
    },
    latin1: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        return data;
      return data.latin1Slice(0, data.length);
    },
    utf16le: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      return data.ucs2Slice(0, data.length);
    },
    base64: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      return data.base64Slice(0, data.length);
    },
    other: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      try {
        const decoder = new TextDecoder(exports);
        return decoder.decode(data);
      } catch {
      }
    }
  };
  var TOKEN = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var QDTEXT = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ];
  var CHARSET = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var EXTENDED_VALUE = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var HEX_VALUES = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  module.exports = {
    basename,
    convertToUTF8,
    getDecoder,
    parseContentType,
    parseDisposition
  };
});

// ../../node_modules/streamsearch/lib/sbmh.js
var require_sbmh = __commonJS((exports, module) => {
  var memcmp = function(buf1, pos1, buf2, pos2, num) {
    for (let i = 0;i < num; ++i) {
      if (buf1[pos1 + i] !== buf2[pos2 + i])
        return false;
    }
    return true;
  };
  var feed = function(self2, data) {
    const len = data.length;
    const needle = self2._needle;
    const needleLen = needle.length;
    let pos = -self2._lookbehindSize;
    const lastNeedleCharPos = needleLen - 1;
    const lastNeedleChar = needle[lastNeedleCharPos];
    const end = len - needleLen;
    const occ = self2._occ;
    const lookbehind = self2._lookbehind;
    if (pos < 0) {
      while (pos < 0 && pos <= end) {
        const nextPos = pos + lastNeedleCharPos;
        const ch = nextPos < 0 ? lookbehind[self2._lookbehindSize + nextPos] : data[nextPos];
        if (ch === lastNeedleChar && matchNeedle(self2, data, pos, lastNeedleCharPos)) {
          self2._lookbehindSize = 0;
          ++self2.matches;
          if (pos > -self2._lookbehindSize)
            self2._cb(true, lookbehind, 0, self2._lookbehindSize + pos, false);
          else
            self2._cb(true, undefined, 0, 0, true);
          return self2._bufPos = pos + needleLen;
        }
        pos += occ[ch];
      }
      while (pos < 0 && !matchNeedle(self2, data, pos, len - pos))
        ++pos;
      if (pos < 0) {
        const bytesToCutOff = self2._lookbehindSize + pos;
        if (bytesToCutOff > 0) {
          self2._cb(false, lookbehind, 0, bytesToCutOff, false);
        }
        self2._lookbehindSize -= bytesToCutOff;
        lookbehind.copy(lookbehind, 0, bytesToCutOff, self2._lookbehindSize);
        lookbehind.set(data, self2._lookbehindSize);
        self2._lookbehindSize += len;
        self2._bufPos = len;
        return len;
      }
      self2._cb(false, lookbehind, 0, self2._lookbehindSize, false);
      self2._lookbehindSize = 0;
    }
    pos += self2._bufPos;
    const firstNeedleChar = needle[0];
    while (pos <= end) {
      const ch = data[pos + lastNeedleCharPos];
      if (ch === lastNeedleChar && data[pos] === firstNeedleChar && memcmp(needle, 0, data, pos, lastNeedleCharPos)) {
        ++self2.matches;
        if (pos > 0)
          self2._cb(true, data, self2._bufPos, pos, true);
        else
          self2._cb(true, undefined, 0, 0, true);
        return self2._bufPos = pos + needleLen;
      }
      pos += occ[ch];
    }
    while (pos < len) {
      if (data[pos] !== firstNeedleChar || !memcmp(data, pos, needle, 0, len - pos)) {
        ++pos;
        continue;
      }
      data.copy(lookbehind, 0, pos, len);
      self2._lookbehindSize = len - pos;
      break;
    }
    if (pos > 0)
      self2._cb(false, data, self2._bufPos, pos < len ? pos : len, true);
    self2._bufPos = len;
    return len;
  };
  var matchNeedle = function(self2, data, pos, len) {
    const lb = self2._lookbehind;
    const lbSize = self2._lookbehindSize;
    const needle = self2._needle;
    for (let i = 0;i < len; ++i, ++pos) {
      const ch = pos < 0 ? lb[lbSize + pos] : data[pos];
      if (ch !== needle[i])
        return false;
    }
    return true;
  };

  class SBMH {
    constructor(needle, cb) {
      if (typeof cb !== "function")
        throw new Error("Missing match callback");
      if (typeof needle === "string")
        needle = Buffer.from(needle);
      else if (!Buffer.isBuffer(needle))
        throw new Error(`Expected Buffer for needle, got ${typeof needle}`);
      const needleLen = needle.length;
      this.maxMatches = Infinity;
      this.matches = 0;
      this._cb = cb;
      this._lookbehindSize = 0;
      this._needle = needle;
      this._bufPos = 0;
      this._lookbehind = Buffer.allocUnsafe(needleLen);
      this._occ = [
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen
      ];
      if (needleLen > 1) {
        for (let i = 0;i < needleLen - 1; ++i)
          this._occ[needle[i]] = needleLen - 1 - i;
      }
    }
    reset() {
      this.matches = 0;
      this._lookbehindSize = 0;
      this._bufPos = 0;
    }
    push(chunk, pos) {
      let result;
      if (!Buffer.isBuffer(chunk))
        chunk = Buffer.from(chunk, "latin1");
      const chunkLen = chunk.length;
      this._bufPos = pos || 0;
      while (result !== chunkLen && this.matches < this.maxMatches)
        result = feed(this, chunk);
      return result;
    }
    destroy() {
      const lbSize = this._lookbehindSize;
      if (lbSize)
        this._cb(false, this._lookbehind, 0, lbSize, false);
      this.reset();
    }
  }
  module.exports = SBMH;
});

// ../../node_modules/busboy/lib/types/multipart.js
var require_multipart = __commonJS((exports, module) => {
  var noop2 = function() {
  };
  var callAndUnsetCb = function(self2, err) {
    const cb = self2._writecb;
    self2._writecb = null;
    if (err)
      self2.destroy(err);
    else if (cb)
      cb();
  };
  var nullDecoder = function(val, hint) {
    return val;
  };
  var finalcb = function(self2, cb, err) {
    if (err)
      return cb(err);
    err = checkEndState(self2);
    cb(err);
  };
  var checkEndState = function(self2) {
    if (self2._hparser)
      return new Error("Malformed part header");
    const fileStream = self2._fileStream;
    if (fileStream) {
      self2._fileStream = null;
      fileStream.destroy(new Error("Unexpected end of file"));
    }
    if (!self2._complete)
      return new Error("Unexpected end of form");
  };
  var { Readable, Writable } = import.meta.require("stream");
  var StreamSearch = require_sbmh();
  var {
    basename,
    convertToUTF8,
    getDecoder,
    parseContentType,
    parseDisposition
  } = require_utils();
  var BUF_CRLF = Buffer.from("\r\n");
  var BUF_CR = Buffer.from("\r");
  var BUF_DASH = Buffer.from("-");
  var MAX_HEADER_PAIRS = 2000;
  var MAX_HEADER_SIZE = 16 * 1024;
  var HPARSER_NAME = 0;
  var HPARSER_PRE_OWS = 1;
  var HPARSER_VALUE = 2;

  class HeaderParser {
    constructor(cb) {
      this.header = Object.create(null);
      this.pairCount = 0;
      this.byteCount = 0;
      this.state = HPARSER_NAME;
      this.name = "";
      this.value = "";
      this.crlf = 0;
      this.cb = cb;
    }
    reset() {
      this.header = Object.create(null);
      this.pairCount = 0;
      this.byteCount = 0;
      this.state = HPARSER_NAME;
      this.name = "";
      this.value = "";
      this.crlf = 0;
    }
    push(chunk, pos, end) {
      let start = pos;
      while (pos < end) {
        switch (this.state) {
          case HPARSER_NAME: {
            let done = false;
            for (;pos < end; ++pos) {
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              const code = chunk[pos];
              if (TOKEN[code] !== 1) {
                if (code !== 58)
                  return -1;
                this.name += chunk.latin1Slice(start, pos);
                if (this.name.length === 0)
                  return -1;
                ++pos;
                done = true;
                this.state = HPARSER_PRE_OWS;
                break;
              }
            }
            if (!done) {
              this.name += chunk.latin1Slice(start, pos);
              break;
            }
          }
          case HPARSER_PRE_OWS: {
            let done = false;
            for (;pos < end; ++pos) {
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              const code = chunk[pos];
              if (code !== 32 && code !== 9) {
                start = pos;
                done = true;
                this.state = HPARSER_VALUE;
                break;
              }
            }
            if (!done)
              break;
          }
          case HPARSER_VALUE:
            switch (this.crlf) {
              case 0:
                for (;pos < end; ++pos) {
                  if (this.byteCount === MAX_HEADER_SIZE)
                    return -1;
                  ++this.byteCount;
                  const code = chunk[pos];
                  if (FIELD_VCHAR[code] !== 1) {
                    if (code !== 13)
                      return -1;
                    ++this.crlf;
                    break;
                  }
                }
                this.value += chunk.latin1Slice(start, pos++);
                break;
              case 1:
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                if (chunk[pos++] !== 10)
                  return -1;
                ++this.crlf;
                break;
              case 2: {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                const code = chunk[pos];
                if (code === 32 || code === 9) {
                  start = pos;
                  this.crlf = 0;
                } else {
                  if (++this.pairCount < MAX_HEADER_PAIRS) {
                    this.name = this.name.toLowerCase();
                    if (this.header[this.name] === undefined)
                      this.header[this.name] = [this.value];
                    else
                      this.header[this.name].push(this.value);
                  }
                  if (code === 13) {
                    ++this.crlf;
                    ++pos;
                  } else {
                    start = pos;
                    this.crlf = 0;
                    this.state = HPARSER_NAME;
                    this.name = "";
                    this.value = "";
                  }
                }
                break;
              }
              case 3: {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                if (chunk[pos++] !== 10)
                  return -1;
                const header = this.header;
                this.reset();
                this.cb(header);
                return pos;
              }
            }
            break;
        }
      }
      return pos;
    }
  }

  class FileStream extends Readable {
    constructor(opts, owner) {
      super(opts);
      this.truncated = false;
      this._readcb = null;
      this.once("end", () => {
        this._read();
        if (--owner._fileEndsLeft === 0 && owner._finalcb) {
          const cb = owner._finalcb;
          owner._finalcb = null;
          process.nextTick(cb);
        }
      });
    }
    _read(n) {
      const cb = this._readcb;
      if (cb) {
        this._readcb = null;
        cb();
      }
    }
  }
  var ignoreData = {
    push: (chunk, pos) => {
    },
    destroy: () => {
    }
  };

  class Multipart extends Writable {
    constructor(cfg) {
      const streamOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : undefined
      };
      super(streamOpts);
      if (!cfg.conType.params || typeof cfg.conType.params.boundary !== "string")
        throw new Error("Multipart: Boundary not found");
      const boundary = cfg.conType.params.boundary;
      const paramDecoder = typeof cfg.defParamCharset === "string" && cfg.defParamCharset ? getDecoder(cfg.defParamCharset) : nullDecoder;
      const defCharset = cfg.defCharset || "utf8";
      const preservePath = cfg.preservePath;
      const fileOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.fileHwm === "number" ? cfg.fileHwm : undefined
      };
      const limits = cfg.limits;
      const fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
      const fileSizeLimit = limits && typeof limits.fileSize === "number" ? limits.fileSize : Infinity;
      const filesLimit = limits && typeof limits.files === "number" ? limits.files : Infinity;
      const fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
      const partsLimit = limits && typeof limits.parts === "number" ? limits.parts : Infinity;
      let parts = -1;
      let fields5 = 0;
      let files = 0;
      let skipPart = false;
      this._fileEndsLeft = 0;
      this._fileStream = undefined;
      this._complete = false;
      let fileSize = 0;
      let field;
      let fieldSize = 0;
      let partCharset;
      let partEncoding;
      let partType;
      let partName;
      let partTruncated = false;
      let hitFilesLimit = false;
      let hitFieldsLimit = false;
      this._hparser = null;
      const hparser = new HeaderParser((header) => {
        this._hparser = null;
        skipPart = false;
        partType = "text/plain";
        partCharset = defCharset;
        partEncoding = "7bit";
        partName = undefined;
        partTruncated = false;
        let filename;
        if (!header["content-disposition"]) {
          skipPart = true;
          return;
        }
        const disp = parseDisposition(header["content-disposition"][0], paramDecoder);
        if (!disp || disp.type !== "form-data") {
          skipPart = true;
          return;
        }
        if (disp.params) {
          if (disp.params.name)
            partName = disp.params.name;
          if (disp.params["filename*"])
            filename = disp.params["filename*"];
          else if (disp.params.filename)
            filename = disp.params.filename;
          if (filename !== undefined && !preservePath)
            filename = basename(filename);
        }
        if (header["content-type"]) {
          const conType = parseContentType(header["content-type"][0]);
          if (conType) {
            partType = `${conType.type}/${conType.subtype}`;
            if (conType.params && typeof conType.params.charset === "string")
              partCharset = conType.params.charset.toLowerCase();
          }
        }
        if (header["content-transfer-encoding"])
          partEncoding = header["content-transfer-encoding"][0].toLowerCase();
        if (partType === "application/octet-stream" || filename !== undefined) {
          if (files === filesLimit) {
            if (!hitFilesLimit) {
              hitFilesLimit = true;
              this.emit("filesLimit");
            }
            skipPart = true;
            return;
          }
          ++files;
          if (this.listenerCount("file") === 0) {
            skipPart = true;
            return;
          }
          fileSize = 0;
          this._fileStream = new FileStream(fileOpts, this);
          ++this._fileEndsLeft;
          this.emit("file", partName, this._fileStream, {
            filename,
            encoding: partEncoding,
            mimeType: partType
          });
        } else {
          if (fields5 === fieldsLimit) {
            if (!hitFieldsLimit) {
              hitFieldsLimit = true;
              this.emit("fieldsLimit");
            }
            skipPart = true;
            return;
          }
          ++fields5;
          if (this.listenerCount("field") === 0) {
            skipPart = true;
            return;
          }
          field = [];
          fieldSize = 0;
        }
      });
      let matchPostBoundary = 0;
      const ssCb = (isMatch, data, start, end, isDataSafe) => {
        retrydata:
          while (data) {
            if (this._hparser !== null) {
              const ret = this._hparser.push(data, start, end);
              if (ret === -1) {
                this._hparser = null;
                hparser.reset();
                this.emit("error", new Error("Malformed part header"));
                break;
              }
              start = ret;
            }
            if (start === end)
              break;
            if (matchPostBoundary !== 0) {
              if (matchPostBoundary === 1) {
                switch (data[start]) {
                  case 45:
                    matchPostBoundary = 2;
                    ++start;
                    break;
                  case 13:
                    matchPostBoundary = 3;
                    ++start;
                    break;
                  default:
                    matchPostBoundary = 0;
                }
                if (start === end)
                  return;
              }
              if (matchPostBoundary === 2) {
                matchPostBoundary = 0;
                if (data[start] === 45) {
                  this._complete = true;
                  this._bparser = ignoreData;
                  return;
                }
                const writecb = this._writecb;
                this._writecb = noop2;
                ssCb(false, BUF_DASH, 0, 1, false);
                this._writecb = writecb;
              } else if (matchPostBoundary === 3) {
                matchPostBoundary = 0;
                if (data[start] === 10) {
                  ++start;
                  if (parts >= partsLimit)
                    break;
                  this._hparser = hparser;
                  if (start === end)
                    break;
                  continue retrydata;
                } else {
                  const writecb = this._writecb;
                  this._writecb = noop2;
                  ssCb(false, BUF_CR, 0, 1, false);
                  this._writecb = writecb;
                }
              }
            }
            if (!skipPart) {
              if (this._fileStream) {
                let chunk;
                const actualLen = Math.min(end - start, fileSizeLimit - fileSize);
                if (!isDataSafe) {
                  chunk = Buffer.allocUnsafe(actualLen);
                  data.copy(chunk, 0, start, start + actualLen);
                } else {
                  chunk = data.slice(start, start + actualLen);
                }
                fileSize += chunk.length;
                if (fileSize === fileSizeLimit) {
                  if (chunk.length > 0)
                    this._fileStream.push(chunk);
                  this._fileStream.emit("limit");
                  this._fileStream.truncated = true;
                  skipPart = true;
                } else if (!this._fileStream.push(chunk)) {
                  if (this._writecb)
                    this._fileStream._readcb = this._writecb;
                  this._writecb = null;
                }
              } else if (field !== undefined) {
                let chunk;
                const actualLen = Math.min(end - start, fieldSizeLimit - fieldSize);
                if (!isDataSafe) {
                  chunk = Buffer.allocUnsafe(actualLen);
                  data.copy(chunk, 0, start, start + actualLen);
                } else {
                  chunk = data.slice(start, start + actualLen);
                }
                fieldSize += actualLen;
                field.push(chunk);
                if (fieldSize === fieldSizeLimit) {
                  skipPart = true;
                  partTruncated = true;
                }
              }
            }
            break;
          }
        if (isMatch) {
          matchPostBoundary = 1;
          if (this._fileStream) {
            this._fileStream.push(null);
            this._fileStream = null;
          } else if (field !== undefined) {
            let data2;
            switch (field.length) {
              case 0:
                data2 = "";
                break;
              case 1:
                data2 = convertToUTF8(field[0], partCharset, 0);
                break;
              default:
                data2 = convertToUTF8(Buffer.concat(field, fieldSize), partCharset, 0);
            }
            field = undefined;
            fieldSize = 0;
            this.emit("field", partName, data2, {
              nameTruncated: false,
              valueTruncated: partTruncated,
              encoding: partEncoding,
              mimeType: partType
            });
          }
          if (++parts === partsLimit)
            this.emit("partsLimit");
        }
      };
      this._bparser = new StreamSearch(`\r\n--${boundary}`, ssCb);
      this._writecb = null;
      this._finalcb = null;
      this.write(BUF_CRLF);
    }
    static detect(conType) {
      return conType.type === "multipart" && conType.subtype === "form-data";
    }
    _write(chunk, enc, cb) {
      this._writecb = cb;
      this._bparser.push(chunk, 0);
      if (this._writecb)
        callAndUnsetCb(this);
    }
    _destroy(err, cb) {
      this._hparser = null;
      this._bparser = ignoreData;
      if (!err)
        err = checkEndState(this);
      const fileStream = this._fileStream;
      if (fileStream) {
        this._fileStream = null;
        fileStream.destroy(err);
      }
      cb(err);
    }
    _final(cb) {
      this._bparser.destroy();
      if (!this._complete)
        return cb(new Error("Unexpected end of form"));
      if (this._fileEndsLeft)
        this._finalcb = finalcb.bind(null, this, cb);
      else
        finalcb(this, cb);
    }
  }
  var TOKEN = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var FIELD_VCHAR = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ];
  module.exports = Multipart;
});

// ../../node_modules/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS((exports, module) => {
  var readPctEnc = function(self2, chunk, pos, len) {
    if (pos >= len)
      return len;
    if (self2._byte === -1) {
      const hexUpper = HEX_VALUES[chunk[pos++]];
      if (hexUpper === -1)
        return -1;
      if (hexUpper >= 8)
        self2._encode = 2;
      if (pos < len) {
        const hexLower = HEX_VALUES[chunk[pos++]];
        if (hexLower === -1)
          return -1;
        if (self2._inKey)
          self2._key += String.fromCharCode((hexUpper << 4) + hexLower);
        else
          self2._val += String.fromCharCode((hexUpper << 4) + hexLower);
        self2._byte = -2;
        self2._lastPos = pos;
      } else {
        self2._byte = hexUpper;
      }
    } else {
      const hexLower = HEX_VALUES[chunk[pos++]];
      if (hexLower === -1)
        return -1;
      if (self2._inKey)
        self2._key += String.fromCharCode((self2._byte << 4) + hexLower);
      else
        self2._val += String.fromCharCode((self2._byte << 4) + hexLower);
      self2._byte = -2;
      self2._lastPos = pos;
    }
    return pos;
  };
  var skipKeyBytes = function(self2, chunk, pos, len) {
    if (self2._bytesKey > self2.fieldNameSizeLimit) {
      if (!self2._keyTrunc) {
        if (self2._lastPos < pos)
          self2._key += chunk.latin1Slice(self2._lastPos, pos - 1);
      }
      self2._keyTrunc = true;
      for (;pos < len; ++pos) {
        const code = chunk[pos];
        if (code === 61 || code === 38)
          break;
        ++self2._bytesKey;
      }
      self2._lastPos = pos;
    }
    return pos;
  };
  var skipValBytes = function(self2, chunk, pos, len) {
    if (self2._bytesVal > self2.fieldSizeLimit) {
      if (!self2._valTrunc) {
        if (self2._lastPos < pos)
          self2._val += chunk.latin1Slice(self2._lastPos, pos - 1);
      }
      self2._valTrunc = true;
      for (;pos < len; ++pos) {
        if (chunk[pos] === 38)
          break;
        ++self2._bytesVal;
      }
      self2._lastPos = pos;
    }
    return pos;
  };
  var { Writable } = import.meta.require("stream");
  var { getDecoder } = require_utils();

  class URLEncoded extends Writable {
    constructor(cfg) {
      const streamOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : undefined
      };
      super(streamOpts);
      let charset = cfg.defCharset || "utf8";
      if (cfg.conType.params && typeof cfg.conType.params.charset === "string")
        charset = cfg.conType.params.charset;
      this.charset = charset;
      const limits = cfg.limits;
      this.fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
      this.fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
      this.fieldNameSizeLimit = limits && typeof limits.fieldNameSize === "number" ? limits.fieldNameSize : 100;
      this._inKey = true;
      this._keyTrunc = false;
      this._valTrunc = false;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._fields = 0;
      this._key = "";
      this._val = "";
      this._byte = -2;
      this._lastPos = 0;
      this._encode = 0;
      this._decoder = getDecoder(charset);
    }
    static detect(conType) {
      return conType.type === "application" && conType.subtype === "x-www-form-urlencoded";
    }
    _write(chunk, enc, cb) {
      if (this._fields >= this.fieldsLimit)
        return cb();
      let i = 0;
      const len = chunk.length;
      this._lastPos = 0;
      if (this._byte !== -2) {
        i = readPctEnc(this, chunk, i, len);
        if (i === -1)
          return cb(new Error("Malformed urlencoded form"));
        if (i >= len)
          return cb();
        if (this._inKey)
          ++this._bytesKey;
        else
          ++this._bytesVal;
      }
      main:
        while (i < len) {
          if (this._inKey) {
            i = skipKeyBytes(this, chunk, i, len);
            while (i < len) {
              switch (chunk[i]) {
                case 61:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._key = this._decoder(this._key, this._encode);
                  this._encode = 0;
                  this._inKey = false;
                  continue main;
                case 38:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._key = this._decoder(this._key, this._encode);
                  this._encode = 0;
                  if (this._bytesKey > 0) {
                    this.emit("field", this._key, "", {
                      nameTruncated: this._keyTrunc,
                      valueTruncated: false,
                      encoding: this.charset,
                      mimeType: "text/plain"
                    });
                  }
                  this._key = "";
                  this._val = "";
                  this._keyTrunc = false;
                  this._valTrunc = false;
                  this._bytesKey = 0;
                  this._bytesVal = 0;
                  if (++this._fields >= this.fieldsLimit) {
                    this.emit("fieldsLimit");
                    return cb();
                  }
                  continue;
                case 43:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._key += " ";
                  this._lastPos = i + 1;
                  break;
                case 37:
                  if (this._encode === 0)
                    this._encode = 1;
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = i + 1;
                  this._byte = -1;
                  i = readPctEnc(this, chunk, i + 1, len);
                  if (i === -1)
                    return cb(new Error("Malformed urlencoded form"));
                  if (i >= len)
                    return cb();
                  ++this._bytesKey;
                  i = skipKeyBytes(this, chunk, i, len);
                  continue;
              }
              ++i;
              ++this._bytesKey;
              i = skipKeyBytes(this, chunk, i, len);
            }
            if (this._lastPos < i)
              this._key += chunk.latin1Slice(this._lastPos, i);
          } else {
            i = skipValBytes(this, chunk, i, len);
            while (i < len) {
              switch (chunk[i]) {
                case 38:
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._inKey = true;
                  this._val = this._decoder(this._val, this._encode);
                  this._encode = 0;
                  if (this._bytesKey > 0 || this._bytesVal > 0) {
                    this.emit("field", this._key, this._val, {
                      nameTruncated: this._keyTrunc,
                      valueTruncated: this._valTrunc,
                      encoding: this.charset,
                      mimeType: "text/plain"
                    });
                  }
                  this._key = "";
                  this._val = "";
                  this._keyTrunc = false;
                  this._valTrunc = false;
                  this._bytesKey = 0;
                  this._bytesVal = 0;
                  if (++this._fields >= this.fieldsLimit) {
                    this.emit("fieldsLimit");
                    return cb();
                  }
                  continue main;
                case 43:
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._val += " ";
                  this._lastPos = i + 1;
                  break;
                case 37:
                  if (this._encode === 0)
                    this._encode = 1;
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = i + 1;
                  this._byte = -1;
                  i = readPctEnc(this, chunk, i + 1, len);
                  if (i === -1)
                    return cb(new Error("Malformed urlencoded form"));
                  if (i >= len)
                    return cb();
                  ++this._bytesVal;
                  i = skipValBytes(this, chunk, i, len);
                  continue;
              }
              ++i;
              ++this._bytesVal;
              i = skipValBytes(this, chunk, i, len);
            }
            if (this._lastPos < i)
              this._val += chunk.latin1Slice(this._lastPos, i);
          }
        }
      cb();
    }
    _final(cb) {
      if (this._byte !== -2)
        return cb(new Error("Malformed urlencoded form"));
      if (!this._inKey || this._bytesKey > 0 || this._bytesVal > 0) {
        if (this._inKey)
          this._key = this._decoder(this._key, this._encode);
        else
          this._val = this._decoder(this._val, this._encode);
        this.emit("field", this._key, this._val, {
          nameTruncated: this._keyTrunc,
          valueTruncated: this._valTrunc,
          encoding: this.charset,
          mimeType: "text/plain"
        });
      }
      cb();
    }
  }
  var HEX_VALUES = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  module.exports = URLEncoded;
});

// ../../node_modules/busboy/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var getInstance = function(cfg) {
    const headers = cfg.headers;
    const conType = parseContentType(headers["content-type"]);
    if (!conType)
      throw new Error("Malformed content type");
    for (const type2 of TYPES) {
      const matched = type2.detect(conType);
      if (!matched)
        continue;
      const instanceCfg = {
        limits: cfg.limits,
        headers,
        conType,
        highWaterMark: undefined,
        fileHwm: undefined,
        defCharset: undefined,
        defParamCharset: undefined,
        preservePath: false
      };
      if (cfg.highWaterMark)
        instanceCfg.highWaterMark = cfg.highWaterMark;
      if (cfg.fileHwm)
        instanceCfg.fileHwm = cfg.fileHwm;
      instanceCfg.defCharset = cfg.defCharset;
      instanceCfg.defParamCharset = cfg.defParamCharset;
      instanceCfg.preservePath = cfg.preservePath;
      return new type2(instanceCfg);
    }
    throw new Error(`Unsupported content type: ${headers["content-type"]}`);
  };
  var { parseContentType } = require_utils();
  var TYPES = [
    require_multipart(),
    require_urlencoded()
  ].filter(function(typemod) {
    return typeof typemod.detect === "function";
  });
  module.exports = (cfg) => {
    if (typeof cfg !== "object" || cfg === null)
      cfg = {};
    if (typeof cfg.headers !== "object" || cfg.headers === null || typeof cfg.headers["content-type"] !== "string") {
      throw new Error("Missing Content-Type");
    }
    return getInstance(cfg);
  };
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/utils.js
var require_utils2 = __commonJS((exports) => {
  var isHeadersInstance = function(obj) {
    return obj?.forEach != null;
  };
  var getHeadersObj = function(headers) {
    if (headers == null || !isHeadersInstance(headers)) {
      return headers;
    }
    const obj = {};
    headers.forEach((value, key) => {
      obj[key] = value;
    });
    return obj;
  };
  var defaultHeadersSerializer = function(headers, onContentLength) {
    const headerArray = [];
    headers.forEach((value, key) => {
      if (onContentLength && key === "content-length") {
        onContentLength(value);
      }
      headerArray.push(`${key}: ${value}`);
    });
    return headerArray;
  };
  var isPromise4 = function(val) {
    return val?.then != null;
  };
  var fakePromise = function(value) {
    if (isPromise4(value)) {
      return value;
    }
    return {
      then(resolve) {
        if (resolve) {
          const callbackResult = resolve(value);
          if (isPromise4(callbackResult)) {
            return callbackResult;
          }
          return fakePromise(callbackResult);
        }
        return this;
      },
      catch() {
        return this;
      },
      finally(cb) {
        if (cb) {
          const callbackResult = cb();
          if (isPromise4(callbackResult)) {
            return callbackResult.then(() => value);
          }
          return fakePromise(value);
        }
        return this;
      },
      [Symbol.toStringTag]: "Promise"
    };
  };
  var isArrayBufferView = function(obj) {
    return obj != null && obj.buffer != null && obj.byteLength != null && obj.byteOffset != null;
  };
  var isNodeReadable = function(obj) {
    return obj != null && obj.pipe != null;
  };
  var createDeferredPromise = function() {
    let resolveFn;
    let rejectFn;
    const promise = new Promise(function deferredPromiseExecutor(resolve, reject) {
      resolveFn = resolve;
      rejectFn = reject;
    });
    return {
      promise,
      get resolve() {
        return resolveFn;
      },
      get reject() {
        return rejectFn;
      }
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getHeadersObj = getHeadersObj;
  exports.defaultHeadersSerializer = defaultHeadersSerializer;
  exports.fakePromise = fakePromise;
  exports.isArrayBufferView = isArrayBufferView;
  exports.isNodeReadable = isNodeReadable;
  exports.createDeferredPromise = createDeferredPromise;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/ReadableStream.js
var require_ReadableStream = __commonJS((exports) => {
  var createController = function(desiredSize, readable) {
    let chunks = [];
    let _closed = false;
    let flushed = false;
    return {
      desiredSize,
      enqueue(chunk) {
        const buf = typeof chunk === "string" ? Buffer.from(chunk) : chunk;
        if (!flushed) {
          chunks.push(buf);
        } else {
          readable.push(buf);
        }
      },
      close() {
        if (chunks.length > 0) {
          this._flush();
        }
        readable.push(null);
        _closed = true;
      },
      error(error) {
        if (chunks.length > 0) {
          this._flush();
        }
        readable.destroy(error);
      },
      get _closed() {
        return _closed;
      },
      _flush() {
        flushed = true;
        if (chunks.length > 0) {
          const concatenated = chunks.length > 1 ? Buffer.concat(chunks) : chunks[0];
          readable.push(concatenated);
          chunks = [];
        }
      }
    };
  };
  var isNodeReadable = function(obj) {
    return obj?.read != null;
  };
  var isReadableStream = function(obj) {
    return obj?.getReader != null;
  };
  var isPonyfillWritableStream = function(obj) {
    return obj?.writable != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillReadableStream = undefined;
  var stream_1 = import.meta.require("stream");
  var utils_js_1 = require_utils2();

  class PonyfillReadableStream {
    readable;
    constructor(underlyingSource) {
      if (underlyingSource instanceof PonyfillReadableStream && underlyingSource.readable != null) {
        this.readable = underlyingSource.readable;
      } else if (isNodeReadable(underlyingSource)) {
        this.readable = underlyingSource;
      } else if (isReadableStream(underlyingSource)) {
        this.readable = stream_1.Readable.fromWeb(underlyingSource);
      } else {
        let started = false;
        let ongoing = false;
        this.readable = new stream_1.Readable({
          read(desiredSize) {
            if (ongoing) {
              return;
            }
            ongoing = true;
            return Promise.resolve().then(async () => {
              if (!started) {
                const controller2 = createController(desiredSize, this);
                started = true;
                await underlyingSource?.start?.(controller2);
                controller2._flush();
                if (controller2._closed) {
                  return;
                }
              }
              const controller = createController(desiredSize, this);
              await underlyingSource?.pull?.(controller);
              controller._flush();
              ongoing = false;
            });
          },
          destroy(err, callback) {
            if (underlyingSource?.cancel) {
              try {
                const res$ = underlyingSource.cancel(err);
                if (res$?.then) {
                  return res$.then(() => {
                    callback(null);
                  }, (err2) => {
                    callback(err2);
                  });
                }
              } catch (err2) {
                callback(err2);
                return;
              }
            }
            callback(null);
          }
        });
      }
    }
    cancel(reason) {
      this.readable.destroy(reason);
      return new Promise((resolve) => this.readable.once("end", resolve));
    }
    locked = false;
    getReader(_options) {
      const iterator = this.readable[Symbol.asyncIterator]();
      this.locked = true;
      return {
        read() {
          return iterator.next();
        },
        releaseLock: () => {
          if (iterator.return) {
            const retResult$ = iterator.return();
            if (retResult$.then) {
              retResult$.then(() => {
                this.locked = false;
              });
              return;
            }
          }
          this.locked = false;
        },
        cancel: (reason) => {
          if (iterator.return) {
            const retResult$ = iterator.return(reason);
            if (retResult$.then) {
              return retResult$.then(() => {
                this.locked = false;
              });
            }
          }
          this.locked = false;
          return (0, utils_js_1.fakePromise)(undefined);
        },
        closed: new Promise((resolve, reject) => {
          this.readable.once("end", resolve);
          this.readable.once("error", reject);
        })
      };
    }
    [Symbol.asyncIterator]() {
      return this.readable[Symbol.asyncIterator]();
    }
    tee() {
      throw new Error("Not implemented");
    }
    pipeTo(destination) {
      if (isPonyfillWritableStream(destination)) {
        return new Promise((resolve, reject) => {
          this.readable.pipe(destination.writable);
          destination.writable.once("finish", resolve);
          destination.writable.once("error", reject);
        });
      } else {
        const writer = destination.getWriter();
        return Promise.resolve().then(async () => {
          try {
            for await (const chunk of this) {
              await writer.write(chunk);
            }
            await writer.close();
          } catch (err) {
            await writer.abort(err);
          }
        });
      }
    }
    pipeThrough({ writable, readable }) {
      this.pipeTo(writable);
      return readable;
    }
    static [Symbol.hasInstance](instance) {
      return isReadableStream(instance);
    }
  }
  exports.PonyfillReadableStream = PonyfillReadableStream;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/Blob.js
var require_Blob = __commonJS((exports) => {
  var getBlobPartAsBuffer = function(blobPart) {
    if (typeof blobPart === "string") {
      return Buffer.from(blobPart);
    } else if (Buffer.isBuffer(blobPart)) {
      return blobPart;
    } else if ((0, utils_js_1.isArrayBufferView)(blobPart)) {
      return Buffer.from(blobPart.buffer, blobPart.byteOffset, blobPart.byteLength);
    } else {
      return Buffer.from(blobPart);
    }
  };
  var hasBufferMethod = function(obj) {
    return obj != null && obj.buffer != null && typeof obj.buffer === "function";
  };
  var hasArrayBufferMethod = function(obj) {
    return obj != null && obj.arrayBuffer != null && typeof obj.arrayBuffer === "function";
  };
  var hasBytesMethod = function(obj) {
    return obj != null && obj.bytes != null && typeof obj.bytes === "function";
  };
  var hasTextMethod = function(obj) {
    return obj != null && obj.text != null && typeof obj.text === "function";
  };
  var hasSizeProperty = function(obj) {
    return obj != null && typeof obj.size === "number";
  };
  var hasStreamMethod = function(obj) {
    return obj != null && obj.stream != null && typeof obj.stream === "function";
  };
  var hasBlobSignature = function(obj) {
    return obj != null && obj[Symbol.toStringTag] === "Blob";
  };
  var isArrayBuffer = function(obj) {
    return obj != null && obj.byteLength != null && obj.slice != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillBlob = undefined;
  exports.hasBufferMethod = hasBufferMethod;
  exports.hasArrayBufferMethod = hasArrayBufferMethod;
  exports.hasBytesMethod = hasBytesMethod;
  exports.hasTextMethod = hasTextMethod;
  exports.hasSizeProperty = hasSizeProperty;
  exports.hasStreamMethod = hasStreamMethod;
  exports.hasBlobSignature = hasBlobSignature;
  exports.isArrayBuffer = isArrayBuffer;
  var ReadableStream_js_1 = require_ReadableStream();
  var utils_js_1 = require_utils2();

  class PonyfillBlob {
    blobParts;
    type;
    encoding;
    _size = null;
    constructor(blobParts = [], options) {
      this.blobParts = blobParts;
      this.type = options?.type || "application/octet-stream";
      this.encoding = options?.encoding || "utf8";
      this._size = options?.size || null;
      if (blobParts.length === 1 && hasBlobSignature(blobParts[0])) {
        return blobParts[0];
      }
    }
    _buffer = null;
    buffer() {
      if (this._buffer) {
        return (0, utils_js_1.fakePromise)(this._buffer);
      }
      if (this.blobParts.length === 1) {
        const blobPart = this.blobParts[0];
        if (hasBufferMethod(blobPart)) {
          return blobPart.buffer().then((buf) => {
            this._buffer = buf;
            return this._buffer;
          });
        }
        if (hasBytesMethod(blobPart)) {
          return blobPart.bytes().then((bytes) => {
            this._buffer = Buffer.from(bytes);
            return this._buffer;
          });
        }
        if (hasArrayBufferMethod(blobPart)) {
          return blobPart.arrayBuffer().then((arrayBuf) => {
            this._buffer = Buffer.from(arrayBuf, undefined, blobPart.size);
            return this._buffer;
          });
        }
        this._buffer = getBlobPartAsBuffer(blobPart);
        return (0, utils_js_1.fakePromise)(this._buffer);
      }
      const jobs = [];
      const bufferChunks = this.blobParts.map((blobPart, i) => {
        if (hasBufferMethod(blobPart)) {
          jobs.push(blobPart.buffer().then((buf) => {
            bufferChunks[i] = buf;
          }));
          return;
        } else if (hasArrayBufferMethod(blobPart)) {
          jobs.push(blobPart.arrayBuffer().then((arrayBuf) => {
            bufferChunks[i] = Buffer.from(arrayBuf, undefined, blobPart.size);
          }));
          return;
        } else if (hasBytesMethod(blobPart)) {
          jobs.push(blobPart.bytes().then((bytes) => {
            bufferChunks[i] = Buffer.from(bytes);
          }));
          return;
        } else {
          return getBlobPartAsBuffer(blobPart);
        }
      });
      if (jobs.length > 0) {
        return Promise.all(jobs).then(() => Buffer.concat(bufferChunks, this._size || undefined));
      }
      return (0, utils_js_1.fakePromise)(Buffer.concat(bufferChunks, this._size || undefined));
    }
    arrayBuffer() {
      if (this._buffer) {
        return (0, utils_js_1.fakePromise)(this._buffer);
      }
      if (this.blobParts.length === 1) {
        if (isArrayBuffer(this.blobParts[0])) {
          return (0, utils_js_1.fakePromise)(this.blobParts[0]);
        }
        if (hasArrayBufferMethod(this.blobParts[0])) {
          return this.blobParts[0].arrayBuffer();
        }
      }
      return this.buffer();
    }
    bytes() {
      if (this._buffer) {
        return (0, utils_js_1.fakePromise)(this._buffer);
      }
      if (this.blobParts.length === 1) {
        if (Buffer.isBuffer(this.blobParts[0])) {
          this._buffer = this.blobParts[0];
          return (0, utils_js_1.fakePromise)(this.blobParts[0]);
        }
        if (this.blobParts[0] instanceof Uint8Array) {
          this._buffer = Buffer.from(this.blobParts[0]);
          return (0, utils_js_1.fakePromise)(this.blobParts[0]);
        }
        if (hasBytesMethod(this.blobParts[0])) {
          return this.blobParts[0].bytes();
        }
        if (hasBufferMethod(this.blobParts[0])) {
          return this.blobParts[0].buffer();
        }
      }
      return this.buffer();
    }
    _text = null;
    text() {
      if (this._text) {
        return (0, utils_js_1.fakePromise)(this._text);
      }
      if (this.blobParts.length === 1) {
        const blobPart = this.blobParts[0];
        if (typeof blobPart === "string") {
          this._text = blobPart;
          return (0, utils_js_1.fakePromise)(this._text);
        }
        if (hasTextMethod(blobPart)) {
          return blobPart.text().then((text) => {
            this._text = text;
            return this._text;
          });
        }
        const buf = getBlobPartAsBuffer(blobPart);
        this._text = buf.toString(this.encoding);
        return (0, utils_js_1.fakePromise)(this._text);
      }
      return this.buffer().then((buf) => {
        this._text = buf.toString(this.encoding);
        return this._text;
      });
    }
    get size() {
      if (this._size == null) {
        this._size = 0;
        for (const blobPart of this.blobParts) {
          if (typeof blobPart === "string") {
            this._size += Buffer.byteLength(blobPart);
          } else if (hasSizeProperty(blobPart)) {
            this._size += blobPart.size;
          } else if ((0, utils_js_1.isArrayBufferView)(blobPart)) {
            this._size += blobPart.byteLength;
          }
        }
      }
      return this._size;
    }
    stream() {
      if (this.blobParts.length === 1) {
        const blobPart = this.blobParts[0];
        if (hasStreamMethod(blobPart)) {
          return blobPart.stream();
        }
        const buf = getBlobPartAsBuffer(blobPart);
        return new ReadableStream_js_1.PonyfillReadableStream({
          start: (controller) => {
            controller.enqueue(buf);
            controller.close();
          }
        });
      }
      if (this._buffer != null) {
        return new ReadableStream_js_1.PonyfillReadableStream({
          start: (controller) => {
            controller.enqueue(this._buffer);
            controller.close();
          }
        });
      }
      let blobPartIterator;
      return new ReadableStream_js_1.PonyfillReadableStream({
        start: (controller) => {
          if (this.blobParts.length === 0) {
            controller.close();
            return;
          }
          blobPartIterator = this.blobParts[Symbol.iterator]();
        },
        pull: (controller) => {
          const { value: blobPart, done } = blobPartIterator.next();
          if (done) {
            controller.close();
            return;
          }
          if (blobPart) {
            if (hasBufferMethod(blobPart)) {
              return blobPart.buffer().then((buf2) => {
                controller.enqueue(buf2);
              });
            }
            if (hasBytesMethod(blobPart)) {
              return blobPart.bytes().then((bytes) => {
                const buf2 = Buffer.from(bytes);
                controller.enqueue(buf2);
              });
            }
            if (hasArrayBufferMethod(blobPart)) {
              return blobPart.arrayBuffer().then((arrayBuffer) => {
                const buf2 = Buffer.from(arrayBuffer, undefined, blobPart.size);
                controller.enqueue(buf2);
              });
            }
            const buf = getBlobPartAsBuffer(blobPart);
            controller.enqueue(buf);
          }
        }
      });
    }
    slice() {
      throw new Error("Not implemented");
    }
  }
  exports.PonyfillBlob = PonyfillBlob;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/File.js
var require_File = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillFile = undefined;
  var Blob_js_1 = require_Blob();

  class PonyfillFile extends Blob_js_1.PonyfillBlob {
    name;
    lastModified;
    constructor(fileBits, name, options) {
      super(fileBits, options);
      this.name = name;
      this.lastModified = options?.lastModified || Date.now();
    }
    webkitRelativePath = "";
  }
  exports.PonyfillFile = PonyfillFile;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/FormData.js
var require_FormData = __commonJS((exports) => {
  var getStreamFromFormData = function(formData, boundary = "---") {
    const entries = [];
    let sentInitialHeader = false;
    return new ReadableStream_js_1.PonyfillReadableStream({
      start: (controller) => {
        formData.forEach((value, key) => {
          if (!sentInitialHeader) {
            controller.enqueue(Buffer.from(`--${boundary}\r\n`));
            sentInitialHeader = true;
          }
          entries.push([key, value]);
        });
        if (!sentInitialHeader) {
          controller.enqueue(Buffer.from(`--${boundary}--\r\n`));
          controller.close();
        }
      },
      pull: async (controller) => {
        const entry = entries.shift();
        if (entry) {
          const [key, value] = entry;
          if (typeof value === "string") {
            controller.enqueue(Buffer.from(`Content-Disposition: form-data; name="${key}"\r\n\r\n`));
            controller.enqueue(Buffer.from(value));
          } else {
            let filenamePart = "";
            if (value.name) {
              filenamePart = `; filename="${value.name}"`;
            }
            controller.enqueue(Buffer.from(`Content-Disposition: form-data; name="${key}"${filenamePart}\r\n`));
            controller.enqueue(Buffer.from(`Content-Type: ${value.type || "application/octet-stream"}\r\n\r\n`));
            const entryStream = value.stream();
            for await (const chunk of entryStream) {
              controller.enqueue(chunk);
            }
          }
          if (entries.length === 0) {
            controller.enqueue(Buffer.from(`\r\n--${boundary}--\r\n`));
            controller.close();
          } else {
            controller.enqueue(Buffer.from(`\r\n--${boundary}\r\n`));
          }
        } else {
          controller.enqueue(Buffer.from(`\r\n--${boundary}--\r\n`));
          controller.close();
        }
      }
    });
  };
  var getNormalizedFile = function(name, blob, fileName) {
    Object.defineProperty(blob, "name", {
      configurable: true,
      enumerable: true,
      value: fileName || blob.name || name
    });
    return blob;
  };
  var isBlob = function(value) {
    return value?.arrayBuffer != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillFormData = undefined;
  exports.getStreamFromFormData = getStreamFromFormData;
  var ReadableStream_js_1 = require_ReadableStream();

  class PonyfillFormData {
    map = new Map;
    append(name, value, fileName) {
      let values4 = this.map.get(name);
      if (!values4) {
        values4 = [];
        this.map.set(name, values4);
      }
      const entry = isBlob(value) ? getNormalizedFile(name, value, fileName) : value;
      values4.push(entry);
    }
    delete(name) {
      this.map.delete(name);
    }
    get(name) {
      const values4 = this.map.get(name);
      return values4 ? values4[0] : null;
    }
    getAll(name) {
      return this.map.get(name) || [];
    }
    has(name) {
      return this.map.has(name);
    }
    set(name, value, fileName) {
      const entry = isBlob(value) ? getNormalizedFile(name, value, fileName) : value;
      this.map.set(name, [entry]);
    }
    *[Symbol.iterator]() {
      for (const [key, values4] of this.map) {
        for (const value of values4) {
          yield [key, value];
        }
      }
    }
    entries() {
      return this[Symbol.iterator]();
    }
    keys() {
      return this.map.keys();
    }
    *values() {
      for (const values4 of this.map.values()) {
        for (const value of values4) {
          yield value;
        }
      }
    }
    forEach(callback) {
      for (const [key, value] of this) {
        callback(value, key, this);
      }
    }
  }
  exports.PonyfillFormData = PonyfillFormData;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/Body.js
var require_Body = __commonJS((exports) => {
  var processBodyInit = function(bodyInit) {
    if (bodyInit == null) {
      return {
        bodyFactory: () => null,
        contentType: null,
        contentLength: null
      };
    }
    if (typeof bodyInit === "string") {
      const buffer = Buffer.from(bodyInit);
      const contentLength = buffer.byteLength;
      return {
        bodyType: BodyInitType.String,
        contentType: "text/plain;charset=UTF-8",
        contentLength,
        buffer,
        bodyFactory() {
          const readable = stream_1.Readable.from(buffer);
          return new ReadableStream_js_1.PonyfillReadableStream(readable);
        }
      };
    }
    if (Buffer.isBuffer(bodyInit)) {
      return {
        bodyType: BodyInitType.Buffer,
        contentType: null,
        contentLength: bodyInit.length,
        buffer: bodyInit,
        bodyFactory() {
          const readable = stream_1.Readable.from(bodyInit);
          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
          return body;
        }
      };
    }
    if ((0, utils_js_1.isArrayBufferView)(bodyInit)) {
      const buffer = Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength);
      return {
        bodyType: BodyInitType.Buffer,
        contentLength: bodyInit.byteLength,
        contentType: null,
        buffer,
        bodyFactory() {
          const readable = stream_1.Readable.from(buffer);
          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
          return body;
        }
      };
    }
    if (bodyInit instanceof ReadableStream_js_1.PonyfillReadableStream && bodyInit.readable != null) {
      return {
        bodyType: BodyInitType.ReadableStream,
        bodyFactory: () => bodyInit,
        contentType: null,
        contentLength: null
      };
    }
    if (isBlob(bodyInit)) {
      return {
        bodyType: BodyInitType.Blob,
        contentType: bodyInit.type,
        contentLength: bodyInit.size,
        bodyFactory() {
          return bodyInit.stream();
        }
      };
    }
    if (bodyInit instanceof ArrayBuffer) {
      const contentLength = bodyInit.byteLength;
      const buffer = Buffer.from(bodyInit, undefined, bodyInit.byteLength);
      return {
        bodyType: BodyInitType.Buffer,
        contentType: null,
        contentLength,
        buffer,
        bodyFactory() {
          const readable = stream_1.Readable.from(buffer);
          const body = new ReadableStream_js_1.PonyfillReadableStream(readable);
          return body;
        }
      };
    }
    if (bodyInit instanceof stream_1.Readable) {
      return {
        bodyType: BodyInitType.Readable,
        contentType: null,
        contentLength: null,
        bodyFactory() {
          const body = new ReadableStream_js_1.PonyfillReadableStream(bodyInit);
          return body;
        }
      };
    }
    if (isURLSearchParams(bodyInit)) {
      const contentType = "application/x-www-form-urlencoded;charset=UTF-8";
      return {
        bodyType: BodyInitType.String,
        contentType,
        contentLength: null,
        bodyFactory() {
          const body = new ReadableStream_js_1.PonyfillReadableStream(stream_1.Readable.from(bodyInit.toString()));
          return body;
        }
      };
    }
    if (isFormData(bodyInit)) {
      const boundary = Math.random().toString(36).substr(2);
      const contentType = `multipart/form-data; boundary=${boundary}`;
      return {
        bodyType: BodyInitType.FormData,
        contentType,
        contentLength: null,
        bodyFactory() {
          return (0, FormData_js_1.getStreamFromFormData)(bodyInit, boundary);
        }
      };
    }
    if (isReadableStream(bodyInit)) {
      return {
        contentType: null,
        contentLength: null,
        bodyFactory() {
          return new ReadableStream_js_1.PonyfillReadableStream(bodyInit);
        }
      };
    }
    if (bodyInit[Symbol.iterator] || bodyInit[Symbol.asyncIterator]) {
      return {
        contentType: null,
        contentLength: null,
        bodyFactory() {
          const readable = stream_1.Readable.from(bodyInit);
          return new ReadableStream_js_1.PonyfillReadableStream(readable);
        }
      };
    }
    throw new Error("Unknown body type");
  };
  var isFormData = function(value) {
    return value?.forEach != null;
  };
  var isBlob = function(value) {
    return value?.stream != null;
  };
  var isURLSearchParams = function(value) {
    return value?.sort != null;
  };
  var isReadableStream = function(value) {
    return value?.getReader != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillBody = undefined;
  var tslib_1 = require_tslib();
  var stream_1 = import.meta.require("stream");
  var busboy_1 = tslib_1.__importDefault(require_lib());
  var Blob_js_1 = require_Blob();
  var File_js_1 = require_File();
  var FormData_js_1 = require_FormData();
  var ReadableStream_js_1 = require_ReadableStream();
  var utils_js_1 = require_utils2();
  var BodyInitType;
  (function(BodyInitType2) {
    BodyInitType2["ReadableStream"] = "ReadableStream";
    BodyInitType2["Blob"] = "Blob";
    BodyInitType2["FormData"] = "FormData";
    BodyInitType2["String"] = "String";
    BodyInitType2["Readable"] = "Readable";
    BodyInitType2["Buffer"] = "Buffer";
  })(BodyInitType || (BodyInitType = {}));

  class PonyfillBody {
    bodyInit;
    options;
    bodyUsed = false;
    contentType = null;
    contentLength = null;
    constructor(bodyInit, options = {}) {
      this.bodyInit = bodyInit;
      this.options = options;
      const { bodyFactory, contentType, contentLength, bodyType, buffer } = processBodyInit(bodyInit);
      this._bodyFactory = bodyFactory;
      this.contentType = contentType;
      this.contentLength = contentLength;
      this.bodyType = bodyType;
      this._buffer = buffer;
    }
    bodyType;
    _bodyFactory = () => null;
    _generatedBody = null;
    _buffer;
    generateBody() {
      if (this._generatedBody?.readable?.destroyed && this._buffer) {
        this._generatedBody.readable = stream_1.Readable.from(this._buffer);
      }
      if (this._generatedBody) {
        return this._generatedBody;
      }
      const body = this._bodyFactory();
      this._generatedBody = body;
      return body;
    }
    handleContentLengthHeader(forceSet = false) {
      const contentTypeInHeaders = this.headers.get("content-type");
      if (!contentTypeInHeaders) {
        if (this.contentType) {
          this.headers.set("content-type", this.contentType);
        }
      } else {
        this.contentType = contentTypeInHeaders;
      }
      const contentLengthInHeaders = this.headers.get("content-length");
      if (forceSet && this.bodyInit == null && !contentLengthInHeaders) {
        this.contentLength = 0;
        this.headers.set("content-length", "0");
      }
      if (!contentLengthInHeaders) {
        if (this.contentLength) {
          this.headers.set("content-length", this.contentLength.toString());
        }
      } else {
        this.contentLength = parseInt(contentLengthInHeaders, 10);
      }
    }
    get body() {
      const _body = this.generateBody();
      if (_body != null) {
        const ponyfillReadableStream = _body;
        const readable = _body.readable;
        return new Proxy(_body.readable, {
          get(_, prop) {
            if (prop in ponyfillReadableStream) {
              const ponyfillReadableStreamProp = ponyfillReadableStream[prop];
              if (typeof ponyfillReadableStreamProp === "function") {
                return ponyfillReadableStreamProp.bind(ponyfillReadableStream);
              }
              return ponyfillReadableStreamProp;
            }
            if (prop in readable) {
              const readableProp = readable[prop];
              if (typeof readableProp === "function") {
                return readableProp.bind(readable);
              }
              return readableProp;
            }
          }
        });
      }
      return null;
    }
    _chunks = null;
    _collectChunksFromReadable() {
      if (this._chunks) {
        return (0, utils_js_1.fakePromise)(this._chunks);
      }
      const _body = this.generateBody();
      if (!_body) {
        return (0, utils_js_1.fakePromise)([]);
      }
      this._chunks = [];
      _body.readable.on("data", (chunk) => {
        this._chunks.push(chunk);
      });
      return new Promise((resolve, reject) => {
        _body.readable.once("end", () => {
          resolve(this._chunks);
        });
        _body.readable.once("error", (e) => {
          reject(e);
        });
      });
    }
    _blob = null;
    blob() {
      if (this._blob) {
        return (0, utils_js_1.fakePromise)(this._blob);
      }
      if (this.bodyType === BodyInitType.Blob) {
        this._blob = this.bodyInit;
        return (0, utils_js_1.fakePromise)(this._blob);
      }
      if (this._buffer) {
        this._blob = new Blob_js_1.PonyfillBlob([this._buffer], {
          type: this.contentType || "",
          size: this.contentLength
        });
        return (0, utils_js_1.fakePromise)(this._blob);
      }
      return this._collectChunksFromReadable().then((chunks) => {
        this._blob = new Blob_js_1.PonyfillBlob(chunks, {
          type: this.contentType || "",
          size: this.contentLength
        });
        return this._blob;
      });
    }
    _formData = null;
    formData(opts) {
      if (this._formData) {
        return (0, utils_js_1.fakePromise)(this._formData);
      }
      if (this.bodyType === BodyInitType.FormData) {
        this._formData = this.bodyInit;
        return (0, utils_js_1.fakePromise)(this._formData);
      }
      this._formData = new FormData_js_1.PonyfillFormData;
      const _body = this.generateBody();
      if (_body == null) {
        return (0, utils_js_1.fakePromise)(this._formData);
      }
      const formDataLimits = {
        ...this.options.formDataLimits,
        ...opts?.formDataLimits
      };
      return new Promise((resolve, reject) => {
        const bb = (0, busboy_1.default)({
          headers: {
            "content-type": this.contentType || ""
          },
          limits: formDataLimits,
          defParamCharset: "utf-8"
        });
        bb.on("field", (name, value, { nameTruncated, valueTruncated }) => {
          if (nameTruncated) {
            reject(new Error(`Field name size exceeded: ${formDataLimits?.fieldNameSize} bytes`));
          }
          if (valueTruncated) {
            reject(new Error(`Field value size exceeded: ${formDataLimits?.fieldSize} bytes`));
          }
          this._formData.set(name, value);
        });
        bb.on("fieldsLimit", () => {
          reject(new Error(`Fields limit exceeded: ${formDataLimits?.fields}`));
        });
        bb.on("file", (name, fileStream, { filename, mimeType }) => {
          const chunks = [];
          fileStream.on("limit", () => {
            reject(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));
          });
          fileStream.on("data", (chunk) => {
            chunks.push(chunk);
          });
          fileStream.on("close", () => {
            if (fileStream.truncated) {
              reject(new Error(`File size limit exceeded: ${formDataLimits?.fileSize} bytes`));
            }
            const file = new File_js_1.PonyfillFile(chunks, filename, { type: mimeType });
            this._formData.set(name, file);
          });
        });
        bb.on("filesLimit", () => {
          reject(new Error(`Files limit exceeded: ${formDataLimits?.files}`));
        });
        bb.on("partsLimit", () => {
          reject(new Error(`Parts limit exceeded: ${formDataLimits?.parts}`));
        });
        bb.on("close", () => {
          resolve(this._formData);
        });
        bb.on("error", (err = "An error occurred while parsing the form data") => {
          const errMessage = err.message || err.toString();
          reject(new TypeError(errMessage, err.cause));
        });
        _body?.readable.pipe(bb);
      });
    }
    buffer() {
      if (this._buffer) {
        return (0, utils_js_1.fakePromise)(this._buffer);
      }
      if (this.bodyType === BodyInitType.Blob) {
        if ((0, Blob_js_1.hasBufferMethod)(this.bodyInit)) {
          return this.bodyInit.buffer().then((buf) => {
            this._buffer = buf;
            return this._buffer;
          });
        }
        if ((0, Blob_js_1.hasBytesMethod)(this.bodyInit)) {
          return this.bodyInit.bytes().then((bytes) => {
            this._buffer = Buffer.from(bytes);
            return this._buffer;
          });
        }
        if ((0, Blob_js_1.hasArrayBufferMethod)(this.bodyInit)) {
          return this.bodyInit.arrayBuffer().then((buf) => {
            this._buffer = Buffer.from(buf, undefined, buf.byteLength);
            return this._buffer;
          });
        }
      }
      return this._collectChunksFromReadable().then((chunks) => {
        if (chunks.length === 1) {
          this._buffer = chunks[0];
          return this._buffer;
        }
        this._buffer = Buffer.concat(chunks);
        return this._buffer;
      });
    }
    bytes() {
      return this.buffer();
    }
    arrayBuffer() {
      return this.buffer();
    }
    _json = null;
    json() {
      if (this._json) {
        return (0, utils_js_1.fakePromise)(this._json);
      }
      return this.text().then((text) => {
        try {
          this._json = JSON.parse(text);
        } catch (e) {
          if (e instanceof SyntaxError) {
            e.message += `, "${text}" is not valid JSON`;
          }
          throw e;
        }
        return this._json;
      });
    }
    _text = null;
    text() {
      if (this._text) {
        return (0, utils_js_1.fakePromise)(this._text);
      }
      if (this.bodyType === BodyInitType.String) {
        this._text = this.bodyInit;
        return (0, utils_js_1.fakePromise)(this._text);
      }
      return this.buffer().then((buffer) => {
        this._text = buffer.toString("utf-8");
        return this._text;
      });
    }
  }
  exports.PonyfillBody = PonyfillBody;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/Headers.js
var require_Headers = __commonJS((exports) => {
  var isHeadersLike = function(headers) {
    return headers?.get && headers?.forEach;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillHeaders = undefined;
  exports.isHeadersLike = isHeadersLike;
  var util_1 = import.meta.require("util");

  class PonyfillHeaders {
    headersInit;
    _map;
    objectNormalizedKeysOfHeadersInit = [];
    objectOriginalKeysOfHeadersInit = [];
    _setCookies = [];
    constructor(headersInit) {
      this.headersInit = headersInit;
    }
    _get(key) {
      const normalized = key.toLowerCase();
      if (normalized === "set-cookie") {
        return this._setCookies.join(", ");
      }
      if (this._map) {
        return this._map.get(normalized) || null;
      }
      if (this.headersInit == null) {
        return null;
      }
      if (Array.isArray(this.headersInit)) {
        return this.headersInit.find((header) => header[0].toLowerCase() === normalized)?.[1] || null;
      } else if (isHeadersLike(this.headersInit)) {
        return this.headersInit.get(normalized);
      } else {
        const initValue = this.headersInit[key] || this.headersInit[normalized];
        if (initValue != null) {
          return initValue;
        }
        if (!this.objectNormalizedKeysOfHeadersInit.length) {
          Object.keys(this.headersInit).forEach((k) => {
            this.objectOriginalKeysOfHeadersInit.push(k);
            this.objectNormalizedKeysOfHeadersInit.push(k.toLowerCase());
          });
        }
        const index = this.objectNormalizedKeysOfHeadersInit.indexOf(normalized);
        if (index === -1) {
          return null;
        }
        const originalKey = this.objectOriginalKeysOfHeadersInit[index];
        return this.headersInit[originalKey];
      }
    }
    getMap() {
      if (!this._map) {
        if (this.headersInit != null) {
          if (Array.isArray(this.headersInit)) {
            this._map = new Map;
            this.headersInit.forEach(([key, value]) => {
              const normalizedKey = key.toLowerCase();
              if (normalizedKey === "set-cookie") {
                this._setCookies.push(value);
                return;
              }
              this._map.set(normalizedKey, value);
            });
          } else if (isHeadersLike(this.headersInit)) {
            this._map = new Map;
            this.headersInit.forEach((value, key) => {
              if (key === "set-cookie") {
                this._setCookies.push(value);
                return;
              }
              this._map.set(key, value);
            });
          } else {
            this._map = new Map;
            for (const initKey in this.headersInit) {
              const initValue = this.headersInit[initKey];
              if (initValue != null) {
                const normalizedKey = initKey.toLowerCase();
                if (normalizedKey === "set-cookie") {
                  this._setCookies.push(initValue);
                  continue;
                }
                this._map.set(normalizedKey, initValue);
              }
            }
          }
        } else {
          this._map = new Map;
        }
      }
      return this._map;
    }
    append(name, value) {
      const key = name.toLowerCase();
      if (key === "set-cookie") {
        this._setCookies.push(value);
        return;
      }
      const existingValue = this.getMap().get(key);
      const finalValue = existingValue ? `${existingValue}, ${value}` : value;
      this.getMap().set(key, finalValue);
    }
    get(name) {
      const value = this._get(name);
      if (value == null) {
        return null;
      }
      return value;
    }
    has(name) {
      if (name === "set-cookie") {
        return this._setCookies.length > 0;
      }
      return !!this._get(name);
    }
    set(name, value) {
      const key = name.toLowerCase();
      if (key === "set-cookie") {
        this._setCookies = [value];
        return;
      }
      this.getMap().set(key, value);
    }
    delete(name) {
      const key = name.toLowerCase();
      if (key === "set-cookie") {
        this._setCookies = [];
        return;
      }
      this.getMap().delete(key);
    }
    forEach(callback) {
      this._setCookies.forEach((setCookie) => {
        callback(setCookie, "set-cookie", this);
      });
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            this.headersInit.forEach(([key, value]) => {
              callback(value, key, this);
            });
            return;
          }
          if (isHeadersLike(this.headersInit)) {
            this.headersInit.forEach(callback);
            return;
          }
          Object.entries(this.headersInit).forEach(([key, value]) => {
            if (value != null) {
              callback(value, key, this);
            }
          });
        }
        return;
      }
      this.getMap().forEach((value, key) => {
        callback(value, key, this);
      });
    }
    *keys() {
      if (this._setCookies.length) {
        yield "set-cookie";
      }
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            yield* this.headersInit.map(([key]) => key)[Symbol.iterator]();
            return;
          }
          if (isHeadersLike(this.headersInit)) {
            yield* this.headersInit.keys();
            return;
          }
          yield* Object.keys(this.headersInit)[Symbol.iterator]();
          return;
        }
      }
      yield* this.getMap().keys();
    }
    *values() {
      yield* this._setCookies;
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            yield* this.headersInit.map(([, value]) => value)[Symbol.iterator]();
            return;
          }
          if (isHeadersLike(this.headersInit)) {
            yield* this.headersInit.values();
            return;
          }
          yield* Object.values(this.headersInit)[Symbol.iterator]();
          return;
        }
      }
      yield* this.getMap().values();
    }
    *entries() {
      yield* this._setCookies.map((cookie) => ["set-cookie", cookie]);
      if (!this._map) {
        if (this.headersInit) {
          if (Array.isArray(this.headersInit)) {
            yield* this.headersInit;
            return;
          }
          if (isHeadersLike(this.headersInit)) {
            yield* this.headersInit.entries();
            return;
          }
          yield* Object.entries(this.headersInit);
          return;
        }
      }
      yield* this.getMap().entries();
    }
    getSetCookie() {
      return this._setCookies;
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      const record = {};
      this.forEach((value, key) => {
        if (key === "set-cookie") {
          record["set-cookie"] = this._setCookies;
        } else {
          record[key] = value.includes(",") ? value.split(",").map((el) => el.trim()) : value;
        }
      });
      return `Headers ${(0, util_1.inspect)(record)}`;
    }
  }
  exports.PonyfillHeaders = PonyfillHeaders;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/Response.js
var require_Response = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillResponse = undefined;
  var http_1 = import.meta.require("http");
  var Body_js_1 = require_Body();
  var Headers_js_1 = require_Headers();
  var JSON_CONTENT_TYPE = "application/json; charset=utf-8";

  class PonyfillResponse extends Body_js_1.PonyfillBody {
    headers;
    constructor(body, init) {
      super(body || null, init);
      this.headers = init?.headers && (0, Headers_js_1.isHeadersLike)(init.headers) ? init.headers : new Headers_js_1.PonyfillHeaders(init?.headers);
      this.status = init?.status || 200;
      this.statusText = init?.statusText || http_1.STATUS_CODES[this.status] || "OK";
      this.url = init?.url || "";
      this.redirected = init?.redirected || false;
      this.type = init?.type || "default";
      this.handleContentLengthHeader();
    }
    get ok() {
      return this.status >= 200 && this.status < 300;
    }
    status;
    statusText;
    url;
    redirected;
    type;
    clone() {
      return this;
    }
    static error() {
      return new PonyfillResponse(null, {
        status: 500,
        statusText: "Internal Server Error"
      });
    }
    static redirect(url, status = 302) {
      if (status < 300 || status > 399) {
        throw new RangeError("Invalid status code");
      }
      return new PonyfillResponse(null, {
        headers: {
          location: url
        },
        status
      });
    }
    static json(data, init = {}) {
      init.headers = init?.headers && (0, Headers_js_1.isHeadersLike)(init.headers) ? init.headers : new Headers_js_1.PonyfillHeaders(init?.headers);
      if (!init.headers.has("content-type")) {
        init.headers.set("content-type", JSON_CONTENT_TYPE);
      }
      return new PonyfillResponse(JSON.stringify(data), init);
    }
  }
  exports.PonyfillResponse = PonyfillResponse;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/fetchCurl.js
var require_fetchCurl = __commonJS((exports) => {
  var fetchCurl = function(fetchRequest) {
    const { Curl, CurlFeature, CurlPause, CurlProgressFunc } = globalThis["libcurl"];
    const curlHandle = new Curl;
    curlHandle.enable(CurlFeature.NoDataParsing);
    curlHandle.setOpt("URL", fetchRequest.url);
    if (process.env.NODE_TLS_REJECT_UNAUTHORIZED === "0") {
      curlHandle.setOpt("SSL_VERIFYPEER", false);
    }
    if (process.env.NODE_EXTRA_CA_CERTS) {
      curlHandle.setOpt("CAINFO", process.env.NODE_EXTRA_CA_CERTS);
    } else {
      curlHandle.setOpt("CAINFO_BLOB", tls_1.rootCertificates.join("\n"));
    }
    curlHandle.enable(CurlFeature.StreamResponse);
    curlHandle.setStreamProgressCallback(function() {
      return fetchRequest["_signal"]?.aborted ? process.env.DEBUG ? CurlProgressFunc.Continue : 1 : 0;
    });
    if (fetchRequest["bodyType"] === "String") {
      curlHandle.setOpt("POSTFIELDS", fetchRequest["bodyInit"]);
    } else {
      const nodeReadable = fetchRequest.body != null ? (0, utils_js_1.isNodeReadable)(fetchRequest.body) ? fetchRequest.body : stream_1.Readable.from(fetchRequest.body) : null;
      if (nodeReadable) {
        curlHandle.setOpt("UPLOAD", true);
        curlHandle.setUploadStream(nodeReadable);
      }
    }
    if (process.env.DEBUG) {
      curlHandle.setOpt("VERBOSE", true);
    }
    curlHandle.setOpt("TRANSFER_ENCODING", false);
    curlHandle.setOpt("HTTP_TRANSFER_DECODING", true);
    curlHandle.setOpt("FOLLOWLOCATION", fetchRequest.redirect === "follow");
    curlHandle.setOpt("MAXREDIRS", 20);
    curlHandle.setOpt("ACCEPT_ENCODING", "");
    curlHandle.setOpt("CUSTOMREQUEST", fetchRequest.method);
    const headersSerializer = fetchRequest.headersSerializer || utils_js_1.defaultHeadersSerializer;
    let size;
    const curlHeaders = headersSerializer(fetchRequest.headers, (value) => {
      size = Number(value);
    });
    if (size != null) {
      curlHandle.setOpt("INFILESIZE", size);
    }
    curlHandle.setOpt("HTTPHEADER", curlHeaders);
    curlHandle.enable(CurlFeature.NoHeaderParsing);
    const deferredPromise = (0, utils_js_1.createDeferredPromise)();
    let streamResolved;
    if (fetchRequest["_signal"]) {
      fetchRequest["_signal"].onabort = () => {
        if (curlHandle.isOpen) {
          try {
            curlHandle.pause(CurlPause.Recv);
          } catch (e) {
            deferredPromise.reject(e);
          }
        }
      };
    }
    curlHandle.once("end", function endListener() {
      try {
        curlHandle.close();
      } catch (e) {
        deferredPromise.reject(e);
      }
    });
    curlHandle.once("error", function errorListener(error) {
      if (streamResolved && !streamResolved.closed && !streamResolved.destroyed) {
        streamResolved.destroy(error);
      } else {
        if (error.message === "Operation was aborted by an application callback") {
          error.message = "The operation was aborted.";
        }
        deferredPromise.reject(error);
      }
      try {
        curlHandle.close();
      } catch (e) {
        deferredPromise.reject(e);
      }
    });
    curlHandle.once("stream", function streamListener(stream, status, headersBuf) {
      const outputStream = new stream_1.PassThrough;
      stream_1.promises.pipeline(stream, outputStream, {
        end: true,
        signal: fetchRequest["_signal"] ?? undefined
      }).then(() => {
        if (!stream.destroyed) {
          stream.resume();
        }
      }).catch(deferredPromise.reject);
      const headersFlat = headersBuf.toString("utf8").split(/\r?\n|\r/g).filter((headerFilter) => {
        if (headerFilter && !headerFilter.startsWith("HTTP/")) {
          if (fetchRequest.redirect === "error" && (headerFilter.includes("location") || headerFilter.includes("Location"))) {
            if (!stream.destroyed) {
              stream.resume();
            }
            outputStream.destroy();
            deferredPromise.reject(new Error("redirect is not allowed"));
          }
          return true;
        }
        return false;
      });
      const headersInit = headersFlat.map((headerFlat) => headerFlat.split(/:\s(.+)/).slice(0, 2));
      const ponyfillResponse = new Response_js_1.PonyfillResponse(outputStream, {
        status,
        headers: headersInit,
        url: curlHandle.getInfo(Curl.info.REDIRECT_URL)?.toString() || fetchRequest.url,
        redirected: Number(curlHandle.getInfo(Curl.info.REDIRECT_COUNT)) > 0
      });
      deferredPromise.resolve(ponyfillResponse);
      streamResolved = outputStream;
    });
    let count = 0;
    try {
      count = Curl.getCount();
    } catch {
    }
    if (count > 0) {
      setImmediate(() => {
        curlHandle.perform();
      });
    } else {
      curlHandle.perform();
    }
    return deferredPromise.promise;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fetchCurl = fetchCurl;
  var stream_1 = import.meta.require("stream");
  var tls_1 = import.meta.require("tls");
  var Response_js_1 = require_Response();
  var utils_js_1 = require_utils2();
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/Request.js
var require_Request = __commonJS((exports) => {
  var isRequest = function(input) {
    return input[Symbol.toStringTag] === "Request";
  };
  var isURL = function(obj) {
    return obj?.href != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillRequest = undefined;
  var http_1 = import.meta.require("http");
  var https_1 = import.meta.require("https");
  var Body_js_1 = require_Body();
  var Headers_js_1 = require_Headers();

  class PonyfillRequest extends Body_js_1.PonyfillBody {
    constructor(input, options) {
      let url;
      let bodyInit = null;
      let requestInit;
      if (typeof input === "string") {
        url = input;
      } else if (isURL(input)) {
        url = input.toString();
      } else if (isRequest(input)) {
        url = input.url;
        bodyInit = input.body;
        requestInit = input;
      }
      if (options != null) {
        bodyInit = options.body || null;
        requestInit = options;
      }
      super(bodyInit, options);
      this.cache = requestInit?.cache || "default";
      this.credentials = requestInit?.credentials || "same-origin";
      this.headers = requestInit?.headers && (0, Headers_js_1.isHeadersLike)(requestInit.headers) ? requestInit.headers : new Headers_js_1.PonyfillHeaders(requestInit?.headers);
      this.integrity = requestInit?.integrity || "";
      this.keepalive = requestInit?.keepalive != null ? requestInit?.keepalive : false;
      this.method = requestInit?.method?.toUpperCase() || "GET";
      this.mode = requestInit?.mode || "cors";
      this.redirect = requestInit?.redirect || "follow";
      this.referrer = requestInit?.referrer || "about:client";
      this.referrerPolicy = requestInit?.referrerPolicy || "no-referrer";
      this._signal = requestInit?.signal;
      this.headersSerializer = requestInit?.headersSerializer;
      this.duplex = requestInit?.duplex || "half";
      this.url = url || "";
      this.destination = "document";
      this.priority = "auto";
      if (this.method !== "GET" && this.method !== "HEAD") {
        this.handleContentLengthHeader(true);
      }
      if (requestInit?.agent != null) {
        if (requestInit.agent === false) {
          this.agent = false;
        } else if (this.url.startsWith("http:/") && requestInit.agent instanceof http_1.Agent) {
          this.agent = requestInit.agent;
        } else if (this.url.startsWith("https:/") && requestInit.agent instanceof https_1.Agent) {
          this.agent = requestInit.agent;
        }
      }
    }
    headersSerializer;
    cache;
    credentials;
    destination;
    headers;
    integrity;
    keepalive;
    method;
    mode;
    priority;
    redirect;
    referrer;
    referrerPolicy;
    url;
    duplex;
    agent;
    _signal;
    get signal() {
      if (!this._signal) {
        this._signal = new AbortController().signal;
      }
      return this._signal;
    }
    clone() {
      return this;
    }
    [Symbol.toStringTag] = "Request";
  }
  exports.PonyfillRequest = PonyfillRequest;
});

// ../../node_modules/fast-decode-uri-component/index.js
var require_fast_decode_uri_component = __commonJS((exports, module) => {
  var decodeURIComponent2 = function(uri) {
    var percentPosition = uri.indexOf("%");
    if (percentPosition === -1)
      return uri;
    var length = uri.length;
    var decoded = "";
    var last = 0;
    var codepoint = 0;
    var startOfOctets = percentPosition;
    var state = UTF8_ACCEPT;
    while (percentPosition > -1 && percentPosition < length) {
      var high = hexCodeToInt(uri[percentPosition + 1], 4);
      var low = hexCodeToInt(uri[percentPosition + 2], 0);
      var byte = high | low;
      var type2 = UTF8_DATA[byte];
      state = UTF8_DATA[256 + state + type2];
      codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type2];
      if (state === UTF8_ACCEPT) {
        decoded += uri.slice(last, startOfOctets);
        decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
        codepoint = 0;
        last = percentPosition + 3;
        percentPosition = startOfOctets = uri.indexOf("%", last);
      } else if (state === UTF8_REJECT) {
        return null;
      } else {
        percentPosition += 3;
        if (percentPosition < length && uri.charCodeAt(percentPosition) === 37)
          continue;
        return null;
      }
    }
    return decoded + uri.slice(last);
  };
  var hexCodeToInt = function(c, shift) {
    var i = HEX[c];
    return i === undefined ? 255 : i << shift;
  };
  var UTF8_ACCEPT = 12;
  var UTF8_REJECT = 0;
  var UTF8_DATA = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    127,
    63,
    63,
    63,
    0,
    31,
    15,
    15,
    15,
    7,
    7,
    7
  ];
  var HEX = {
    "0": 0,
    "1": 1,
    "2": 2,
    "3": 3,
    "4": 4,
    "5": 5,
    "6": 6,
    "7": 7,
    "8": 8,
    "9": 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  module.exports = decodeURIComponent2;
});

// ../../node_modules/fast-querystring/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  var parse2 = function(input) {
    const result = new Empty;
    if (typeof input !== "string") {
      return result;
    }
    let inputLength = input.length;
    let key = "";
    let value = "";
    let startingIndex = -1;
    let equalityIndex = -1;
    let shouldDecodeKey = false;
    let shouldDecodeValue = false;
    let keyHasPlus = false;
    let valueHasPlus = false;
    let hasBothKeyValuePair = false;
    let c = 0;
    for (let i = 0;i < inputLength + 1; i++) {
      c = i !== inputLength ? input.charCodeAt(i) : 38;
      if (c === 38) {
        hasBothKeyValuePair = equalityIndex > startingIndex;
        if (!hasBothKeyValuePair) {
          equalityIndex = i;
        }
        key = input.slice(startingIndex + 1, equalityIndex);
        if (hasBothKeyValuePair || key.length > 0) {
          if (keyHasPlus) {
            key = key.replace(plusRegex, " ");
          }
          if (shouldDecodeKey) {
            key = fastDecode(key) || key;
          }
          if (hasBothKeyValuePair) {
            value = input.slice(equalityIndex + 1, i);
            if (valueHasPlus) {
              value = value.replace(plusRegex, " ");
            }
            if (shouldDecodeValue) {
              value = fastDecode(value) || value;
            }
          }
          const currentValue = result[key];
          if (currentValue === undefined) {
            result[key] = value;
          } else {
            if (currentValue.pop) {
              currentValue.push(value);
            } else {
              result[key] = [currentValue, value];
            }
          }
        }
        value = "";
        startingIndex = i;
        equalityIndex = i;
        shouldDecodeKey = false;
        shouldDecodeValue = false;
        keyHasPlus = false;
        valueHasPlus = false;
      } else if (c === 61) {
        if (equalityIndex <= startingIndex) {
          equalityIndex = i;
        } else {
          shouldDecodeValue = true;
        }
      } else if (c === 43) {
        if (equalityIndex > startingIndex) {
          valueHasPlus = true;
        } else {
          keyHasPlus = true;
        }
      } else if (c === 37) {
        if (equalityIndex > startingIndex) {
          shouldDecodeValue = true;
        } else {
          shouldDecodeKey = true;
        }
      }
    }
    return result;
  };
  var fastDecode = require_fast_decode_uri_component();
  var plusRegex = /\+/g;
  var Empty = function() {
  };
  Empty.prototype = Object.create(null);
  module.exports = parse2;
});

// ../../node_modules/fast-querystring/lib/internals/querystring.js
var require_querystring = __commonJS((exports, module) => {
  var encodeString = function(str) {
    const len = str.length;
    if (len === 0)
      return "";
    let out = "";
    let lastPos = 0;
    let i = 0;
    outer:
      for (;i < len; i++) {
        let c = str.charCodeAt(i);
        while (c < 128) {
          if (noEscape[c] !== 1) {
            if (lastPos < i)
              out += str.slice(lastPos, i);
            lastPos = i + 1;
            out += hexTable[c];
          }
          if (++i === len)
            break outer;
          c = str.charCodeAt(i);
        }
        if (lastPos < i)
          out += str.slice(lastPos, i);
        if (c < 2048) {
          lastPos = i + 1;
          out += hexTable[192 | c >> 6] + hexTable[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          lastPos = i + 1;
          out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
          continue;
        }
        ++i;
        if (i >= len) {
          throw new Error("URI malformed");
        }
        const c2 = str.charCodeAt(i) & 1023;
        lastPos = i + 1;
        c = 65536 + ((c & 1023) << 10 | c2);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
    if (lastPos === 0)
      return str;
    if (lastPos < len)
      return out + str.slice(lastPos);
    return out;
  };
  var hexTable = Array.from({ length: 256 }, (_, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  var noEscape = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
  ]);
  module.exports = { encodeString };
});

// ../../node_modules/fast-querystring/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  var getAsPrimitive = function(value) {
    const type2 = typeof value;
    if (type2 === "string") {
      return encodeString(value);
    } else if (type2 === "bigint") {
      return value.toString();
    } else if (type2 === "boolean") {
      return value ? "true" : "false";
    } else if (type2 === "number" && Number.isFinite(value)) {
      return value < 1000000000000000000000 ? "" + value : encodeString("" + value);
    }
    return "";
  };
  var stringify = function(input) {
    let result = "";
    if (input === null || typeof input !== "object") {
      return result;
    }
    const separator = "&";
    const keys = Object.keys(input);
    const keyLength = keys.length;
    let valueLength = 0;
    for (let i = 0;i < keyLength; i++) {
      const key = keys[i];
      const value = input[key];
      const encodedKey = encodeString(key) + "=";
      if (i) {
        result += separator;
      }
      if (Array.isArray(value)) {
        valueLength = value.length;
        for (let j = 0;j < valueLength; j++) {
          if (j) {
            result += separator;
          }
          result += encodedKey;
          result += getAsPrimitive(value[j]);
        }
      } else {
        result += encodedKey;
        result += getAsPrimitive(value);
      }
    }
    return result;
  };
  var { encodeString } = require_querystring();
  module.exports = stringify;
});

// ../../node_modules/fast-querystring/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var parse2 = require_parse();
  var stringify = require_stringify();
  var fastQuerystring = {
    parse: parse2,
    stringify
  };
  module.exports = fastQuerystring;
  module.exports.default = fastQuerystring;
  module.exports.parse = parse2;
  module.exports.stringify = stringify;
});

// ../../node_modules/@kamilkisiela/fast-url-parser/src/punycode.js
var require_punycode = __commonJS((exports, module) => {
  var error = function(type2) {
    throw new RangeError(errors4[type2]);
  };
  var map = function(array, callback) {
    var result = [];
    var length = array.length;
    while (length--) {
      result[length] = callback(array[length]);
    }
    return result;
  };
  var mapDomain = function(domain, callback) {
    var parts = domain.split("@");
    var result = "";
    if (parts.length > 1) {
      result = parts[0] + "@";
      domain = parts[1];
    }
    domain = domain.replace(regexSeparators, ".");
    var labels = domain.split(".");
    var encoded = map(labels, callback).join(".");
    return result + encoded;
  };
  var ucs2decode = function(string) {
    var output = [];
    var counter = 0;
    var length = string.length;
    while (counter < length) {
      var value = string.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < length) {
        var extra = string.charCodeAt(counter++);
        if ((extra & 64512) === 56320) {
          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  };
  var maxInt = 2147483647;
  var base = 36;
  var tMin = 1;
  var tMax = 26;
  var skew = 38;
  var damp = 700;
  var initialBias = 72;
  var initialN = 128;
  var delimiter = "-";
  var regexNonASCII = /[^\0-\x7F]/;
  var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
  var errors4 = {
    overflow: "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
  };
  var baseMinusTMin = base - tMin;
  var floor = Math.floor;
  var stringFromCharCode = String.fromCharCode;
  var digitToBasic = function(digit, flag) {
    return digit + 22 + 75 * (digit < 26) - ((flag !== 0) << 5);
  };
  var adapt = function(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for (;delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }
    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  };
  var encode = function(input) {
    var output = [];
    input = ucs2decode(input);
    var inputLength = input.length;
    var n = initialN;
    var delta = 0;
    var bias = initialBias;
    for (var currentValue of input) {
      if (currentValue < 128) {
        output.push(stringFromCharCode(currentValue));
      }
    }
    var basicLength = output.length;
    var handledCPCount = basicLength;
    if (basicLength) {
      output.push(delimiter);
    }
    while (handledCPCount < inputLength) {
      var m = maxInt;
      for (var currentValue of input) {
        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      }
      var handledCPCountPlusOne = handledCPCount + 1;
      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error("overflow");
      }
      delta += (m - n) * handledCPCountPlusOne;
      n = m;
      for (var currentValue of input) {
        if (currentValue < n && ++delta > maxInt) {
          error("overflow");
        }
        if (currentValue === n) {
          var q = delta;
          for (var k = base;; k += base) {
            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (q < t) {
              break;
            }
            var qMinusT = q - t;
            var baseMinusT = base - t;
            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
            q = floor(qMinusT / baseMinusT);
          }
          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }
      ++delta;
      ++n;
    }
    return output.join("");
  };
  var toASCII = function(input) {
    return mapDomain(input, function(string) {
      return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
    });
  };
  module.exports = {
    toASCII
  };
});

// ../../node_modules/@kamilkisiela/fast-url-parser/src/urlparser.js
var require_urlparser = __commonJS((exports, module) => {
  var Url = function() {
    this._protocol = null;
    this._href = "";
    this._port = -1;
    this._query = null;
    this.auth = null;
    this.slashes = null;
    this.host = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.pathname = null;
    this._prependSlash = false;
  };
  var _escapePath = function(pathname) {
    return pathname.replace(/[?#]/g, function(match) {
      return encodeURIComponent(match);
    });
  };
  var _escapeSearch = function(search) {
    return search.replace(/#/g, function(match) {
      return encodeURIComponent(match);
    });
  };
  var containsCharacter = function(string, char1, fromIndex, stopCharacterTable) {
    var len2 = string.length;
    for (var i2 = fromIndex;i2 < len2; ++i2) {
      var ch = string.charCodeAt(i2);
      if (ch === char1) {
        return true;
      } else if (stopCharacterTable[ch] === 1) {
        return false;
      }
    }
    return false;
  };
  var containsCharacter2 = function(string, char1, char2) {
    for (var i2 = 0, len2 = string.length;i2 < len2; ++i2) {
      var ch = string.charCodeAt(i2);
      if (ch === char1 || ch === char2)
        return true;
    }
    return false;
  };
  var makeAsciiTable = function(spec) {
    var ret = new Uint8Array(128);
    spec.forEach(function(item) {
      if (typeof item === "number") {
        ret[item] = 1;
      } else {
        var start = item[0];
        var end = item[1];
        for (var j = start;j <= end; ++j) {
          ret[j] = 1;
        }
      }
    });
    return ret;
  };
  var f = function() {
  };
  var querystring = import.meta.require("querystring");
  Url.queryString = querystring;
  Url.prototype.parse = function Url$parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
    if (typeof str !== "string") {
      throw new TypeError("Parameter 'url' must be a string, not " + typeof str);
    }
    var start = 0;
    var end = str.length - 1;
    while (str.charCodeAt(start) <= 32)
      start++;
    while (str.charCodeAt(end) <= 32)
      end--;
    start = this._parseProtocol(str, start, end);
    if (this._protocol !== "javascript") {
      start = this._parseHost(str, start, end, hostDenotesSlash);
      var proto = this._protocol;
      if (!this.hostname && (this.slashes || proto && !slashProtocols[proto])) {
        this.hostname = this.host = "";
      }
    }
    if (start <= end) {
      var ch = str.charCodeAt(start);
      if (ch === 47 || ch === 92) {
        this._parsePath(str, start, end, disableAutoEscapeChars);
      } else if (ch === 63) {
        this._parseQuery(str, start, end, disableAutoEscapeChars);
      } else if (ch === 35) {
        this._parseHash(str, start, end, disableAutoEscapeChars);
      } else if (this._protocol !== "javascript") {
        this._parsePath(str, start, end, disableAutoEscapeChars);
      } else {
        this.pathname = str.slice(start, end + 1);
      }
    }
    if (!this.pathname && this.hostname && this._slashProtocols[this._protocol]) {
      this.pathname = "/";
    }
    if (parseQueryString) {
      var search = this.search;
      if (search == null) {
        search = this.search = "";
      }
      if (search.charCodeAt(0) === 63) {
        search = search.slice(1);
      }
      this.query = Url.queryString.parse(search);
    }
  };
  Url.prototype.resolve = function Url$resolve(relative) {
    return this.resolveObject(Url.parse(relative, false, true)).format();
  };
  Url.prototype.format = function Url$format() {
    var auth = this.auth || "";
    if (auth) {
      auth = encodeURIComponent(auth);
      auth = auth.replace(/%3A/i, ":");
      auth += "@";
    }
    var protocol = this.protocol || "";
    var pathname = this.pathname || "";
    var hash = this.hash || "";
    var search = this.search || "";
    var query = "";
    var hostname = this.hostname || "";
    var port = this.port || "";
    var host = false;
    var scheme = "";
    var q = this.query;
    if (q && typeof q === "object") {
      query = Url.queryString.stringify(q);
    }
    if (!search) {
      search = query ? "?" + query : "";
    }
    if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58)
      protocol += ":";
    if (this.host) {
      host = auth + this.host;
    } else if (hostname) {
      var ip6 = hostname.indexOf(":") > -1;
      if (ip6)
        hostname = "[" + hostname + "]";
      host = auth + hostname + (port ? ":" + port : "");
    }
    var slashes = this.slashes || (!protocol || slashProtocols[protocol]) && host !== false;
    if (protocol)
      scheme = protocol + (slashes ? "//" : "");
    else if (slashes)
      scheme = "//";
    if (slashes && pathname && pathname.charCodeAt(0) !== 47) {
      pathname = "/" + pathname;
    }
    if (search && search.charCodeAt(0) !== 63)
      search = "?" + search;
    if (hash && hash.charCodeAt(0) !== 35)
      hash = "#" + hash;
    pathname = escapePathName(pathname);
    search = escapeSearch(search);
    return scheme + (host === false ? "" : host) + pathname + search + hash;
  };
  Url.prototype.resolveObject = function Url$resolveObject(relative) {
    if (typeof relative === "string")
      relative = Url.parse(relative, false, true);
    var result = this._clone();
    result.hash = relative.hash;
    if (!relative.href) {
      result._href = "";
      return result;
    }
    if (relative.slashes && !relative._protocol) {
      relative._copyPropsTo(result, true);
      if (slashProtocols[result._protocol] && result.hostname && !result.pathname) {
        result.pathname = "/";
      }
      result._href = "";
      return result;
    }
    if (relative._protocol && relative._protocol !== result._protocol) {
      if (!slashProtocols[relative._protocol]) {
        relative._copyPropsTo(result, false);
        result._href = "";
        return result;
      }
      result._protocol = relative._protocol;
      if (!relative.host && relative._protocol !== "javascript") {
        var relPath = (relative.pathname || "").split("/");
        while (relPath.length && !(relative.host = relPath.shift()))
          ;
        if (!relative.host)
          relative.host = "";
        if (!relative.hostname)
          relative.hostname = "";
        if (relPath[0] !== "")
          relPath.unshift("");
        if (relPath.length < 2)
          relPath.unshift("");
        result.pathname = relPath.join("/");
      } else {
        result.pathname = relative.pathname;
      }
      result.search = relative.search;
      result.host = relative.host || "";
      result.auth = relative.auth;
      result.hostname = relative.hostname || relative.host;
      result._port = relative._port;
      result.slashes = result.slashes || relative.slashes;
      result._href = "";
      return result;
    }
    var isSourceAbs = result.pathname && result.pathname.charCodeAt(0) === 47;
    var isRelAbs = relative.host || relative.pathname && relative.pathname.charCodeAt(0) === 47;
    var mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname;
    var removeAllDots = mustEndAbs;
    var srcPath = result.pathname && result.pathname.split("/") || [];
    var relPath = relative.pathname && relative.pathname.split("/") || [];
    var psychotic = result._protocol && !slashProtocols[result._protocol];
    if (psychotic) {
      result.hostname = "";
      result._port = -1;
      if (result.host) {
        if (srcPath[0] === "")
          srcPath[0] = result.host;
        else
          srcPath.unshift(result.host);
      }
      result.host = "";
      if (relative._protocol) {
        relative.hostname = "";
        relative._port = -1;
        if (relative.host) {
          if (relPath[0] === "")
            relPath[0] = relative.host;
          else
            relPath.unshift(relative.host);
        }
        relative.host = "";
      }
      mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
    }
    if (isRelAbs) {
      result.host = relative.host ? relative.host : result.host;
      result.hostname = relative.hostname ? relative.hostname : result.hostname;
      result.search = relative.search;
      srcPath = relPath;
    } else if (relPath.length) {
      if (!srcPath)
        srcPath = [];
      srcPath.pop();
      srcPath = srcPath.concat(relPath);
      result.search = relative.search;
    } else if (relative.search) {
      if (psychotic) {
        result.hostname = result.host = srcPath.shift();
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      result.search = relative.search;
      result._href = "";
      return result;
    }
    if (!srcPath.length) {
      result.pathname = null;
      result._href = "";
      return result;
    }
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (result.host || relative.host) && (last === "." || last === "..") || last === "";
    var up = 0;
    for (var i2 = srcPath.length;i2 >= 0; i2--) {
      last = srcPath[i2];
      if (last === ".") {
        srcPath.splice(i2, 1);
      } else if (last === "..") {
        srcPath.splice(i2, 1);
        up++;
      } else if (up) {
        srcPath.splice(i2, 1);
        up--;
      }
    }
    if (!mustEndAbs && !removeAllDots) {
      for (;up--; up) {
        srcPath.unshift("..");
      }
    }
    if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charCodeAt(0) !== 47)) {
      srcPath.unshift("");
    }
    if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
      srcPath.push("");
    }
    var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charCodeAt(0) === 47;
    if (psychotic) {
      result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    mustEndAbs = mustEndAbs || result.host && srcPath.length;
    if (mustEndAbs && !isAbsolute) {
      srcPath.unshift("");
    }
    result.pathname = srcPath.length === 0 ? null : srcPath.join("/");
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result._href = "";
    return result;
  };
  var punycode = require_punycode();
  Url.prototype._hostIdna = function Url$_hostIdna(hostname) {
    return punycode.toASCII(hostname);
  };
  var escapePathName = Url.prototype._escapePathName = function Url$_escapePathName(pathname) {
    if (!containsCharacter2(pathname, 35, 63)) {
      return pathname;
    }
    return _escapePath(pathname);
  };
  var escapeSearch = Url.prototype._escapeSearch = function Url$_escapeSearch(search) {
    if (!containsCharacter2(search, 35, -1))
      return search;
    return _escapeSearch(search);
  };
  Url.prototype._parseProtocol = function Url$_parseProtocol(str, start, end) {
    var doLowerCase = false;
    var protocolCharacters = this._protocolCharacters;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 58) {
        var protocol = str.slice(start, i2);
        if (doLowerCase)
          protocol = protocol.toLowerCase();
        this._protocol = protocol;
        return i2 + 1;
      } else if (protocolCharacters[ch] === 1) {
        if (ch < 97)
          doLowerCase = true;
      } else {
        return start;
      }
    }
    return start;
  };
  Url.prototype._parseAuth = function Url$_parseAuth(str, start, end, decode) {
    var auth = str.slice(start, end + 1);
    if (decode) {
      auth = decodeURIComponent(auth);
    }
    this.auth = auth;
  };
  Url.prototype._parsePort = function Url$_parsePort(str, start, end) {
    var port = 0;
    var hadChars = false;
    var validPort = true;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (48 <= ch && ch <= 57) {
        port = 10 * port + (ch - 48);
        hadChars = true;
      } else {
        validPort = false;
        if (ch === 92 || ch === 47) {
          validPort = true;
        }
        break;
      }
    }
    if (port === 0 && !hadChars || !validPort) {
      if (!validPort) {
        this._port = -2;
      }
      return 0;
    }
    this._port = port;
    return i2 - start;
  };
  Url.prototype._parseHost = function Url$_parseHost(str, start, end, slashesDenoteHost) {
    var hostEndingCharacters = this._hostEndingCharacters;
    var first = str.charCodeAt(start);
    var second = str.charCodeAt(start + 1);
    if ((first === 47 || first === 92) && (second === 47 || second === 92)) {
      this.slashes = true;
      if (start === 0) {
        if (end < 2)
          return start;
        var hasAuth = containsCharacter(str, 64, 2, hostEndingCharacters);
        if (!hasAuth && !slashesDenoteHost) {
          this.slashes = null;
          return start;
        }
      }
      start += 2;
    } else if (!this._protocol || slashProtocols[this._protocol]) {
      return start;
    }
    var doLowerCase = false;
    var idna = false;
    var hostNameStart = start;
    var hostNameEnd = end;
    var lastCh = -1;
    var portLength = 0;
    var charsAfterDot = 0;
    var authNeedsDecoding = false;
    var j = -1;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 64) {
        j = i2;
      } else if (ch === 37) {
        authNeedsDecoding = true;
      } else if (hostEndingCharacters[ch] === 1) {
        break;
      }
    }
    if (j > -1) {
      this._parseAuth(str, start, j - 1, authNeedsDecoding);
      start = hostNameStart = j + 1;
    }
    if (str.charCodeAt(start) === 91) {
      for (var i2 = start + 1;i2 <= end; ++i2) {
        var ch = str.charCodeAt(i2);
        if (ch === 93) {
          if (str.charCodeAt(i2 + 1) === 58) {
            portLength = this._parsePort(str, i2 + 2, end) + 1;
          }
          var hostname = str.slice(start + 1, i2).toLowerCase();
          this.hostname = hostname;
          this.host = this._port > 0 ? "[" + hostname + "]:" + this._port : "[" + hostname + "]";
          this.pathname = "/";
          return i2 + portLength + 1;
        }
      }
      return start;
    }
    for (var i2 = start;i2 <= end; ++i2) {
      if (charsAfterDot > 62) {
        this.hostname = this.host = str.slice(start, i2);
        return i2;
      }
      var ch = str.charCodeAt(i2);
      if (ch === 58) {
        portLength = this._parsePort(str, i2 + 1, end) + 1;
        hostNameEnd = i2 - 1;
        break;
      } else if (ch < 97) {
        if (ch === 46) {
          charsAfterDot = -1;
        } else if (65 <= ch && ch <= 90) {
          doLowerCase = true;
        } else if (!(ch === 45 || ch === 95 || ch === 43 || 48 <= ch && ch <= 57)) {
          if (hostEndingCharacters[ch] === 0 && this._noPrependSlashHostEnders[ch] === 0) {
            this._prependSlash = true;
          }
          hostNameEnd = i2 - 1;
          break;
        }
      } else if (ch >= 123) {
        if (ch <= 126) {
          if (this._noPrependSlashHostEnders[ch] === 0) {
            this._prependSlash = true;
          }
          hostNameEnd = i2 - 1;
          break;
        }
        idna = true;
      }
      lastCh = ch;
      charsAfterDot++;
    }
    if (hostNameEnd + 1 !== start && hostNameEnd - hostNameStart <= 256) {
      var hostname = str.slice(hostNameStart, hostNameEnd + 1);
      if (doLowerCase)
        hostname = hostname.toLowerCase();
      if (idna)
        hostname = this._hostIdna(hostname);
      this.hostname = hostname;
      this.host = this._port > 0 ? hostname + ":" + this._port : hostname;
    }
    return hostNameEnd + 1 + portLength;
  };
  Url.prototype._copyPropsTo = function Url$_copyPropsTo(input, noProtocol) {
    if (!noProtocol) {
      input._protocol = this._protocol;
    }
    input._href = this._href;
    input._port = this._port;
    input._prependSlash = this._prependSlash;
    input.auth = this.auth;
    input.slashes = this.slashes;
    input.host = this.host;
    input.hostname = this.hostname;
    input.hash = this.hash;
    input.search = this.search;
    input.pathname = this.pathname;
  };
  Url.prototype._clone = function Url$_clone() {
    var ret = new Url;
    ret._protocol = this._protocol;
    ret._href = this._href;
    ret._port = this._port;
    ret._prependSlash = this._prependSlash;
    ret.auth = this.auth;
    ret.slashes = this.slashes;
    ret.host = this.host;
    ret.hostname = this.hostname;
    ret.hash = this.hash;
    ret.search = this.search;
    ret.pathname = this.pathname;
    return ret;
  };
  Url.prototype._getComponentEscaped = function Url$_getComponentEscaped(str, start, end, isAfterQuery) {
    var cur = start;
    var i2 = start;
    var ret = "";
    var autoEscapeMap2 = isAfterQuery ? this._afterQueryAutoEscapeMap : this._autoEscapeMap;
    for (;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      var escaped = autoEscapeMap2[ch];
      if (escaped !== "" && escaped !== undefined) {
        if (cur < i2)
          ret += str.slice(cur, i2);
        ret += escaped;
        cur = i2 + 1;
      }
    }
    if (cur < i2 + 1)
      ret += str.slice(cur, i2);
    return ret;
  };
  Url.prototype._parsePath = function Url$_parsePath(str, start, end, disableAutoEscapeChars) {
    var pathStart = start;
    var pathEnd = end;
    var escape2 = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;
    var prePath = this._port === -2 ? "/:" : "";
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 35) {
        this._parseHash(str, i2, end, disableAutoEscapeChars);
        pathEnd = i2 - 1;
        break;
      } else if (ch === 63) {
        this._parseQuery(str, i2, end, disableAutoEscapeChars);
        pathEnd = i2 - 1;
        break;
      } else if (!disableAutoEscapeChars && !escape2 && autoEscapeCharacters[ch] === 1) {
        escape2 = true;
      }
    }
    if (pathStart > pathEnd) {
      this.pathname = prePath === "" ? "/" : prePath;
      return;
    }
    var path;
    if (escape2) {
      path = this._getComponentEscaped(str, pathStart, pathEnd, false);
    } else {
      path = str.slice(pathStart, pathEnd + 1);
    }
    this.pathname = prePath === "" ? this._prependSlash ? "/" + path : path : prePath + path;
  };
  Url.prototype._parseQuery = function Url$_parseQuery(str, start, end, disableAutoEscapeChars) {
    var queryStart = start;
    var queryEnd = end;
    var escape2 = false;
    var autoEscapeCharacters = this._autoEscapeCharacters;
    for (var i2 = start;i2 <= end; ++i2) {
      var ch = str.charCodeAt(i2);
      if (ch === 35) {
        this._parseHash(str, i2, end, disableAutoEscapeChars);
        queryEnd = i2 - 1;
        break;
      } else if (!disableAutoEscapeChars && !escape2 && autoEscapeCharacters[ch] === 1) {
        escape2 = true;
      }
    }
    if (queryStart > queryEnd) {
      this.search = "";
      return;
    }
    var query;
    if (escape2) {
      query = this._getComponentEscaped(str, queryStart, queryEnd, true);
    } else {
      query = str.slice(queryStart, queryEnd + 1);
    }
    this.search = query;
  };
  Url.prototype._parseHash = function Url$_parseHash(str, start, end, disableAutoEscapeChars) {
    if (start > end) {
      this.hash = "";
      return;
    }
    this.hash = disableAutoEscapeChars ? str.slice(start, end + 1) : this._getComponentEscaped(str, start, end, true);
  };
  Object.defineProperty(Url.prototype, "port", {
    get: function() {
      if (this._port >= 0) {
        return "" + this._port;
      }
      return null;
    },
    set: function(v) {
      if (v == null) {
        this._port = -1;
      } else {
        this._port = parseInt(v, 10);
      }
    }
  });
  Object.defineProperty(Url.prototype, "query", {
    get: function() {
      var query = this._query;
      if (query != null) {
        return query;
      }
      var search = this.search;
      if (search) {
        if (search.charCodeAt(0) === 63) {
          search = search.slice(1);
        }
        if (search !== "") {
          this._query = search;
          return search;
        }
      }
      return search;
    },
    set: function(v) {
      this._query = v;
    }
  });
  Object.defineProperty(Url.prototype, "path", {
    get: function() {
      var p = this.pathname || "";
      var s = this.search || "";
      if (p || s) {
        return p + s;
      }
      return p == null && s ? "/" + s : null;
    },
    set: function() {
    }
  });
  Object.defineProperty(Url.prototype, "protocol", {
    get: function() {
      var proto = this._protocol;
      return proto ? proto + ":" : proto;
    },
    set: function(v) {
      if (typeof v === "string") {
        var end = v.length - 1;
        if (v.charCodeAt(end) === 58) {
          this._protocol = v.slice(0, end);
        } else {
          this._protocol = v;
        }
      } else if (v == null) {
        this._protocol = null;
      }
    }
  });
  Object.defineProperty(Url.prototype, "href", {
    get: function() {
      var href = this._href;
      if (!href) {
        href = this._href = this.format();
      }
      return href;
    },
    set: function(v) {
      this._href = v;
    }
  });
  Url.parse = function Url$Parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
    if (str instanceof Url)
      return str;
    var ret = new Url;
    ret.parse(str, !!parseQueryString, !!hostDenotesSlash, !!disableAutoEscapeChars);
    return ret;
  };
  Url.format = function Url$Format(obj) {
    if (typeof obj === "string") {
      obj = Url.parse(obj);
    }
    if (!(obj instanceof Url)) {
      return Url.prototype.format.call(obj);
    }
    return obj.format();
  };
  Url.resolve = function Url$Resolve(source2, relative) {
    return Url.parse(source2, false, true).resolve(relative);
  };
  Url.resolveObject = function Url$ResolveObject(source2, relative) {
    if (!source2)
      return relative;
    return Url.parse(source2, false, true).resolveObject(relative);
  };
  var autoEscape = [
    "<",
    ">",
    "\"",
    "`",
    " ",
    "\r",
    "\n",
    "\t",
    "{",
    "}",
    "|",
    "\\",
    "^",
    "`",
    "'"
  ];
  var autoEscapeMap = new Array(128);
  for (i = 0, len = autoEscapeMap.length;i < len; ++i) {
    autoEscapeMap[i] = "";
  }
  var i;
  var len;
  for (i = 0, len = autoEscape.length;i < len; ++i) {
    c = autoEscape[i];
    esc = encodeURIComponent(c);
    if (esc === c) {
      esc = escape(c);
    }
    autoEscapeMap[c.charCodeAt(0)] = esc;
  }
  var c;
  var esc;
  var i;
  var len;
  var afterQueryAutoEscapeMap = autoEscapeMap.slice();
  autoEscapeMap[92] = "/";
  var slashProtocols = Url.prototype._slashProtocols = {
    http: true,
    https: true,
    gopher: true,
    file: true,
    ftp: true,
    "http:": true,
    "https:": true,
    "gopher:": true,
    "file:": true,
    "ftp:": true
  };
  f.prototype = slashProtocols;
  Url.prototype._protocolCharacters = makeAsciiTable([
    [97, 122],
    [65, 90],
    46,
    43,
    45
  ]);
  Url.prototype._hostEndingCharacters = makeAsciiTable([
    35,
    63,
    47,
    92
  ]);
  Url.prototype._autoEscapeCharacters = makeAsciiTable(autoEscape.map(function(v) {
    return v.charCodeAt(0);
  }));
  Url.prototype._noPrependSlashHostEnders = makeAsciiTable([
    "<",
    ">",
    "'",
    "`",
    " ",
    "\r",
    "\n",
    "\t",
    "{",
    "}",
    "|",
    "^",
    "`",
    "\"",
    "%",
    ";"
  ].map(function(v) {
    return v.charCodeAt(0);
  }));
  Url.prototype._autoEscapeMap = autoEscapeMap;
  Url.prototype._afterQueryAutoEscapeMap = afterQueryAutoEscapeMap;
  module.exports = Url;
  Url.replace = function Url$Replace() {
    import.meta.require.cache.url = {
      exports: Url
    };
  };
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/URLSearchParams.js
var require_URLSearchParams = __commonJS((exports) => {
  var isURLSearchParams = function(value) {
    return value?.entries != null;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillURLSearchParams = undefined;
  var tslib_1 = require_tslib();
  var fast_querystring_1 = tslib_1.__importDefault(require_lib2());

  class PonyfillURLSearchParams {
    params;
    constructor(init) {
      if (init) {
        if (typeof init === "string") {
          this.params = fast_querystring_1.default.parse(init);
        } else if (Array.isArray(init)) {
          this.params = {};
          for (const [key, value] of init) {
            this.params[key] = value;
          }
        } else if (isURLSearchParams(init)) {
          this.params = {};
          for (const [key, value] of init.entries()) {
            this.params[key] = value;
          }
        } else {
          this.params = init;
        }
      } else {
        this.params = {};
      }
    }
    append(name, value) {
      const existingValue = this.params[name];
      const finalValue = existingValue ? `${existingValue},${value}` : value;
      this.params[name] = finalValue;
    }
    delete(name) {
      delete this.params[name];
    }
    get(name) {
      const value = this.params[name];
      if (Array.isArray(value)) {
        return value[0] || null;
      }
      return value || null;
    }
    getAll(name) {
      const value = this.params[name];
      if (!Array.isArray(value)) {
        return value ? [value] : [];
      }
      return value;
    }
    has(name) {
      return name in this.params;
    }
    set(name, value) {
      this.params[name] = value;
    }
    sort() {
      const sortedKeys = Object.keys(this.params).sort();
      const sortedParams = {};
      for (const key of sortedKeys) {
        sortedParams[key] = this.params[key];
      }
      this.params = sortedParams;
    }
    toString() {
      return fast_querystring_1.default.stringify(this.params);
    }
    *keys() {
      for (const key in this.params) {
        yield key;
      }
    }
    *entries() {
      for (const key of this.keys()) {
        const value = this.params[key];
        if (Array.isArray(value)) {
          for (const item of value) {
            yield [key, item];
          }
        } else {
          yield [key, value];
        }
      }
    }
    *values() {
      for (const [, value] of this) {
        yield value;
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    forEach(callback) {
      for (const [key, value] of this) {
        callback(value, key, this);
      }
    }
    get size() {
      return Object.keys(this.params).length;
    }
  }
  exports.PonyfillURLSearchParams = PonyfillURLSearchParams;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/URL.js
var require_URL = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillURL = undefined;
  var tslib_1 = require_tslib();
  var buffer_1 = import.meta.require("buffer");
  var crypto_1 = import.meta.require("crypto");
  var fast_querystring_1 = tslib_1.__importDefault(require_lib2());
  var fast_url_parser_1 = tslib_1.__importDefault(require_urlparser());
  var URLSearchParams_js_1 = require_URLSearchParams();
  fast_url_parser_1.default.queryString = fast_querystring_1.default;

  class PonyfillURL extends fast_url_parser_1.default {
    constructor(url, base) {
      super();
      if (url.startsWith("data:")) {
        this.protocol = "data:";
        this.pathname = url.slice("data:".length);
        return;
      }
      this.parse(url, false);
      if (base) {
        const baseParsed = typeof base === "string" ? new PonyfillURL(base) : base;
        this.protocol = this.protocol || baseParsed.protocol;
        this.host = this.host || baseParsed.host;
        this.pathname = this.pathname || baseParsed.pathname;
      }
    }
    get origin() {
      return `${this.protocol}//${this.host}`;
    }
    _searchParams;
    get searchParams() {
      if (!this._searchParams) {
        this._searchParams = new URLSearchParams_js_1.PonyfillURLSearchParams(this.query);
      }
      return this._searchParams;
    }
    get username() {
      return this.auth?.split(":")[0] || "";
    }
    set username(value) {
      this.auth = `${value}:${this.password}`;
    }
    get password() {
      return this.auth?.split(":")[1] || "";
    }
    set password(value) {
      this.auth = `${this.username}:${value}`;
    }
    toString() {
      return this.format();
    }
    toJSON() {
      return this.toString();
    }
    static blobRegistry = new Map;
    static createObjectURL(blob) {
      const blobUrl = `blob:whatwgnode:${(0, crypto_1.randomUUID)()}`;
      this.blobRegistry.set(blobUrl, blob);
      return blobUrl;
    }
    static resolveObjectURL(url) {
      if (!this.blobRegistry.has(url)) {
        URL.revokeObjectURL(url);
      } else {
        this.blobRegistry.delete(url);
      }
    }
    static getBlobFromURL(url) {
      return this.blobRegistry.get(url) || (0, buffer_1.resolveObjectURL)(url);
    }
  }
  exports.PonyfillURL = PonyfillURL;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/fetchNodeHttp.js
var require_fetchNodeHttp = __commonJS((exports) => {
  var getRequestFnForProtocol = function(url) {
    if (url.startsWith("http:")) {
      return http_1.request;
    } else if (url.startsWith("https:")) {
      return https_1.request;
    }
    throw new Error(`Unsupported protocol: ${url.split(":")[0] || url}`);
  };
  var fetchNodeHttp = function(fetchRequest) {
    return new Promise((resolve, reject) => {
      try {
        const requestFn = getRequestFnForProtocol(fetchRequest.url);
        const nodeReadable = fetchRequest.body != null ? (0, utils_js_1.isNodeReadable)(fetchRequest.body) ? fetchRequest.body : stream_1.Readable.from(fetchRequest.body) : null;
        const headersSerializer = fetchRequest.headersSerializer || utils_js_1.getHeadersObj;
        const nodeHeaders = headersSerializer(fetchRequest.headers);
        if (nodeHeaders["accept-encoding"] == null) {
          nodeHeaders["accept-encoding"] = "gzip, deflate, br";
        }
        const nodeRequest = requestFn(fetchRequest.url, {
          method: fetchRequest.method,
          headers: nodeHeaders,
          signal: fetchRequest["_signal"] ?? undefined,
          agent: fetchRequest.agent
        });
        nodeRequest.once("response", (nodeResponse) => {
          let outputStream;
          const contentEncoding = nodeResponse.headers["content-encoding"];
          switch (contentEncoding) {
            case "x-gzip":
            case "gzip":
              outputStream = (0, zlib_1.createGunzip)();
              break;
            case "x-deflate":
            case "deflate":
              outputStream = (0, zlib_1.createInflate)();
              break;
            case "x-deflate-raw":
            case "deflate-raw":
              outputStream = (0, zlib_1.createInflateRaw)();
              break;
            case "br":
              outputStream = (0, zlib_1.createBrotliDecompress)();
              break;
            default:
              outputStream = new stream_1.PassThrough;
          }
          if (nodeResponse.headers.location) {
            if (fetchRequest.redirect === "error") {
              const redirectError = new Error("Redirects are not allowed");
              reject(redirectError);
              nodeResponse.resume();
              return;
            }
            if (fetchRequest.redirect === "follow") {
              const redirectedUrl = new URL_js_1.PonyfillURL(nodeResponse.headers.location, fetchRequest.url);
              const redirectResponse$ = fetchNodeHttp(new Request_js_1.PonyfillRequest(redirectedUrl, fetchRequest));
              resolve(redirectResponse$.then((redirectResponse) => {
                redirectResponse.redirected = true;
                return redirectResponse;
              }));
              nodeResponse.resume();
              return;
            }
          }
          stream_1.promises.pipeline(nodeResponse, outputStream, {
            signal: fetchRequest["_signal"] ?? undefined,
            end: true
          }).then(() => {
            if (!nodeResponse.destroyed) {
              nodeResponse.resume();
            }
          }).catch(reject);
          const ponyfillResponse = new Response_js_1.PonyfillResponse(outputStream, {
            status: nodeResponse.statusCode,
            statusText: nodeResponse.statusMessage,
            headers: nodeResponse.headers,
            url: fetchRequest.url
          });
          resolve(ponyfillResponse);
        });
        nodeRequest.once("error", reject);
        if (nodeReadable) {
          nodeReadable.pipe(nodeRequest);
        } else {
          nodeRequest.end();
        }
      } catch (e) {
        reject(e);
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fetchNodeHttp = fetchNodeHttp;
  var http_1 = import.meta.require("http");
  var https_1 = import.meta.require("https");
  var stream_1 = import.meta.require("stream");
  var zlib_1 = import.meta.require("zlib");
  var Request_js_1 = require_Request();
  var Response_js_1 = require_Response();
  var URL_js_1 = require_URL();
  var utils_js_1 = require_utils2();
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/fetch.js
var require_fetch = __commonJS((exports) => {
  var getResponseForFile = function(url) {
    const path = (0, url_1.fileURLToPath)(url);
    const readable = (0, fs_1.createReadStream)(path);
    return new Response_js_1.PonyfillResponse(readable);
  };
  var getResponseForDataUri = function(url) {
    const [mimeType = "text/plain", ...datas] = url.substring(5).split(",");
    const data = decodeURIComponent(datas.join(","));
    if (mimeType.endsWith(BASE64_SUFFIX)) {
      const buffer = Buffer.from(data, "base64url");
      const realMimeType = mimeType.slice(0, -BASE64_SUFFIX.length);
      return new Response_js_1.PonyfillResponse(buffer, {
        status: 200,
        statusText: "OK",
        headers: {
          "content-type": realMimeType
        }
      });
    }
    return new Response_js_1.PonyfillResponse(data, {
      status: 200,
      statusText: "OK",
      headers: {
        "content-type": mimeType
      }
    });
  };
  var getResponseForBlob = function(url) {
    const blob = URL_js_1.PonyfillURL.getBlobFromURL(url);
    if (!blob) {
      throw new TypeError("Invalid Blob URL");
    }
    return new Response_js_1.PonyfillResponse(blob, {
      status: 200,
      headers: {
        "content-type": blob.type,
        "content-length": blob.size.toString()
      }
    });
  };
  var isURL = function(obj) {
    return obj != null && obj.href != null;
  };
  var fetchPonyfill = function(info, init) {
    if (typeof info === "string" || isURL(info)) {
      const ponyfillRequest = new Request_js_1.PonyfillRequest(info, init);
      return fetchPonyfill(ponyfillRequest);
    }
    const fetchRequest = info;
    if (fetchRequest.url.startsWith("data:")) {
      const response = getResponseForDataUri(fetchRequest.url);
      return (0, utils_js_1.fakePromise)(response);
    }
    if (fetchRequest.url.startsWith("file:")) {
      const response = getResponseForFile(fetchRequest.url);
      return (0, utils_js_1.fakePromise)(response);
    }
    if (fetchRequest.url.startsWith("blob:")) {
      const response = getResponseForBlob(fetchRequest.url);
      return (0, utils_js_1.fakePromise)(response);
    }
    if (globalThis.libcurl && !fetchRequest.agent) {
      return (0, fetchCurl_js_1.fetchCurl)(fetchRequest);
    }
    return (0, fetchNodeHttp_js_1.fetchNodeHttp)(fetchRequest);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fetchPonyfill = fetchPonyfill;
  var fs_1 = import.meta.require("fs");
  var url_1 = import.meta.require("url");
  var fetchCurl_js_1 = require_fetchCurl();
  var fetchNodeHttp_js_1 = require_fetchNodeHttp();
  var Request_js_1 = require_Request();
  var Response_js_1 = require_Response();
  var URL_js_1 = require_URL();
  var utils_js_1 = require_utils2();
  var BASE64_SUFFIX = ";base64";
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/TextEncoderDecoder.js
var require_TextEncoderDecoder = __commonJS((exports) => {
  var PonyfillBtoa = function(input) {
    return Buffer.from(input, "binary").toString("base64");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillTextDecoder = exports.PonyfillTextEncoder = undefined;
  exports.PonyfillBtoa = PonyfillBtoa;
  var utils_js_1 = require_utils2();

  class PonyfillTextEncoder {
    encoding;
    constructor(encoding = "utf-8") {
      this.encoding = encoding;
    }
    encode(input) {
      return Buffer.from(input, this.encoding);
    }
    encodeInto(source2, destination) {
      const buffer = this.encode(source2);
      const copied = buffer.copy(destination);
      return {
        read: copied,
        written: copied
      };
    }
  }
  exports.PonyfillTextEncoder = PonyfillTextEncoder;

  class PonyfillTextDecoder {
    encoding;
    fatal = false;
    ignoreBOM = false;
    constructor(encoding = "utf-8", options) {
      this.encoding = encoding;
      if (options) {
        this.fatal = options.fatal || false;
        this.ignoreBOM = options.ignoreBOM || false;
      }
    }
    decode(input) {
      if (Buffer.isBuffer(input)) {
        return input.toString(this.encoding);
      }
      if ((0, utils_js_1.isArrayBufferView)(input)) {
        return Buffer.from(input.buffer, input.byteOffset, input.byteLength).toString(this.encoding);
      }
      return Buffer.from(input).toString(this.encoding);
    }
  }
  exports.PonyfillTextDecoder = PonyfillTextDecoder;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/WritableStream.js
var require_WritableStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillWritableStream = undefined;
  var stream_1 = import.meta.require("stream");
  var utils_js_1 = require_utils2();

  class PonyfillWritableStream {
    writable;
    constructor(underlyingSink) {
      if (underlyingSink instanceof stream_1.Writable) {
        this.writable = underlyingSink;
      } else if (underlyingSink) {
        const writable = new stream_1.Writable({
          write(chunk, _encoding, callback) {
            try {
              const result = underlyingSink.write?.(chunk, controller);
              if (result instanceof Promise) {
                result.then(() => {
                  callback();
                }, (err) => {
                  callback(err);
                });
              } else {
                callback();
              }
            } catch (err) {
              callback(err);
            }
          },
          final(callback) {
            const result = underlyingSink.close?.();
            if (result instanceof Promise) {
              result.then(() => {
                callback();
              }, (err) => {
                callback(err);
              });
            } else {
              callback();
            }
          }
        });
        this.writable = writable;
        let onabort;
        let reason;
        const controller = {
          signal: {
            any(signals) {
              return AbortSignal.any([...signals]);
            },
            get reason() {
              return reason;
            },
            get aborted() {
              return writable.destroyed;
            },
            addEventListener: (_event, eventListener) => {
              writable.once("error", eventListener);
              writable.once("close", eventListener);
            },
            removeEventListener: (_event, eventListener) => {
              writable.off("error", eventListener);
              writable.off("close", eventListener);
            },
            dispatchEvent: (_event) => {
              return false;
            },
            get onabort() {
              return onabort;
            },
            set onabort(value) {
              if (onabort) {
                this.removeEventListener("abort", onabort);
              }
              onabort = value;
              if (onabort) {
                this.addEventListener("abort", onabort);
              }
            },
            throwIfAborted() {
              if (writable.destroyed) {
                throw reason;
              }
            }
          },
          error: (e) => {
            this.writable.destroy(e);
          }
        };
        this.writable.once("error", (err) => {
          reason = err;
        });
      } else {
        this.writable = new stream_1.Writable;
      }
    }
    getWriter() {
      const writable = this.writable;
      return {
        closed: new Promise((resolve) => {
          writable.once("close", () => {
            resolve(undefined);
          });
        }),
        get desiredSize() {
          return writable.writableLength;
        },
        ready: new Promise((resolve) => {
          writable.once("drain", () => {
            resolve(undefined);
          });
        }),
        releaseLock() {
        },
        write(chunk) {
          if (chunk == null) {
            return (0, utils_js_1.fakePromise)(undefined);
          }
          return new Promise((resolve, reject) => {
            writable.write(chunk, (err) => {
              if (err) {
                reject(err);
              } else {
                resolve();
              }
            });
          });
        },
        close() {
          if (!writable.errored && writable.closed) {
            return (0, utils_js_1.fakePromise)(undefined);
          }
          return new Promise((resolve, reject) => {
            if (writable.errored) {
              reject(writable.errored);
            } else {
              writable.end((err) => {
                if (err) {
                  reject(err);
                } else {
                  resolve();
                }
              });
            }
          });
        },
        abort(reason) {
          return new Promise((resolve) => {
            writable.destroy(reason);
            writable.once("close", resolve);
          });
        }
      };
    }
    close() {
      if (!this.writable.errored && this.writable.closed) {
        return (0, utils_js_1.fakePromise)(undefined);
      }
      return new Promise((resolve, reject) => {
        if (this.writable.errored) {
          reject(this.writable.errored);
        } else {
          this.writable.end((err) => {
            if (err) {
              reject(err);
            } else {
              resolve();
            }
          });
        }
      });
    }
    abort(reason) {
      return new Promise((resolve) => {
        this.writable.destroy(reason);
        this.writable.once("close", resolve);
      });
    }
    locked = false;
  }
  exports.PonyfillWritableStream = PonyfillWritableStream;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/TransformStream.js
var require_TransformStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillTransformStream = undefined;
  var node_stream_1 = import.meta.require("stream");
  var ReadableStream_js_1 = require_ReadableStream();
  var WritableStream_js_1 = require_WritableStream();

  class PonyfillTransformStream {
    transform;
    writable;
    readable;
    constructor(transformer) {
      if (transformer instanceof node_stream_1.Transform) {
        this.transform = transformer;
      } else if (transformer) {
        const controller = {
          enqueue(chunk) {
            transform.push(chunk);
          },
          error(reason) {
            transform.destroy(reason);
          },
          terminate() {
            transform.end();
          },
          get desiredSize() {
            return transform.writableLength;
          }
        };
        const transform = new node_stream_1.Transform({
          read() {
          },
          write(chunk, _encoding, callback) {
            try {
              const result = transformer.transform?.(chunk, controller);
              if (result instanceof Promise) {
                result.then(() => {
                  callback();
                }, (err) => {
                  callback(err);
                });
              } else {
                callback();
              }
            } catch (err) {
              callback(err);
            }
          },
          final(callback) {
            try {
              const result = transformer.flush?.(controller);
              if (result instanceof Promise) {
                result.then(() => {
                  callback();
                }, (err) => {
                  callback(err);
                });
              } else {
                callback();
              }
            } catch (err) {
              callback(err);
            }
          }
        });
        this.transform = transform;
      } else {
        this.transform = new node_stream_1.Transform;
      }
      this.writable = new WritableStream_js_1.PonyfillWritableStream(this.transform);
      this.readable = new ReadableStream_js_1.PonyfillReadableStream(this.transform);
    }
  }
  exports.PonyfillTransformStream = PonyfillTransformStream;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/CompressionStream.js
var require_CompressionStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillCompressionStream = undefined;
  var node_zlib_1 = import.meta.require("zlib");
  var TransformStream_js_1 = require_TransformStream();

  class PonyfillCompressionStream extends TransformStream_js_1.PonyfillTransformStream {
    static supportedFormats = globalThis.process?.version?.startsWith("v2") ? ["gzip", "deflate", "br"] : ["gzip", "deflate", "deflate-raw", "br"];
    constructor(compressionFormat) {
      switch (compressionFormat) {
        case "x-gzip":
        case "gzip":
          super((0, node_zlib_1.createGzip)());
          break;
        case "x-deflate":
        case "deflate":
          super((0, node_zlib_1.createDeflate)());
          break;
        case "deflate-raw":
          super((0, node_zlib_1.createDeflateRaw)());
          break;
        case "br":
          super((0, node_zlib_1.createBrotliCompress)());
          break;
        default:
          throw new Error(`Unsupported compression format: ${compressionFormat}`);
      }
    }
  }
  exports.PonyfillCompressionStream = PonyfillCompressionStream;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/DecompressionStream.js
var require_DecompressionStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PonyfillDecompressionStream = undefined;
  var node_zlib_1 = import.meta.require("zlib");
  var TransformStream_js_1 = require_TransformStream();

  class PonyfillDecompressionStream extends TransformStream_js_1.PonyfillTransformStream {
    static supportedFormats = globalThis.process?.version?.startsWith("v2") ? ["gzip", "deflate", "br"] : ["gzip", "deflate", "deflate-raw", "br"];
    constructor(compressionFormat) {
      switch (compressionFormat) {
        case "x-gzip":
        case "gzip":
          super((0, node_zlib_1.createGunzip)());
          break;
        case "x-deflate":
        case "deflate":
          super((0, node_zlib_1.createInflate)());
          break;
        case "deflate-raw":
          super((0, node_zlib_1.createInflateRaw)());
          break;
        case "br":
          super((0, node_zlib_1.createBrotliDecompress)());
          break;
        default:
          throw new TypeError(`Unsupported compression format: '${compressionFormat}'`);
      }
    }
  }
  exports.PonyfillDecompressionStream = PonyfillDecompressionStream;
});

// ../../node_modules/@whatwg-node/node-fetch/cjs/index.js
var require_cjs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DecompressionStream = exports.CompressionStream = exports.TransformStream = exports.WritableStream = exports.URLSearchParams = exports.URL = exports.btoa = exports.TextDecoder = exports.TextEncoder = exports.Blob = exports.FormData = exports.File = exports.ReadableStream = exports.Response = exports.Request = exports.Body = exports.Headers = exports.fetch = undefined;
  var fetch_js_1 = require_fetch();
  Object.defineProperty(exports, "fetch", { enumerable: true, get: function() {
    return fetch_js_1.fetchPonyfill;
  } });
  var Headers_js_1 = require_Headers();
  Object.defineProperty(exports, "Headers", { enumerable: true, get: function() {
    return Headers_js_1.PonyfillHeaders;
  } });
  var Body_js_1 = require_Body();
  Object.defineProperty(exports, "Body", { enumerable: true, get: function() {
    return Body_js_1.PonyfillBody;
  } });
  var Request_js_1 = require_Request();
  Object.defineProperty(exports, "Request", { enumerable: true, get: function() {
    return Request_js_1.PonyfillRequest;
  } });
  var Response_js_1 = require_Response();
  Object.defineProperty(exports, "Response", { enumerable: true, get: function() {
    return Response_js_1.PonyfillResponse;
  } });
  var ReadableStream_js_1 = require_ReadableStream();
  Object.defineProperty(exports, "ReadableStream", { enumerable: true, get: function() {
    return ReadableStream_js_1.PonyfillReadableStream;
  } });
  var File_js_1 = require_File();
  Object.defineProperty(exports, "File", { enumerable: true, get: function() {
    return File_js_1.PonyfillFile;
  } });
  var FormData_js_1 = require_FormData();
  Object.defineProperty(exports, "FormData", { enumerable: true, get: function() {
    return FormData_js_1.PonyfillFormData;
  } });
  var Blob_js_1 = require_Blob();
  Object.defineProperty(exports, "Blob", { enumerable: true, get: function() {
    return Blob_js_1.PonyfillBlob;
  } });
  var TextEncoderDecoder_js_1 = require_TextEncoderDecoder();
  Object.defineProperty(exports, "TextEncoder", { enumerable: true, get: function() {
    return TextEncoderDecoder_js_1.PonyfillTextEncoder;
  } });
  Object.defineProperty(exports, "TextDecoder", { enumerable: true, get: function() {
    return TextEncoderDecoder_js_1.PonyfillTextDecoder;
  } });
  Object.defineProperty(exports, "btoa", { enumerable: true, get: function() {
    return TextEncoderDecoder_js_1.PonyfillBtoa;
  } });
  var URL_js_1 = require_URL();
  Object.defineProperty(exports, "URL", { enumerable: true, get: function() {
    return URL_js_1.PonyfillURL;
  } });
  var URLSearchParams_js_1 = require_URLSearchParams();
  Object.defineProperty(exports, "URLSearchParams", { enumerable: true, get: function() {
    return URLSearchParams_js_1.PonyfillURLSearchParams;
  } });
  var WritableStream_js_1 = require_WritableStream();
  Object.defineProperty(exports, "WritableStream", { enumerable: true, get: function() {
    return WritableStream_js_1.PonyfillWritableStream;
  } });
  var TransformStream_js_1 = require_TransformStream();
  Object.defineProperty(exports, "TransformStream", { enumerable: true, get: function() {
    return TransformStream_js_1.PonyfillTransformStream;
  } });
  var CompressionStream_js_1 = require_CompressionStream();
  Object.defineProperty(exports, "CompressionStream", { enumerable: true, get: function() {
    return CompressionStream_js_1.PonyfillCompressionStream;
  } });
  var DecompressionStream_js_1 = require_DecompressionStream();
  Object.defineProperty(exports, "DecompressionStream", { enumerable: true, get: function() {
    return DecompressionStream_js_1.PonyfillDecompressionStream;
  } });
});

// ../../node_modules/@whatwg-node/fetch/dist/create-node-ponyfill.js
var require_create_node_ponyfill = __commonJS((exports, module) => {
  var shouldSkipPonyfill = require_shouldSkipPonyfill();
  module.exports = function createNodePonyfill(opts = {}) {
    const ponyfills = {};
    ponyfills.URLPattern = globalThis.URLPattern;
    if (!ponyfills.URLPattern) {
      const urlPatternModule = require_urlpattern_polyfill();
      ponyfills.URLPattern = urlPatternModule.URLPattern;
    }
    if (opts.skipPonyfill || shouldSkipPonyfill()) {
      return {
        fetch: globalThis.fetch,
        Headers: globalThis.Headers,
        Request: globalThis.Request,
        Response: globalThis.Response,
        FormData: globalThis.FormData,
        ReadableStream: globalThis.ReadableStream,
        WritableStream: globalThis.WritableStream,
        TransformStream: globalThis.TransformStream,
        CompressionStream: globalThis.CompressionStream,
        DecompressionStream: globalThis.DecompressionStream,
        Blob: globalThis.Blob,
        File: globalThis.File,
        crypto: globalThis.crypto,
        btoa: globalThis.btoa,
        TextEncoder: globalThis.TextEncoder,
        TextDecoder: globalThis.TextDecoder,
        URLPattern: ponyfills.URLPattern,
        URL: globalThis.URL,
        URLSearchParams: globalThis.URLSearchParams
      };
    }
    const newNodeFetch = require_cjs();
    ponyfills.fetch = newNodeFetch.fetch;
    ponyfills.Request = newNodeFetch.Request;
    ponyfills.Response = newNodeFetch.Response;
    ponyfills.Headers = newNodeFetch.Headers;
    ponyfills.FormData = newNodeFetch.FormData;
    ponyfills.ReadableStream = newNodeFetch.ReadableStream;
    ponyfills.URL = newNodeFetch.URL;
    ponyfills.URLSearchParams = newNodeFetch.URLSearchParams;
    ponyfills.WritableStream = newNodeFetch.WritableStream;
    ponyfills.TransformStream = newNodeFetch.TransformStream;
    ponyfills.CompressionStream = newNodeFetch.CompressionStream;
    ponyfills.DecompressionStream = newNodeFetch.DecompressionStream;
    ponyfills.Blob = newNodeFetch.Blob;
    ponyfills.File = newNodeFetch.File;
    ponyfills.crypto = globalThis.crypto;
    ponyfills.btoa = newNodeFetch.btoa;
    ponyfills.TextEncoder = newNodeFetch.TextEncoder;
    ponyfills.TextDecoder = newNodeFetch.TextDecoder;
    if (opts.formDataLimits) {
      ponyfills.Body = class Body extends newNodeFetch.Body {
        constructor(body, userOpts) {
          super(body, {
            formDataLimits: opts.formDataLimits,
            ...userOpts
          });
        }
      };
      ponyfills.Request = class Request2 extends newNodeFetch.Request {
        constructor(input, userOpts) {
          super(input, {
            formDataLimits: opts.formDataLimits,
            ...userOpts
          });
        }
      };
      ponyfills.Response = class Response2 extends newNodeFetch.Response {
        constructor(body, userOpts) {
          super(body, {
            formDataLimits: opts.formDataLimits,
            ...userOpts
          });
        }
      };
    }
    if (!ponyfills.crypto) {
      const cryptoModule = import.meta.require("crypto");
      ponyfills.crypto = cryptoModule.webcrypto;
    }
    return ponyfills;
  };
});

// ../../node_modules/lodash/_listCacheClear.js
var require__listCacheClear = __commonJS((exports, module) => {
  var listCacheClear = function() {
    this.__data__ = [];
    this.size = 0;
  };
  module.exports = listCacheClear;
});

// ../../node_modules/lodash/eq.js
var require_eq = __commonJS((exports, module) => {
  var eq = function(value, other) {
    return value === other || value !== value && other !== other;
  };
  module.exports = eq;
});

// ../../node_modules/lodash/_assocIndexOf.js
var require__assocIndexOf = __commonJS((exports, module) => {
  var assocIndexOf = function(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  };
  var eq = require_eq();
  module.exports = assocIndexOf;
});

// ../../node_modules/lodash/_listCacheDelete.js
var require__listCacheDelete = __commonJS((exports, module) => {
  var listCacheDelete = function(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  };
  var assocIndexOf = require__assocIndexOf();
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  module.exports = listCacheDelete;
});

// ../../node_modules/lodash/_listCacheGet.js
var require__listCacheGet = __commonJS((exports, module) => {
  var listCacheGet = function(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  };
  var assocIndexOf = require__assocIndexOf();
  module.exports = listCacheGet;
});

// ../../node_modules/lodash/_listCacheHas.js
var require__listCacheHas = __commonJS((exports, module) => {
  var listCacheHas = function(key) {
    return assocIndexOf(this.__data__, key) > -1;
  };
  var assocIndexOf = require__assocIndexOf();
  module.exports = listCacheHas;
});

// ../../node_modules/lodash/_listCacheSet.js
var require__listCacheSet = __commonJS((exports, module) => {
  var listCacheSet = function(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  };
  var assocIndexOf = require__assocIndexOf();
  module.exports = listCacheSet;
});

// ../../node_modules/lodash/_ListCache.js
var require__ListCache = __commonJS((exports, module) => {
  var ListCache = function(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  };
  var listCacheClear = require__listCacheClear();
  var listCacheDelete = require__listCacheDelete();
  var listCacheGet = require__listCacheGet();
  var listCacheHas = require__listCacheHas();
  var listCacheSet = require__listCacheSet();
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  module.exports = ListCache;
});

// ../../node_modules/lodash/_stackClear.js
var require__stackClear = __commonJS((exports, module) => {
  var stackClear = function() {
    this.__data__ = new ListCache;
    this.size = 0;
  };
  var ListCache = require__ListCache();
  module.exports = stackClear;
});

// ../../node_modules/lodash/_stackDelete.js
var require__stackDelete = __commonJS((exports, module) => {
  var stackDelete = function(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  };
  module.exports = stackDelete;
});

// ../../node_modules/lodash/_stackGet.js
var require__stackGet = __commonJS((exports, module) => {
  var stackGet = function(key) {
    return this.__data__.get(key);
  };
  module.exports = stackGet;
});

// ../../node_modules/lodash/_stackHas.js
var require__stackHas = __commonJS((exports, module) => {
  var stackHas = function(key) {
    return this.__data__.has(key);
  };
  module.exports = stackHas;
});

// ../../node_modules/lodash/_freeGlobal.js
var require__freeGlobal = __commonJS((exports, module) => {
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  module.exports = freeGlobal;
});

// ../../node_modules/lodash/_root.js
var require__root = __commonJS((exports, module) => {
  var freeGlobal = require__freeGlobal();
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  module.exports = root;
});

// ../../node_modules/lodash/_Symbol.js
var require__Symbol = __commonJS((exports, module) => {
  var root = require__root();
  var Symbol2 = root.Symbol;
  module.exports = Symbol2;
});

// ../../node_modules/lodash/_getRawTag.js
var require__getRawTag = __commonJS((exports, module) => {
  var getRawTag = function(value) {
    var isOwn = hasOwnProperty3.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  };
  var Symbol2 = require__Symbol();
  var objectProto = Object.prototype;
  var hasOwnProperty3 = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined;
  module.exports = getRawTag;
});

// ../../node_modules/lodash/_objectToString.js
var require__objectToString = __commonJS((exports, module) => {
  var objectToString = function(value) {
    return nativeObjectToString.call(value);
  };
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;
  module.exports = objectToString;
});

// ../../node_modules/lodash/_baseGetTag.js
var require__baseGetTag = __commonJS((exports, module) => {
  var baseGetTag = function(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  };
  var Symbol2 = require__Symbol();
  var getRawTag = require__getRawTag();
  var objectToString = require__objectToString();
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined;
  module.exports = baseGetTag;
});

// ../../node_modules/lodash/isObject.js
var require_isObject = __commonJS((exports, module) => {
  var isObject3 = function(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  };
  module.exports = isObject3;
});

// ../../node_modules/lodash/isFunction.js
var require_isFunction = __commonJS((exports, module) => {
  var isFunction = function(value) {
    if (!isObject3(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  };
  var baseGetTag = require__baseGetTag();
  var isObject3 = require_isObject();
  var asyncTag = "[object AsyncFunction]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var proxyTag = "[object Proxy]";
  module.exports = isFunction;
});

// ../../node_modules/lodash/_coreJsData.js
var require__coreJsData = __commonJS((exports, module) => {
  var root = require__root();
  var coreJsData = root["__core-js_shared__"];
  module.exports = coreJsData;
});

// ../../node_modules/lodash/_isMasked.js
var require__isMasked = __commonJS((exports, module) => {
  var isMasked = function(func) {
    return !!maskSrcKey && maskSrcKey in func;
  };
  var coreJsData = require__coreJsData();
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  module.exports = isMasked;
});

// ../../node_modules/lodash/_toSource.js
var require__toSource = __commonJS((exports, module) => {
  var toSource = function(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  };
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  module.exports = toSource;
});

// ../../node_modules/lodash/_baseIsNative.js
var require__baseIsNative = __commonJS((exports, module) => {
  var baseIsNative = function(value) {
    if (!isObject3(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  };
  var isFunction = require_isFunction();
  var isMasked = require__isMasked();
  var isObject3 = require_isObject();
  var toSource = require__toSource();
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty3 = objectProto.hasOwnProperty;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  module.exports = baseIsNative;
});

// ../../node_modules/lodash/_getValue.js
var require__getValue = __commonJS((exports, module) => {
  var getValue = function(object, key) {
    return object == null ? undefined : object[key];
  };
  module.exports = getValue;
});

// ../../node_modules/lodash/_getNative.js
var require__getNative = __commonJS((exports, module) => {
  var getNative = function(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  };
  var baseIsNative = require__baseIsNative();
  var getValue = require__getValue();
  module.exports = getNative;
});

// ../../node_modules/lodash/_Map.js
var require__Map = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var Map2 = getNative(root, "Map");
  module.exports = Map2;
});

// ../../node_modules/lodash/_nativeCreate.js
var require__nativeCreate = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var nativeCreate = getNative(Object, "create");
  module.exports = nativeCreate;
});

// ../../node_modules/lodash/_hashClear.js
var require__hashClear = __commonJS((exports, module) => {
  var hashClear = function() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  };
  var nativeCreate = require__nativeCreate();
  module.exports = hashClear;
});

// ../../node_modules/lodash/_hashDelete.js
var require__hashDelete = __commonJS((exports, module) => {
  var hashDelete = function(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  };
  module.exports = hashDelete;
});

// ../../node_modules/lodash/_hashGet.js
var require__hashGet = __commonJS((exports, module) => {
  var hashGet = function(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty3.call(data, key) ? data[key] : undefined;
  };
  var nativeCreate = require__nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto = Object.prototype;
  var hasOwnProperty3 = objectProto.hasOwnProperty;
  module.exports = hashGet;
});

// ../../node_modules/lodash/_hashHas.js
var require__hashHas = __commonJS((exports, module) => {
  var hashHas = function(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty3.call(data, key);
  };
  var nativeCreate = require__nativeCreate();
  var objectProto = Object.prototype;
  var hasOwnProperty3 = objectProto.hasOwnProperty;
  module.exports = hashHas;
});

// ../../node_modules/lodash/_hashSet.js
var require__hashSet = __commonJS((exports, module) => {
  var hashSet = function(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  };
  var nativeCreate = require__nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  module.exports = hashSet;
});

// ../../node_modules/lodash/_Hash.js
var require__Hash = __commonJS((exports, module) => {
  var Hash = function(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  };
  var hashClear = require__hashClear();
  var hashDelete = require__hashDelete();
  var hashGet = require__hashGet();
  var hashHas = require__hashHas();
  var hashSet = require__hashSet();
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  module.exports = Hash;
});

// ../../node_modules/lodash/_mapCacheClear.js
var require__mapCacheClear = __commonJS((exports, module) => {
  var mapCacheClear = function() {
    this.size = 0;
    this.__data__ = {
      hash: new Hash,
      map: new (Map2 || ListCache),
      string: new Hash
    };
  };
  var Hash = require__Hash();
  var ListCache = require__ListCache();
  var Map2 = require__Map();
  module.exports = mapCacheClear;
});

// ../../node_modules/lodash/_isKeyable.js
var require__isKeyable = __commonJS((exports, module) => {
  var isKeyable = function(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  };
  module.exports = isKeyable;
});

// ../../node_modules/lodash/_getMapData.js
var require__getMapData = __commonJS((exports, module) => {
  var getMapData = function(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  };
  var isKeyable = require__isKeyable();
  module.exports = getMapData;
});

// ../../node_modules/lodash/_mapCacheDelete.js
var require__mapCacheDelete = __commonJS((exports, module) => {
  var mapCacheDelete = function(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  };
  var getMapData = require__getMapData();
  module.exports = mapCacheDelete;
});

// ../../node_modules/lodash/_mapCacheGet.js
var require__mapCacheGet = __commonJS((exports, module) => {
  var mapCacheGet = function(key) {
    return getMapData(this, key).get(key);
  };
  var getMapData = require__getMapData();
  module.exports = mapCacheGet;
});

// ../../node_modules/lodash/_mapCacheHas.js
var require__mapCacheHas = __commonJS((exports, module) => {
  var mapCacheHas = function(key) {
    return getMapData(this, key).has(key);
  };
  var getMapData = require__getMapData();
  module.exports = mapCacheHas;
});

// ../../node_modules/lodash/_mapCacheSet.js
var require__mapCacheSet = __commonJS((exports, module) => {
  var mapCacheSet = function(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  };
  var getMapData = require__getMapData();
  module.exports = mapCacheSet;
});

// ../../node_modules/lodash/_MapCache.js
var require__MapCache = __commonJS((exports, module) => {
  var MapCache = function(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  };
  var mapCacheClear = require__mapCacheClear();
  var mapCacheDelete = require__mapCacheDelete();
  var mapCacheGet = require__mapCacheGet();
  var mapCacheHas = require__mapCacheHas();
  var mapCacheSet = require__mapCacheSet();
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  module.exports = MapCache;
});

// ../../node_modules/lodash/_stackSet.js
var require__stackSet = __commonJS((exports, module) => {
  var stackSet = function(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  };
  var ListCache = require__ListCache();
  var Map2 = require__Map();
  var MapCache = require__MapCache();
  var LARGE_ARRAY_SIZE = 200;
  module.exports = stackSet;
});

// ../../node_modules/lodash/_Stack.js
var require__Stack = __commonJS((exports, module) => {
  var Stack2 = function(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  };
  var ListCache = require__ListCache();
  var stackClear = require__stackClear();
  var stackDelete = require__stackDelete();
  var stackGet = require__stackGet();
  var stackHas = require__stackHas();
  var stackSet = require__stackSet();
  Stack2.prototype.clear = stackClear;
  Stack2.prototype["delete"] = stackDelete;
  Stack2.prototype.get = stackGet;
  Stack2.prototype.has = stackHas;
  Stack2.prototype.set = stackSet;
  module.exports = Stack2;
});

// ../../node_modules/lodash/_defineProperty.js
var require__defineProperty = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var defineProperty = function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  }();
  module.exports = defineProperty;
});

// ../../node_modules/lodash/_baseAssignValue.js
var require__baseAssignValue = __commonJS((exports, module) => {
  var baseAssignValue = function(object, key, value) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object, key, {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      });
    } else {
      object[key] = value;
    }
  };
  var defineProperty = require__defineProperty();
  module.exports = baseAssignValue;
});

// ../../node_modules/lodash/_assignMergeValue.js
var require__assignMergeValue = __commonJS((exports, module) => {
  var assignMergeValue = function(object, key, value) {
    if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  };
  var baseAssignValue = require__baseAssignValue();
  var eq = require_eq();
  module.exports = assignMergeValue;
});

// ../../node_modules/lodash/_createBaseFor.js
var require__createBaseFor = __commonJS((exports, module) => {
  var createBaseFor = function(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  };
  module.exports = createBaseFor;
});

// ../../node_modules/lodash/_baseFor.js
var require__baseFor = __commonJS((exports, module) => {
  var createBaseFor = require__createBaseFor();
  var baseFor = createBaseFor();
  module.exports = baseFor;
});

// ../../node_modules/lodash/_cloneBuffer.js
var require__cloneBuffer = __commonJS((exports, module) => {
  var cloneBuffer = function(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  };
  var root = require__root();
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root.Buffer : undefined;
  var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined;
  module.exports = cloneBuffer;
});

// ../../node_modules/lodash/_Uint8Array.js
var require__Uint8Array = __commonJS((exports, module) => {
  var root = require__root();
  var Uint8Array2 = root.Uint8Array;
  module.exports = Uint8Array2;
});

// ../../node_modules/lodash/_cloneArrayBuffer.js
var require__cloneArrayBuffer = __commonJS((exports, module) => {
  var cloneArrayBuffer = function(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
    return result;
  };
  var Uint8Array2 = require__Uint8Array();
  module.exports = cloneArrayBuffer;
});

// ../../node_modules/lodash/_cloneTypedArray.js
var require__cloneTypedArray = __commonJS((exports, module) => {
  var cloneTypedArray = function(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  };
  var cloneArrayBuffer = require__cloneArrayBuffer();
  module.exports = cloneTypedArray;
});

// ../../node_modules/lodash/_copyArray.js
var require__copyArray = __commonJS((exports, module) => {
  var copyArray = function(source2, array) {
    var index = -1, length = source2.length;
    array || (array = Array(length));
    while (++index < length) {
      array[index] = source2[index];
    }
    return array;
  };
  module.exports = copyArray;
});

// ../../node_modules/lodash/_baseCreate.js
var require__baseCreate = __commonJS((exports, module) => {
  var isObject3 = require_isObject();
  var objectCreate = Object.create;
  var baseCreate = function() {
    function object() {
    }
    return function(proto) {
      if (!isObject3(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object;
      object.prototype = undefined;
      return result;
    };
  }();
  module.exports = baseCreate;
});

// ../../node_modules/lodash/_overArg.js
var require__overArg = __commonJS((exports, module) => {
  var overArg = function(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  };
  module.exports = overArg;
});

// ../../node_modules/lodash/_getPrototype.js
var require__getPrototype = __commonJS((exports, module) => {
  var overArg = require__overArg();
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  module.exports = getPrototype;
});

// ../../node_modules/lodash/_isPrototype.js
var require__isPrototype = __commonJS((exports, module) => {
  var isPrototype = function(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  };
  var objectProto = Object.prototype;
  module.exports = isPrototype;
});

// ../../node_modules/lodash/_initCloneObject.js
var require__initCloneObject = __commonJS((exports, module) => {
  var initCloneObject = function(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  };
  var baseCreate = require__baseCreate();
  var getPrototype = require__getPrototype();
  var isPrototype = require__isPrototype();
  module.exports = initCloneObject;
});

// ../../node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS((exports, module) => {
  var isObjectLike11 = function(value) {
    return value != null && typeof value == "object";
  };
  module.exports = isObjectLike11;
});

// ../../node_modules/lodash/_baseIsArguments.js
var require__baseIsArguments = __commonJS((exports, module) => {
  var baseIsArguments = function(value) {
    return isObjectLike11(value) && baseGetTag(value) == argsTag;
  };
  var baseGetTag = require__baseGetTag();
  var isObjectLike11 = require_isObjectLike();
  var argsTag = "[object Arguments]";
  module.exports = baseIsArguments;
});

// ../../node_modules/lodash/isArguments.js
var require_isArguments = __commonJS((exports, module) => {
  var baseIsArguments = require__baseIsArguments();
  var isObjectLike11 = require_isObjectLike();
  var objectProto = Object.prototype;
  var hasOwnProperty3 = objectProto.hasOwnProperty;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike11(value) && hasOwnProperty3.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  module.exports = isArguments;
});

// ../../node_modules/lodash/isArray.js
var require_isArray = __commonJS((exports, module) => {
  var isArray = Array.isArray;
  module.exports = isArray;
});

// ../../node_modules/lodash/isLength.js
var require_isLength = __commonJS((exports, module) => {
  var isLength = function(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  };
  var MAX_SAFE_INTEGER = 9007199254740991;
  module.exports = isLength;
});

// ../../node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS((exports, module) => {
  var isArrayLike = function(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  };
  var isFunction = require_isFunction();
  var isLength = require_isLength();
  module.exports = isArrayLike;
});

// ../../node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS((exports, module) => {
  var isArrayLikeObject = function(value) {
    return isObjectLike11(value) && isArrayLike(value);
  };
  var isArrayLike = require_isArrayLike();
  var isObjectLike11 = require_isObjectLike();
  module.exports = isArrayLikeObject;
});

// ../../node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS((exports, module) => {
  var stubFalse = function() {
    return false;
  };
  module.exports = stubFalse;
});

// ../../node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS((exports, module) => {
  var root = require__root();
  var stubFalse = require_stubFalse();
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root.Buffer : undefined;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined;
  var isBuffer = nativeIsBuffer || stubFalse;
  module.exports = isBuffer;
});

// ../../node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS((exports, module) => {
  var isPlainObject = function(value) {
    if (!isObjectLike11(value) || baseGetTag(value) != objectTag) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty3.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  };
  var baseGetTag = require__baseGetTag();
  var getPrototype = require__getPrototype();
  var isObjectLike11 = require_isObjectLike();
  var objectTag = "[object Object]";
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty3 = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  module.exports = isPlainObject;
});

// ../../node_modules/lodash/_baseIsTypedArray.js
var require__baseIsTypedArray = __commonJS((exports, module) => {
  var baseIsTypedArray = function(value) {
    return isObjectLike11(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  };
  var baseGetTag = require__baseGetTag();
  var isLength = require_isLength();
  var isObjectLike11 = require_isObjectLike();
  var argsTag = "[object Arguments]";
  var arrayTag = "[object Array]";
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var funcTag = "[object Function]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var objectTag = "[object Object]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  module.exports = baseIsTypedArray;
});

// ../../node_modules/lodash/_baseUnary.js
var require__baseUnary = __commonJS((exports, module) => {
  var baseUnary = function(func) {
    return function(value) {
      return func(value);
    };
  };
  module.exports = baseUnary;
});

// ../../node_modules/lodash/_nodeUtil.js
var require__nodeUtil = __commonJS((exports, module) => {
  var freeGlobal = require__freeGlobal();
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal.process;
  var nodeUtil = function() {
    try {
      var types2 = freeModule && freeModule.require && freeModule.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  module.exports = nodeUtil;
});

// ../../node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS((exports, module) => {
  var baseIsTypedArray = require__baseIsTypedArray();
  var baseUnary = require__baseUnary();
  var nodeUtil = require__nodeUtil();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  module.exports = isTypedArray;
});

// ../../node_modules/lodash/_safeGet.js
var require__safeGet = __commonJS((exports, module) => {
  var safeGet = function(object, key) {
    if (key === "constructor" && typeof object[key] === "function") {
      return;
    }
    if (key == "__proto__") {
      return;
    }
    return object[key];
  };
  module.exports = safeGet;
});

// ../../node_modules/lodash/_assignValue.js
var require__assignValue = __commonJS((exports, module) => {
  var assignValue = function(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty3.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  };
  var baseAssignValue = require__baseAssignValue();
  var eq = require_eq();
  var objectProto = Object.prototype;
  var hasOwnProperty3 = objectProto.hasOwnProperty;
  module.exports = assignValue;
});

// ../../node_modules/lodash/_copyObject.js
var require__copyObject = __commonJS((exports, module) => {
  var copyObject = function(source2, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source2[key], key, object, source2) : undefined;
      if (newValue === undefined) {
        newValue = source2[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  };
  var assignValue = require__assignValue();
  var baseAssignValue = require__baseAssignValue();
  module.exports = copyObject;
});

// ../../node_modules/lodash/_baseTimes.js
var require__baseTimes = __commonJS((exports, module) => {
  var baseTimes = function(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  };
  module.exports = baseTimes;
});

// ../../node_modules/lodash/_isIndex.js
var require__isIndex = __commonJS((exports, module) => {
  var isIndex = function(value, length) {
    var type2 = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  };
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  module.exports = isIndex;
});

// ../../node_modules/lodash/_arrayLikeKeys.js
var require__arrayLikeKeys = __commonJS((exports, module) => {
  var arrayLikeKeys = function(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty3.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  };
  var baseTimes = require__baseTimes();
  var isArguments = require_isArguments();
  var isArray = require_isArray();
  var isBuffer = require_isBuffer();
  var isIndex = require__isIndex();
  var isTypedArray = require_isTypedArray();
  var objectProto = Object.prototype;
  var hasOwnProperty3 = objectProto.hasOwnProperty;
  module.exports = arrayLikeKeys;
});

// ../../node_modules/lodash/_nativeKeysIn.js
var require__nativeKeysIn = __commonJS((exports, module) => {
  var nativeKeysIn = function(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  };
  module.exports = nativeKeysIn;
});

// ../../node_modules/lodash/_baseKeysIn.js
var require__baseKeysIn = __commonJS((exports, module) => {
  var baseKeysIn = function(object) {
    if (!isObject3(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty3.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  };
  var isObject3 = require_isObject();
  var isPrototype = require__isPrototype();
  var nativeKeysIn = require__nativeKeysIn();
  var objectProto = Object.prototype;
  var hasOwnProperty3 = objectProto.hasOwnProperty;
  module.exports = baseKeysIn;
});

// ../../node_modules/lodash/keysIn.js
var require_keysIn = __commonJS((exports, module) => {
  var keysIn = function(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  };
  var arrayLikeKeys = require__arrayLikeKeys();
  var baseKeysIn = require__baseKeysIn();
  var isArrayLike = require_isArrayLike();
  module.exports = keysIn;
});

// ../../node_modules/lodash/toPlainObject.js
var require_toPlainObject = __commonJS((exports, module) => {
  var toPlainObject = function(value) {
    return copyObject(value, keysIn(value));
  };
  var copyObject = require__copyObject();
  var keysIn = require_keysIn();
  module.exports = toPlainObject;
});

// ../../node_modules/lodash/_baseMergeDeep.js
var require__baseMergeDeep = __commonJS((exports, module) => {
  var baseMergeDeep = function(object, source2, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object, key), srcValue = safeGet(source2, key), stacked = stack.get(srcValue);
    if (stacked) {
      assignMergeValue(object, key, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source2, stack) : undefined;
    var isCommon = newValue === undefined;
    if (isCommon) {
      var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
        newValue = objValue;
        if (isArguments(objValue)) {
          newValue = toPlainObject(objValue);
        } else if (!isObject3(objValue) || isFunction(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack["delete"](srcValue);
    }
    assignMergeValue(object, key, newValue);
  };
  var assignMergeValue = require__assignMergeValue();
  var cloneBuffer = require__cloneBuffer();
  var cloneTypedArray = require__cloneTypedArray();
  var copyArray = require__copyArray();
  var initCloneObject = require__initCloneObject();
  var isArguments = require_isArguments();
  var isArray = require_isArray();
  var isArrayLikeObject = require_isArrayLikeObject();
  var isBuffer = require_isBuffer();
  var isFunction = require_isFunction();
  var isObject3 = require_isObject();
  var isPlainObject = require_isPlainObject();
  var isTypedArray = require_isTypedArray();
  var safeGet = require__safeGet();
  var toPlainObject = require_toPlainObject();
  module.exports = baseMergeDeep;
});

// ../../node_modules/lodash/_baseMerge.js
var require__baseMerge = __commonJS((exports, module) => {
  var baseMerge = function(object, source2, srcIndex, customizer, stack) {
    if (object === source2) {
      return;
    }
    baseFor(source2, function(srcValue, key) {
      stack || (stack = new Stack2);
      if (isObject3(srcValue)) {
        baseMergeDeep(object, source2, key, srcIndex, baseMerge, customizer, stack);
      } else {
        var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source2, stack) : undefined;
        if (newValue === undefined) {
          newValue = srcValue;
        }
        assignMergeValue(object, key, newValue);
      }
    }, keysIn);
  };
  var Stack2 = require__Stack();
  var assignMergeValue = require__assignMergeValue();
  var baseFor = require__baseFor();
  var baseMergeDeep = require__baseMergeDeep();
  var isObject3 = require_isObject();
  var keysIn = require_keysIn();
  var safeGet = require__safeGet();
  module.exports = baseMerge;
});

// ../../node_modules/lodash/identity.js
var require_identity = __commonJS((exports, module) => {
  var identity = function(value) {
    return value;
  };
  module.exports = identity;
});

// ../../node_modules/lodash/_apply.js
var require__apply = __commonJS((exports, module) => {
  var apply = function(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  };
  module.exports = apply;
});

// ../../node_modules/lodash/_overRest.js
var require__overRest = __commonJS((exports, module) => {
  var overRest = function(func, start, transform) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  };
  var apply = require__apply();
  var nativeMax = Math.max;
  module.exports = overRest;
});

// ../../node_modules/lodash/constant.js
var require_constant = __commonJS((exports, module) => {
  var constant = function(value) {
    return function() {
      return value;
    };
  };
  module.exports = constant;
});

// ../../node_modules/lodash/_baseSetToString.js
var require__baseSetToString = __commonJS((exports, module) => {
  var constant = require_constant();
  var defineProperty = require__defineProperty();
  var identity = require_identity();
  var baseSetToString = !defineProperty ? identity : function(func, string) {
    return defineProperty(func, "toString", {
      configurable: true,
      enumerable: false,
      value: constant(string),
      writable: true
    });
  };
  module.exports = baseSetToString;
});

// ../../node_modules/lodash/_shortOut.js
var require__shortOut = __commonJS((exports, module) => {
  var shortOut = function(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(undefined, arguments);
    };
  };
  var HOT_COUNT = 800;
  var HOT_SPAN = 16;
  var nativeNow = Date.now;
  module.exports = shortOut;
});

// ../../node_modules/lodash/_setToString.js
var require__setToString = __commonJS((exports, module) => {
  var baseSetToString = require__baseSetToString();
  var shortOut = require__shortOut();
  var setToString = shortOut(baseSetToString);
  module.exports = setToString;
});

// ../../node_modules/lodash/_baseRest.js
var require__baseRest = __commonJS((exports, module) => {
  var baseRest = function(func, start) {
    return setToString(overRest(func, start, identity), func + "");
  };
  var identity = require_identity();
  var overRest = require__overRest();
  var setToString = require__setToString();
  module.exports = baseRest;
});

// ../../node_modules/lodash/_isIterateeCall.js
var require__isIterateeCall = __commonJS((exports, module) => {
  var isIterateeCall = function(value, index, object) {
    if (!isObject3(object)) {
      return false;
    }
    var type2 = typeof index;
    if (type2 == "number" ? isArrayLike(object) && isIndex(index, object.length) : type2 == "string" && (index in object)) {
      return eq(object[index], value);
    }
    return false;
  };
  var eq = require_eq();
  var isArrayLike = require_isArrayLike();
  var isIndex = require__isIndex();
  var isObject3 = require_isObject();
  module.exports = isIterateeCall;
});

// ../../node_modules/lodash/_createAssigner.js
var require__createAssigner = __commonJS((exports, module) => {
  var createAssigner = function(assigner) {
    return baseRest(function(object, sources) {
      var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source2 = sources[index];
        if (source2) {
          assigner(object, source2, index, customizer);
        }
      }
      return object;
    });
  };
  var baseRest = require__baseRest();
  var isIterateeCall = require__isIterateeCall();
  module.exports = createAssigner;
});

// ../../node_modules/lodash/merge.js
var require_merge = __commonJS((exports, module) => {
  var baseMerge = require__baseMerge();
  var createAssigner = require__createAssigner();
  var merge2 = createAssigner(function(object, source2, srcIndex) {
    baseMerge(object, source2, srcIndex);
  });
  module.exports = merge2;
});

// ../../node_modules/change-case/node_modules/tslib/tslib.js
var require_tslib2 = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept2(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept2(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept2(result.get))
            descriptor.get = _;
          if (_ = accept2(result.set))
            descriptor.set = _;
          if (_ = accept2(result.init))
            initializers.unshift(_);
        } else if (_ = accept2(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error8) {
        e = { error: error8 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env2, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env2.stack.push({ value, dispose, async });
      } else if (async) {
        env2.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error8, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error8, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env2) {
      function fail(e) {
        env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
        env2.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env2.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env2.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
        if (env2.hasError)
          throw env2.error;
      }
      return next();
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
  });
});

// ../../node_modules/camel-case/node_modules/tslib/tslib.js
var require_tslib3 = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept2(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept2(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept2(result.get))
            descriptor.get = _;
          if (_ = accept2(result.set))
            descriptor.set = _;
          if (_ = accept2(result.init))
            initializers.unshift(_);
        } else if (_ = accept2(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error8) {
        e = { error: error8 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env2, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env2.stack.push({ value, dispose, async });
      } else if (async) {
        env2.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error8, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error8, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env2) {
      function fail(e) {
        env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
        env2.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env2.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env2.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
        if (env2.hasError)
          throw env2.error;
      }
      return next();
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
  });
});

// ../../node_modules/pascal-case/node_modules/tslib/tslib.js
var require_tslib4 = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept2(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept2(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept2(result.get))
            descriptor.get = _;
          if (_ = accept2(result.set))
            descriptor.set = _;
          if (_ = accept2(result.init))
            initializers.unshift(_);
        } else if (_ = accept2(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error8) {
        e = { error: error8 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env2, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env2.stack.push({ value, dispose, async });
      } else if (async) {
        env2.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error8, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error8, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env2) {
      function fail(e) {
        env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
        env2.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env2.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env2.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
        if (env2.hasError)
          throw env2.error;
      }
      return next();
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
  });
});

// ../../node_modules/lower-case/dist/index.js
var require_dist = __commonJS((exports) => {
  var localeLowerCase = function(str, locale) {
    var lang = SUPPORTED_LOCALE[locale.toLowerCase()];
    if (lang)
      return lowerCase(str.replace(lang.regexp, function(m) {
        return lang.map[m];
      }));
    return lowerCase(str);
  };
  var lowerCase = function(str) {
    return str.toLowerCase();
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.lowerCase = exports.localeLowerCase = undefined;
  var SUPPORTED_LOCALE = {
    tr: {
      regexp: /\u0130|\u0049|\u0049\u0307/g,
      map: {
        "İ": "i",
        I: "\u0131",
        "İ": "i"
      }
    },
    az: {
      regexp: /\u0130/g,
      map: {
        "İ": "i",
        I: "\u0131",
        "İ": "i"
      }
    },
    lt: {
      regexp: /\u0049|\u004A|\u012E|\u00CC|\u00CD|\u0128/g,
      map: {
        I: "i\u0307",
        J: "j\u0307",
        "Į": "\u012F\u0307",
        "Ì": "i\u0307\u0300",
        "Í": "i\u0307\u0301",
        "Ĩ": "i\u0307\u0303"
      }
    }
  };
  exports.localeLowerCase = localeLowerCase;
  exports.lowerCase = lowerCase;
});

// ../../node_modules/no-case/dist/index.js
var require_dist2 = __commonJS((exports) => {
  var noCase = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    var _a = options.splitRegexp, splitRegexp = _a === undefined ? DEFAULT_SPLIT_REGEXP : _a, _b = options.stripRegexp, stripRegexp = _b === undefined ? DEFAULT_STRIP_REGEXP : _b, _c = options.transform, transform = _c === undefined ? lower_case_1.lowerCase : _c, _d = options.delimiter, delimiter = _d === undefined ? " " : _d;
    var result = replace(replace(input, splitRegexp, "$1\0$2"), stripRegexp, "\0");
    var start = 0;
    var end = result.length;
    while (result.charAt(start) === "\0")
      start++;
    while (result.charAt(end - 1) === "\0")
      end--;
    return result.slice(start, end).split("\0").map(transform).join(delimiter);
  };
  var replace = function(input, re, value) {
    if (re instanceof RegExp)
      return input.replace(re, value);
    return re.reduce(function(input2, re2) {
      return input2.replace(re2, value);
    }, input);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.noCase = undefined;
  var lower_case_1 = require_dist();
  var DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
  var DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;
  exports.noCase = noCase;
});

// ../../node_modules/pascal-case/dist/index.js
var require_dist3 = __commonJS((exports) => {
  var pascalCaseTransform = function(input, index) {
    var firstChar = input.charAt(0);
    var lowerChars = input.substr(1).toLowerCase();
    if (index > 0 && firstChar >= "0" && firstChar <= "9") {
      return "_" + firstChar + lowerChars;
    }
    return "" + firstChar.toUpperCase() + lowerChars;
  };
  var pascalCaseTransformMerge = function(input) {
    return input.charAt(0).toUpperCase() + input.slice(1).toLowerCase();
  };
  var pascalCase = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    return no_case_1.noCase(input, tslib_1.__assign({ delimiter: "", transform: pascalCaseTransform }, options));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pascalCase = exports.pascalCaseTransformMerge = exports.pascalCaseTransform = undefined;
  var tslib_1 = require_tslib4();
  var no_case_1 = require_dist2();
  exports.pascalCaseTransform = pascalCaseTransform;
  exports.pascalCaseTransformMerge = pascalCaseTransformMerge;
  exports.pascalCase = pascalCase;
});

// ../../node_modules/camel-case/dist/index.js
var require_dist4 = __commonJS((exports) => {
  var camelCaseTransform = function(input, index) {
    if (index === 0)
      return input.toLowerCase();
    return pascal_case_1.pascalCaseTransform(input, index);
  };
  var camelCaseTransformMerge = function(input, index) {
    if (index === 0)
      return input.toLowerCase();
    return pascal_case_1.pascalCaseTransformMerge(input);
  };
  var camelCase = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    return pascal_case_1.pascalCase(input, tslib_1.__assign({ transform: camelCaseTransform }, options));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.camelCase = exports.camelCaseTransformMerge = exports.camelCaseTransform = undefined;
  var tslib_1 = require_tslib3();
  var pascal_case_1 = require_dist3();
  exports.camelCaseTransform = camelCaseTransform;
  exports.camelCaseTransformMerge = camelCaseTransformMerge;
  exports.camelCase = camelCase;
});

// ../../node_modules/capital-case/node_modules/tslib/tslib.js
var require_tslib5 = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept2(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept2(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept2(result.get))
            descriptor.get = _;
          if (_ = accept2(result.set))
            descriptor.set = _;
          if (_ = accept2(result.init))
            initializers.unshift(_);
        } else if (_ = accept2(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error8) {
        e = { error: error8 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env2, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env2.stack.push({ value, dispose, async });
      } else if (async) {
        env2.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error8, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error8, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env2) {
      function fail(e) {
        env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
        env2.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env2.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env2.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
        if (env2.hasError)
          throw env2.error;
      }
      return next();
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
  });
});

// ../../node_modules/upper-case-first/dist/index.js
var require_dist5 = __commonJS((exports) => {
  var upperCaseFirst = function(input) {
    return input.charAt(0).toUpperCase() + input.substr(1);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.upperCaseFirst = undefined;
  exports.upperCaseFirst = upperCaseFirst;
});

// ../../node_modules/capital-case/dist/index.js
var require_dist6 = __commonJS((exports) => {
  var capitalCaseTransform = function(input) {
    return upper_case_first_1.upperCaseFirst(input.toLowerCase());
  };
  var capitalCase = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    return no_case_1.noCase(input, tslib_1.__assign({ delimiter: " ", transform: capitalCaseTransform }, options));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.capitalCase = exports.capitalCaseTransform = undefined;
  var tslib_1 = require_tslib5();
  var no_case_1 = require_dist2();
  var upper_case_first_1 = require_dist5();
  exports.capitalCaseTransform = capitalCaseTransform;
  exports.capitalCase = capitalCase;
});

// ../../node_modules/constant-case/node_modules/tslib/tslib.js
var require_tslib6 = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept2(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept2(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept2(result.get))
            descriptor.get = _;
          if (_ = accept2(result.set))
            descriptor.set = _;
          if (_ = accept2(result.init))
            initializers.unshift(_);
        } else if (_ = accept2(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error8) {
        e = { error: error8 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env2, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env2.stack.push({ value, dispose, async });
      } else if (async) {
        env2.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error8, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error8, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env2) {
      function fail(e) {
        env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
        env2.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env2.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env2.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
        if (env2.hasError)
          throw env2.error;
      }
      return next();
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
  });
});

// ../../node_modules/upper-case/dist/index.js
var require_dist7 = __commonJS((exports) => {
  var localeUpperCase = function(str, locale) {
    var lang = SUPPORTED_LOCALE[locale.toLowerCase()];
    if (lang)
      return upperCase(str.replace(lang.regexp, function(m) {
        return lang.map[m];
      }));
    return upperCase(str);
  };
  var upperCase = function(str) {
    return str.toUpperCase();
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.upperCase = exports.localeUpperCase = undefined;
  var SUPPORTED_LOCALE = {
    tr: {
      regexp: /[\u0069]/g,
      map: {
        i: "\u0130"
      }
    },
    az: {
      regexp: /[\u0069]/g,
      map: {
        i: "\u0130"
      }
    },
    lt: {
      regexp: /[\u0069\u006A\u012F]\u0307|\u0069\u0307[\u0300\u0301\u0303]/g,
      map: {
        "i̇": "I",
        "j̇": "J",
        "į̇": "\u012E",
        "i̇̀": "\xCC",
        "i̇́": "\xCD",
        "i̇̃": "\u0128"
      }
    }
  };
  exports.localeUpperCase = localeUpperCase;
  exports.upperCase = upperCase;
});

// ../../node_modules/constant-case/dist/index.js
var require_dist8 = __commonJS((exports) => {
  var constantCase = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    return no_case_1.noCase(input, tslib_1.__assign({ delimiter: "_", transform: upper_case_1.upperCase }, options));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.constantCase = undefined;
  var tslib_1 = require_tslib6();
  var no_case_1 = require_dist2();
  var upper_case_1 = require_dist7();
  exports.constantCase = constantCase;
});

// ../../node_modules/dot-case/node_modules/tslib/tslib.js
var require_tslib7 = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept2(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept2(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept2(result.get))
            descriptor.get = _;
          if (_ = accept2(result.set))
            descriptor.set = _;
          if (_ = accept2(result.init))
            initializers.unshift(_);
        } else if (_ = accept2(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error8) {
        e = { error: error8 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env2, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env2.stack.push({ value, dispose, async });
      } else if (async) {
        env2.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error8, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error8, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env2) {
      function fail(e) {
        env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
        env2.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env2.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env2.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
        if (env2.hasError)
          throw env2.error;
      }
      return next();
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
  });
});

// ../../node_modules/dot-case/dist/index.js
var require_dist9 = __commonJS((exports) => {
  var dotCase = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    return no_case_1.noCase(input, tslib_1.__assign({ delimiter: "." }, options));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dotCase = undefined;
  var tslib_1 = require_tslib7();
  var no_case_1 = require_dist2();
  exports.dotCase = dotCase;
});

// ../../node_modules/header-case/node_modules/tslib/tslib.js
var require_tslib8 = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept2(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept2(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept2(result.get))
            descriptor.get = _;
          if (_ = accept2(result.set))
            descriptor.set = _;
          if (_ = accept2(result.init))
            initializers.unshift(_);
        } else if (_ = accept2(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error8) {
        e = { error: error8 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env2, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env2.stack.push({ value, dispose, async });
      } else if (async) {
        env2.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error8, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error8, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env2) {
      function fail(e) {
        env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
        env2.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env2.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env2.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
        if (env2.hasError)
          throw env2.error;
      }
      return next();
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
  });
});

// ../../node_modules/header-case/dist/index.js
var require_dist10 = __commonJS((exports) => {
  var headerCase = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    return capital_case_1.capitalCase(input, tslib_1.__assign({ delimiter: "-" }, options));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.headerCase = undefined;
  var tslib_1 = require_tslib8();
  var capital_case_1 = require_dist6();
  exports.headerCase = headerCase;
});

// ../../node_modules/param-case/node_modules/tslib/tslib.js
var require_tslib9 = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept2(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept2(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept2(result.get))
            descriptor.get = _;
          if (_ = accept2(result.set))
            descriptor.set = _;
          if (_ = accept2(result.init))
            initializers.unshift(_);
        } else if (_ = accept2(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error8) {
        e = { error: error8 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env2, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env2.stack.push({ value, dispose, async });
      } else if (async) {
        env2.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error8, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error8, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env2) {
      function fail(e) {
        env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
        env2.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env2.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env2.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
        if (env2.hasError)
          throw env2.error;
      }
      return next();
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
  });
});

// ../../node_modules/param-case/dist/index.js
var require_dist11 = __commonJS((exports) => {
  var paramCase = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    return dot_case_1.dotCase(input, tslib_1.__assign({ delimiter: "-" }, options));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.paramCase = undefined;
  var tslib_1 = require_tslib9();
  var dot_case_1 = require_dist9();
  exports.paramCase = paramCase;
});

// ../../node_modules/path-case/node_modules/tslib/tslib.js
var require_tslib10 = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept2(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept2(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept2(result.get))
            descriptor.get = _;
          if (_ = accept2(result.set))
            descriptor.set = _;
          if (_ = accept2(result.init))
            initializers.unshift(_);
        } else if (_ = accept2(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error8) {
        e = { error: error8 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env2, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env2.stack.push({ value, dispose, async });
      } else if (async) {
        env2.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error8, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error8, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env2) {
      function fail(e) {
        env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
        env2.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env2.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env2.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
        if (env2.hasError)
          throw env2.error;
      }
      return next();
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
  });
});

// ../../node_modules/path-case/dist/index.js
var require_dist12 = __commonJS((exports) => {
  var pathCase = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    return dot_case_1.dotCase(input, tslib_1.__assign({ delimiter: "/" }, options));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pathCase = undefined;
  var tslib_1 = require_tslib10();
  var dot_case_1 = require_dist9();
  exports.pathCase = pathCase;
});

// ../../node_modules/sentence-case/node_modules/tslib/tslib.js
var require_tslib11 = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept2(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept2(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept2(result.get))
            descriptor.get = _;
          if (_ = accept2(result.set))
            descriptor.set = _;
          if (_ = accept2(result.init))
            initializers.unshift(_);
        } else if (_ = accept2(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error8) {
        e = { error: error8 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env2, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env2.stack.push({ value, dispose, async });
      } else if (async) {
        env2.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error8, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error8, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env2) {
      function fail(e) {
        env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
        env2.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env2.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env2.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
        if (env2.hasError)
          throw env2.error;
      }
      return next();
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
  });
});

// ../../node_modules/sentence-case/dist/index.js
var require_dist13 = __commonJS((exports) => {
  var sentenceCaseTransform = function(input, index) {
    var result = input.toLowerCase();
    if (index === 0)
      return upper_case_first_1.upperCaseFirst(result);
    return result;
  };
  var sentenceCase = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    return no_case_1.noCase(input, tslib_1.__assign({ delimiter: " ", transform: sentenceCaseTransform }, options));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sentenceCase = exports.sentenceCaseTransform = undefined;
  var tslib_1 = require_tslib11();
  var no_case_1 = require_dist2();
  var upper_case_first_1 = require_dist5();
  exports.sentenceCaseTransform = sentenceCaseTransform;
  exports.sentenceCase = sentenceCase;
});

// ../../node_modules/snake-case/node_modules/tslib/tslib.js
var require_tslib12 = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept2(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept2(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept2(result.get))
            descriptor.get = _;
          if (_ = accept2(result.set))
            descriptor.set = _;
          if (_ = accept2(result.init))
            initializers.unshift(_);
        } else if (_ = accept2(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error8) {
        e = { error: error8 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env2, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env2.stack.push({ value, dispose, async });
      } else if (async) {
        env2.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error8, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error8, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env2) {
      function fail(e) {
        env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
        env2.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env2.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env2.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
        if (env2.hasError)
          throw env2.error;
      }
      return next();
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
  });
});

// ../../node_modules/snake-case/dist/index.js
var require_dist14 = __commonJS((exports) => {
  var snakeCase = function(input, options) {
    if (options === undefined) {
      options = {};
    }
    return dot_case_1.dotCase(input, tslib_1.__assign({ delimiter: "_" }, options));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.snakeCase = undefined;
  var tslib_1 = require_tslib12();
  var dot_case_1 = require_dist9();
  exports.snakeCase = snakeCase;
});

// ../../node_modules/change-case/dist/index.js
var require_dist15 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_1 = require_tslib2();
  tslib_1.__exportStar(require_dist4(), exports);
  tslib_1.__exportStar(require_dist6(), exports);
  tslib_1.__exportStar(require_dist8(), exports);
  tslib_1.__exportStar(require_dist9(), exports);
  tslib_1.__exportStar(require_dist10(), exports);
  tslib_1.__exportStar(require_dist2(), exports);
  tslib_1.__exportStar(require_dist11(), exports);
  tslib_1.__exportStar(require_dist3(), exports);
  tslib_1.__exportStar(require_dist12(), exports);
  tslib_1.__exportStar(require_dist13(), exports);
  tslib_1.__exportStar(require_dist14(), exports);
});

// ../../node_modules/lower-case-first/dist/index.js
var require_dist16 = __commonJS((exports) => {
  var lowerCaseFirst = function(input) {
    return input.charAt(0).toLowerCase() + input.substr(1);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.lowerCaseFirst = undefined;
  exports.lowerCaseFirst = lowerCaseFirst;
});

// ../../node_modules/sponge-case/dist/index.js
var require_dist17 = __commonJS((exports) => {
  var spongeCase = function(input) {
    var result = "";
    for (var i = 0;i < input.length; i++) {
      result += Math.random() > 0.5 ? input[i].toUpperCase() : input[i].toLowerCase();
    }
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.spongeCase = undefined;
  exports.spongeCase = spongeCase;
});

// ../../node_modules/swap-case/dist/index.js
var require_dist18 = __commonJS((exports) => {
  var swapCase = function(input) {
    var result = "";
    for (var i = 0;i < input.length; i++) {
      var lower = input[i].toLowerCase();
      result += input[i] === lower ? input[i].toUpperCase() : lower;
    }
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.swapCase = undefined;
  exports.swapCase = swapCase;
});

// ../../node_modules/title-case/dist/index.js
var require_dist19 = __commonJS((exports) => {
  var titleCase = function(input) {
    var result = "";
    var m;
    while ((m = TOKENS.exec(input)) !== null) {
      var token = m[0], index = m.index;
      if (!IS_MANUAL_CASE.test(token) && (!SMALL_WORDS.test(token) || index === 0 || index + token.length === input.length) && (input.charAt(index + token.length) !== ":" || WHITESPACE.test(input.charAt(index + token.length + 1)))) {
        result += token.replace(ALPHANUMERIC_PATTERN, function(m2) {
          return m2.toUpperCase();
        });
        continue;
      }
      result += token;
    }
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.titleCase = undefined;
  var SMALL_WORDS = /\b(?:an?d?|a[st]|because|but|by|en|for|i[fn]|neither|nor|o[fnr]|only|over|per|so|some|tha[tn]|the|to|up|upon|vs?\.?|versus|via|when|with|without|yet)\b/i;
  var TOKENS = /[^\s:\u2013\u2014-]+|./g;
  var WHITESPACE = /\s/;
  var IS_MANUAL_CASE = /.(?=[A-Z]|\..)/;
  var ALPHANUMERIC_PATTERN = /[A-Za-z0-9\u00C0-\u00FF]/;
  exports.titleCase = titleCase;
});

// ../../node_modules/is-upper-case/dist/index.js
var require_dist20 = __commonJS((exports) => {
  var isUpperCase = function(input) {
    return input.toUpperCase() === input && input.toLowerCase() !== input;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isUpperCase = undefined;
  exports.isUpperCase = isUpperCase;
});

// ../../node_modules/is-lower-case/dist/index.js
var require_dist21 = __commonJS((exports) => {
  var isLowerCase = function(input) {
    return input.toLowerCase() === input && input.toUpperCase() !== input;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLowerCase = undefined;
  exports.isLowerCase = isLowerCase;
});

// ../../node_modules/change-case-all/dist/index.js
var require_dist22 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isLowerCase = exports.isUpperCase = exports.upperCaseFirst = exports.localeUpperCase = exports.upperCase = exports.titleCase = exports.swapCase = exports.spongeCase = exports.lowerCaseFirst = exports.localeLowerCase = exports.lowerCase = exports.snakeCase = exports.sentenceCase = exports.pathCase = exports.pascalCase = exports.paramCase = exports.noCase = exports.headerCase = exports.dotCase = exports.constantCase = exports.capitalCase = exports.camelCase = undefined;
  var changeCase = require_dist15();
  var lowerCase1 = require_dist();
  var lowerCaseFirst1 = require_dist16();
  var spongeCase1 = require_dist17();
  var swapCase1 = require_dist18();
  var titleCase1 = require_dist19();
  var upperCase1 = require_dist7();
  var upperCaseFirst1 = require_dist5();
  var isUpperCase1 = require_dist20();
  var isLowerCase1 = require_dist21();
  exports.camelCase = changeCase.camelCase;
  exports.capitalCase = changeCase.capitalCase;
  exports.constantCase = changeCase.constantCase;
  exports.dotCase = changeCase.dotCase;
  exports.headerCase = changeCase.headerCase;
  exports.noCase = changeCase.noCase;
  exports.paramCase = changeCase.paramCase;
  exports.pascalCase = changeCase.pascalCase;
  exports.pathCase = changeCase.pathCase;
  exports.sentenceCase = changeCase.sentenceCase;
  exports.snakeCase = changeCase.snakeCase;
  exports.lowerCase = lowerCase1.lowerCase;
  exports.localeLowerCase = lowerCase1.localeLowerCase;
  exports.lowerCaseFirst = lowerCaseFirst1.lowerCaseFirst;
  exports.spongeCase = spongeCase1.spongeCase;
  exports.swapCase = swapCase1.swapCase;
  exports.titleCase = titleCase1.titleCase;
  exports.upperCase = upperCase1.upperCase;
  exports.localeUpperCase = upperCase1.localeUpperCase;
  exports.upperCaseFirst = upperCaseFirst1.upperCaseFirst;
  exports.isUpperCase = isUpperCase1.isUpperCase;
  exports.isLowerCase = isLowerCase1.isLowerCase;
});

// ../../node_modules/auto-bind/index.js
var require_auto_bind = __commonJS((exports, module) => {
  var getAllProperties = (object) => {
    const properties = new Set;
    do {
      for (const key of Reflect.ownKeys(object)) {
        properties.add([object, key]);
      }
    } while ((object = Reflect.getPrototypeOf(object)) && object !== Object.prototype);
    return properties;
  };
  module.exports = (self2, { include, exclude } = {}) => {
    const filter = (key) => {
      const match = (pattern) => typeof pattern === "string" ? key === pattern : pattern.test(key);
      if (include) {
        return include.some(match);
      }
      if (exclude) {
        return !exclude.some(match);
      }
      return true;
    };
    for (const [object, key] of getAllProperties(self2.constructor.prototype)) {
      if (key === "constructor" || !filter(key)) {
        continue;
      }
      const descriptor = Reflect.getOwnPropertyDescriptor(object, key);
      if (descriptor && typeof descriptor.value === "function") {
        self2[key] = self2[key].bind(self2);
      }
    }
    return self2;
  };
});

// ../../node_modules/dependency-graph/lib/dep_graph.js
var require_dep_graph = __commonJS((exports) => {
  var createDFS = function(edges, leavesOnly, result, circular) {
    var visited = {};
    return function(start) {
      if (visited[start]) {
        return;
      }
      var inCurrentPath = {};
      var currentPath = [];
      var todo = [];
      todo.push({ node: start, processed: false });
      while (todo.length > 0) {
        var current = todo[todo.length - 1];
        var processed = current.processed;
        var node = current.node;
        if (!processed) {
          if (visited[node]) {
            todo.pop();
            continue;
          } else if (inCurrentPath[node]) {
            if (circular) {
              todo.pop();
              continue;
            }
            currentPath.push(node);
            throw new DepGraphCycleError(currentPath);
          }
          inCurrentPath[node] = true;
          currentPath.push(node);
          var nodeEdges = edges[node];
          for (var i = nodeEdges.length - 1;i >= 0; i--) {
            todo.push({ node: nodeEdges[i], processed: false });
          }
          current.processed = true;
        } else {
          todo.pop();
          currentPath.pop();
          inCurrentPath[node] = false;
          visited[node] = true;
          if (!leavesOnly || edges[node].length === 0) {
            result.push(node);
          }
        }
      }
    };
  };
  var DepGraph = exports.DepGraph = function DepGraph(opts) {
    this.nodes = {};
    this.outgoingEdges = {};
    this.incomingEdges = {};
    this.circular = opts && !!opts.circular;
  };
  DepGraph.prototype = {
    size: function() {
      return Object.keys(this.nodes).length;
    },
    addNode: function(node, data) {
      if (!this.hasNode(node)) {
        if (arguments.length === 2) {
          this.nodes[node] = data;
        } else {
          this.nodes[node] = node;
        }
        this.outgoingEdges[node] = [];
        this.incomingEdges[node] = [];
      }
    },
    removeNode: function(node) {
      if (this.hasNode(node)) {
        delete this.nodes[node];
        delete this.outgoingEdges[node];
        delete this.incomingEdges[node];
        [this.incomingEdges, this.outgoingEdges].forEach(function(edgeList) {
          Object.keys(edgeList).forEach(function(key) {
            var idx = edgeList[key].indexOf(node);
            if (idx >= 0) {
              edgeList[key].splice(idx, 1);
            }
          }, this);
        });
      }
    },
    hasNode: function(node) {
      return this.nodes.hasOwnProperty(node);
    },
    getNodeData: function(node) {
      if (this.hasNode(node)) {
        return this.nodes[node];
      } else {
        throw new Error("Node does not exist: " + node);
      }
    },
    setNodeData: function(node, data) {
      if (this.hasNode(node)) {
        this.nodes[node] = data;
      } else {
        throw new Error("Node does not exist: " + node);
      }
    },
    addDependency: function(from, to) {
      if (!this.hasNode(from)) {
        throw new Error("Node does not exist: " + from);
      }
      if (!this.hasNode(to)) {
        throw new Error("Node does not exist: " + to);
      }
      if (this.outgoingEdges[from].indexOf(to) === -1) {
        this.outgoingEdges[from].push(to);
      }
      if (this.incomingEdges[to].indexOf(from) === -1) {
        this.incomingEdges[to].push(from);
      }
      return true;
    },
    removeDependency: function(from, to) {
      var idx;
      if (this.hasNode(from)) {
        idx = this.outgoingEdges[from].indexOf(to);
        if (idx >= 0) {
          this.outgoingEdges[from].splice(idx, 1);
        }
      }
      if (this.hasNode(to)) {
        idx = this.incomingEdges[to].indexOf(from);
        if (idx >= 0) {
          this.incomingEdges[to].splice(idx, 1);
        }
      }
    },
    clone: function() {
      var source2 = this;
      var result = new DepGraph;
      var keys = Object.keys(source2.nodes);
      keys.forEach(function(n) {
        result.nodes[n] = source2.nodes[n];
        result.outgoingEdges[n] = source2.outgoingEdges[n].slice(0);
        result.incomingEdges[n] = source2.incomingEdges[n].slice(0);
      });
      return result;
    },
    directDependenciesOf: function(node) {
      if (this.hasNode(node)) {
        return this.outgoingEdges[node].slice(0);
      } else {
        throw new Error("Node does not exist: " + node);
      }
    },
    directDependantsOf: function(node) {
      if (this.hasNode(node)) {
        return this.incomingEdges[node].slice(0);
      } else {
        throw new Error("Node does not exist: " + node);
      }
    },
    dependenciesOf: function(node, leavesOnly) {
      if (this.hasNode(node)) {
        var result = [];
        var DFS = createDFS(this.outgoingEdges, leavesOnly, result, this.circular);
        DFS(node);
        var idx = result.indexOf(node);
        if (idx >= 0) {
          result.splice(idx, 1);
        }
        return result;
      } else {
        throw new Error("Node does not exist: " + node);
      }
    },
    dependantsOf: function(node, leavesOnly) {
      if (this.hasNode(node)) {
        var result = [];
        var DFS = createDFS(this.incomingEdges, leavesOnly, result, this.circular);
        DFS(node);
        var idx = result.indexOf(node);
        if (idx >= 0) {
          result.splice(idx, 1);
        }
        return result;
      } else {
        throw new Error("Node does not exist: " + node);
      }
    },
    overallOrder: function(leavesOnly) {
      var self2 = this;
      var result = [];
      var keys = Object.keys(this.nodes);
      if (keys.length === 0) {
        return result;
      } else {
        if (!this.circular) {
          var CycleDFS = createDFS(this.outgoingEdges, false, [], this.circular);
          keys.forEach(function(n) {
            CycleDFS(n);
          });
        }
        var DFS = createDFS(this.outgoingEdges, leavesOnly, result, this.circular);
        keys.filter(function(node) {
          return self2.incomingEdges[node].length === 0;
        }).forEach(function(n) {
          DFS(n);
        });
        if (this.circular) {
          keys.filter(function(node) {
            return result.indexOf(node) === -1;
          }).forEach(function(n) {
            DFS(n);
          });
        }
        return result;
      }
    },
    entryNodes: function() {
      var self2 = this;
      return Object.keys(this.nodes).filter(function(node) {
        return self2.incomingEdges[node].length === 0;
      });
    }
  };
  DepGraph.prototype.directDependentsOf = DepGraph.prototype.directDependantsOf;
  DepGraph.prototype.dependentsOf = DepGraph.prototype.dependantsOf;
  var DepGraphCycleError = exports.DepGraphCycleError = function(cyclePath) {
    var message = "Dependency Cycle Found: " + cyclePath.join(" -> ");
    var instance = new Error(message);
    instance.cyclePath = cyclePath;
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    if (Error.captureStackTrace) {
      Error.captureStackTrace(instance, DepGraphCycleError);
    }
    return instance;
  };
  DepGraphCycleError.prototype = Object.create(Error.prototype, {
    constructor: {
      value: Error,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  Object.setPrototypeOf(DepGraphCycleError, Error);
});

// ../../node_modules/graphql-tag/node_modules/tslib/tslib.js
var require_tslib13 = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept2(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept2(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept2(result.get))
            descriptor.get = _;
          if (_ = accept2(result.set))
            descriptor.set = _;
          if (_ = accept2(result.init))
            initializers.unshift(_);
        } else if (_ = accept2(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error8) {
        e = { error: error8 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env2, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
          if (async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env2.stack.push({ value, dispose, async });
      } else if (async) {
        env2.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error8, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error8, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env2) {
      function fail(e) {
        env2.error = env2.hasError ? new _SuppressedError(e, env2.error, "An error was suppressed during disposal.") : e;
        env2.hasError = true;
      }
      var r, s = 0;
      function next() {
        while (r = env2.stack.pop()) {
          try {
            if (!r.async && s === 1)
              return s = 0, env2.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  fail(e);
                  return next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        }
        if (s === 1)
          return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
        if (env2.hasError)
          throw env2.error;
      }
      return next();
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
  });
});

// ../../node_modules/unc-path-regex/index.js
var require_unc_path_regex = __commonJS((exports, module) => {
  module.exports = function uncPathRegex() {
    return /^[\\\/]{2,}[^\\\/]+[\\\/]+[^\\\/]+/;
  };
});

// ../../node_modules/is-unc-path/index.js
var require_is_unc_path = __commonJS((exports, module) => {
  var regex = require_unc_path_regex()();
  module.exports = function(filepath) {
    if (typeof filepath !== "string") {
      throw new TypeError("expected a string");
    }
    return regex.test(filepath);
  };
});

// ../../node_modules/is-relative/index.js
var require_is_relative = __commonJS((exports, module) => {
  var isUncPath = require_is_unc_path();
  module.exports = function isRelative(filepath) {
    if (typeof filepath !== "string") {
      throw new TypeError("expected filepath to be a string");
    }
    return !isUncPath(filepath) && !/^([a-z]:)?[\\\/]/i.test(filepath);
  };
});

// ../../node_modules/is-windows/index.js
var require_is_windows = __commonJS((exports, module) => {
  /*!
   * is-windows <https://github.com/jonschlinkert/is-windows>
   *
   * Copyright © 2015-2018, Jon Schlinkert.
   * Released under the MIT License.
   */
  (function(factory) {
    if (exports && typeof exports === "object" && typeof module !== "undefined") {
      module.exports = factory();
    } else if (typeof define === "function" && define.amd) {
      define([], factory);
    } else if (typeof window !== "undefined") {
      window.isWindows = factory();
    } else if (typeof global !== "undefined") {
      global.isWindows = factory();
    } else if (typeof self !== "undefined") {
      self.isWindows = factory();
    } else {
      this.isWindows = factory();
    }
  })(function() {
    return function isWindows() {
      return process && (process.platform === "win32" || /^(msys|cygwin)$/.test(process.env.OSTYPE));
    };
  });
});

// ../../node_modules/is-absolute/index.js
var require_is_absolute = __commonJS((exports, module) => {
  var isAbsolute = function(fp) {
    if (typeof fp !== "string") {
      throw new TypeError("isAbsolute expects a string.");
    }
    return isWindows() ? isAbsolute.win32(fp) : isAbsolute.posix(fp);
  };
  var isRelative = require_is_relative();
  var isWindows = require_is_windows();
  module.exports = isAbsolute;
  isAbsolute.posix = function posixPath(fp) {
    return fp.charAt(0) === "/";
  };
  isAbsolute.win32 = function win32(fp) {
    if (/[a-z]/i.test(fp.charAt(0)) && fp.charAt(1) === ":" && fp.charAt(2) === "\\") {
      return true;
    }
    if (fp.slice(0, 2) === "\\\\") {
      return true;
    }
    return !isRelative(fp);
  };
});

// ../../node_modules/path-root-regex/index.js
var require_path_root_regex = __commonJS((exports, module) => {
  /*!
   * path-root-regex <https://github.com/jonschlinkert/path-root-regex>
   *
   * Copyright (c) 2016, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  module.exports = function() {
    return /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?/;
  };
});

// ../../node_modules/path-root/index.js
var require_path_root = __commonJS((exports, module) => {
  /*!
   * path-root <https://github.com/jonschlinkert/path-root>
   *
   * Copyright (c) 2016, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  var pathRootRegex = require_path_root_regex();
  module.exports = function(filepath) {
    if (typeof filepath !== "string") {
      throw new TypeError("expected a string");
    }
    var match = pathRootRegex().exec(filepath);
    if (match) {
      return match[0];
    }
  };
});

// ../../node_modules/map-cache/index.js
var require_map_cache = __commonJS((exports, module) => {
  var MapCache = function(data) {
    this.__data__ = data || {};
  };
  /*!
   * map-cache <https://github.com/jonschlinkert/map-cache>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  var hasOwn = Object.prototype.hasOwnProperty;
  module.exports = MapCache;
  MapCache.prototype.set = function mapSet(key, value) {
    if (key !== "__proto__") {
      this.__data__[key] = value;
    }
    return this;
  };
  MapCache.prototype.get = function mapGet(key) {
    return key === "__proto__" ? undefined : this.__data__[key];
  };
  MapCache.prototype.has = function mapHas(key) {
    return key !== "__proto__" && hasOwn.call(this.__data__, key);
  };
  MapCache.prototype.del = function mapDelete(key) {
    return this.has(key) && delete this.__data__[key];
  };
});

// ../../node_modules/parse-filepath/index.js
var require_parse_filepath = __commonJS((exports, module) => {
  var define2 = function(obj, prop, fn) {
    var cached;
    Object.defineProperty(obj, prop, {
      configurable: true,
      enumerable: true,
      set: function(val) {
        cached = val;
      },
      get: function() {
        return cached || (cached = fn.call(obj));
      }
    });
  };
  var path = import.meta.require("path");
  var isAbsolute = require_is_absolute();
  var pathRoot = require_path_root();
  var MapCache = require_map_cache();
  var cache = new MapCache;
  module.exports = function(filepath) {
    if (typeof filepath !== "string") {
      throw new TypeError("parse-filepath expects a string");
    }
    if (cache.has(filepath)) {
      return cache.get(filepath);
    }
    var obj = {};
    if (typeof path.parse === "function") {
      obj = path.parse(filepath);
      obj.extname = obj.ext;
      obj.basename = obj.base;
      obj.dirname = obj.dir;
      obj.stem = obj.name;
    } else {
      define2(obj, "root", function() {
        return pathRoot(this.path);
      });
      define2(obj, "extname", function() {
        return path.extname(filepath);
      });
      define2(obj, "ext", function() {
        return this.extname;
      });
      define2(obj, "name", function() {
        return path.basename(filepath, this.ext);
      });
      define2(obj, "stem", function() {
        return this.name;
      });
      define2(obj, "base", function() {
        return this.name + this.ext;
      });
      define2(obj, "basename", function() {
        return this.base;
      });
      define2(obj, "dir", function() {
        var dir = path.dirname(filepath);
        if (dir === ".") {
          return filepath[0] === "." ? dir : "";
        } else {
          return dir;
        }
      });
      define2(obj, "dirname", function() {
        return this.dir;
      });
    }
    obj.path = filepath;
    define2(obj, "absolute", function() {
      return path.resolve(this.path);
    });
    define2(obj, "isAbsolute", function() {
      return isAbsolute(this.path);
    });
    cache.set(filepath, obj);
    return obj;
  };
});

// ../../node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS((exports, module) => {
  (function(t, e) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = e() : typeof define == "function" && define.amd ? define(e) : (t = typeof globalThis != "undefined" ? globalThis : t || self).dayjs = e();
  })(exports, function() {
    var t = 1000, e = 60000, n = 3600000, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
      var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
      return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
    } }, m = function(t2, e2, n2) {
      var r2 = String(t2);
      return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
    }, v = { s: m, z: function(t2) {
      var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
      return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
    }, m: function t(e2, n2) {
      if (e2.date() < n2.date())
        return -t(n2, e2);
      var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
      return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
    }, a: function(t2) {
      return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
    }, p: function(t2) {
      return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t2) {
      return t2 === undefined;
    } }, g = "en", D = {};
    D[g] = M;
    var p = "$isDayjsObject", S = function(t2) {
      return t2 instanceof _ || !(!t2 || !t2[p]);
    }, w = function t(e2, n2, r2) {
      var i2;
      if (!e2)
        return g;
      if (typeof e2 == "string") {
        var s2 = e2.toLowerCase();
        D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
        var u2 = e2.split("-");
        if (!i2 && u2.length > 1)
          return t(u2[0]);
      } else {
        var a2 = e2.name;
        D[a2] = e2, i2 = a2;
      }
      return !r2 && i2 && (g = i2), i2 || !r2 && g;
    }, O = function(t2, e2) {
      if (S(t2))
        return t2.clone();
      var n2 = typeof e2 == "object" ? e2 : {};
      return n2.date = t2, n2.args = arguments, new _(n2);
    }, b = v;
    b.l = w, b.i = S, b.w = function(t2, e2) {
      return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
    };
    var _ = function() {
      function M2(t2) {
        this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
      }
      var m2 = M2.prototype;
      return m2.parse = function(t2) {
        this.$d = function(t3) {
          var { date: e2, utc: n2 } = t3;
          if (e2 === null)
            return new Date(NaN);
          if (b.u(e2))
            return new Date;
          if (e2 instanceof Date)
            return new Date(e2);
          if (typeof e2 == "string" && !/Z$/i.test(e2)) {
            var r2 = e2.match($);
            if (r2) {
              var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
            }
          }
          return new Date(e2);
        }(t2), this.init();
      }, m2.init = function() {
        var t2 = this.$d;
        this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
      }, m2.$utils = function() {
        return b;
      }, m2.isValid = function() {
        return !(this.$d.toString() === l);
      }, m2.isSame = function(t2, e2) {
        var n2 = O(t2);
        return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
      }, m2.isAfter = function(t2, e2) {
        return O(t2) < this.startOf(e2);
      }, m2.isBefore = function(t2, e2) {
        return this.endOf(e2) < O(t2);
      }, m2.$g = function(t2, e2, n2) {
        return b.u(t2) ? this[e2] : this.set(n2, t2);
      }, m2.unix = function() {
        return Math.floor(this.valueOf() / 1000);
      }, m2.valueOf = function() {
        return this.$d.getTime();
      }, m2.startOf = function(t2, e2) {
        var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = function(t3, e3) {
          var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
          return r2 ? i2 : i2.endOf(a);
        }, $2 = function(t3, e3) {
          return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
        }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
        switch (f2) {
          case h:
            return r2 ? l2(1, 0) : l2(31, 11);
          case c:
            return r2 ? l2(1, M3) : l2(0, M3 + 1);
          case o:
            var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
            return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
          case a:
          case d:
            return $2(v2 + "Hours", 0);
          case u:
            return $2(v2 + "Minutes", 1);
          case s:
            return $2(v2 + "Seconds", 2);
          case i:
            return $2(v2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m2.endOf = function(t2) {
        return this.startOf(t2, false);
      }, m2.$set = function(t2, e2) {
        var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
        if (o2 === c || o2 === h) {
          var y2 = this.clone().set(d, 1);
          y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
        } else
          l2 && this.$d[l2]($2);
        return this.init(), this;
      }, m2.set = function(t2, e2) {
        return this.clone().$set(t2, e2);
      }, m2.get = function(t2) {
        return this[b.p(t2)]();
      }, m2.add = function(r2, f2) {
        var d2, l2 = this;
        r2 = Number(r2);
        var $2 = b.p(f2), y2 = function(t2) {
          var e2 = O(l2);
          return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
        };
        if ($2 === c)
          return this.set(c, this.$M + r2);
        if ($2 === h)
          return this.set(h, this.$y + r2);
        if ($2 === a)
          return y2(1);
        if ($2 === o)
          return y2(7);
        var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
        return b.w(m3, this);
      }, m2.subtract = function(t2, e2) {
        return this.add(-1 * t2, e2);
      }, m2.format = function(t2) {
        var e2 = this, n2 = this.$locale();
        if (!this.isValid())
          return n2.invalidDate || l;
        var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
          return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
        }, d2 = function(t3) {
          return b.s(s2 % 12 || 12, t3, "0");
        }, $2 = f2 || function(t3, e3, n3) {
          var r3 = t3 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        };
        return r2.replace(y, function(t3, r3) {
          return r3 || function(t4) {
            switch (t4) {
              case "YY":
                return String(e2.$y).slice(-2);
              case "YYYY":
                return b.s(e2.$y, 4, "0");
              case "M":
                return a2 + 1;
              case "MM":
                return b.s(a2 + 1, 2, "0");
              case "MMM":
                return h2(n2.monthsShort, a2, c2, 3);
              case "MMMM":
                return h2(c2, a2);
              case "D":
                return e2.$D;
              case "DD":
                return b.s(e2.$D, 2, "0");
              case "d":
                return String(e2.$W);
              case "dd":
                return h2(n2.weekdaysMin, e2.$W, o2, 2);
              case "ddd":
                return h2(n2.weekdaysShort, e2.$W, o2, 3);
              case "dddd":
                return o2[e2.$W];
              case "H":
                return String(s2);
              case "HH":
                return b.s(s2, 2, "0");
              case "h":
                return d2(1);
              case "hh":
                return d2(2);
              case "a":
                return $2(s2, u2, true);
              case "A":
                return $2(s2, u2, false);
              case "m":
                return String(u2);
              case "mm":
                return b.s(u2, 2, "0");
              case "s":
                return String(e2.$s);
              case "ss":
                return b.s(e2.$s, 2, "0");
              case "SSS":
                return b.s(e2.$ms, 3, "0");
              case "Z":
                return i2;
            }
            return null;
          }(t3) || i2.replace(":", "");
        });
      }, m2.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m2.diff = function(r2, d2, l2) {
        var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
          return b.m(y2, m3);
        };
        switch (M3) {
          case h:
            $2 = D2() / 12;
            break;
          case c:
            $2 = D2();
            break;
          case f:
            $2 = D2() / 3;
            break;
          case o:
            $2 = (g2 - v2) / 604800000;
            break;
          case a:
            $2 = (g2 - v2) / 86400000;
            break;
          case u:
            $2 = g2 / n;
            break;
          case s:
            $2 = g2 / e;
            break;
          case i:
            $2 = g2 / t;
            break;
          default:
            $2 = g2;
        }
        return l2 ? $2 : b.a($2);
      }, m2.daysInMonth = function() {
        return this.endOf(c).$D;
      }, m2.$locale = function() {
        return D[this.$L];
      }, m2.locale = function(t2, e2) {
        if (!t2)
          return this.$L;
        var n2 = this.clone(), r2 = w(t2, e2, true);
        return r2 && (n2.$L = r2), n2;
      }, m2.clone = function() {
        return b.w(this.$d, this);
      }, m2.toDate = function() {
        return new Date(this.valueOf());
      }, m2.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m2.toISOString = function() {
        return this.$d.toISOString();
      }, m2.toString = function() {
        return this.$d.toUTCString();
      }, M2;
    }(), k = _.prototype;
    return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach(function(t2) {
      k[t2[1]] = function(e2) {
        return this.$g(e2, t2[0], t2[1]);
      };
    }), O.extend = function(t2, e2) {
      return t2.$i || (t2(e2, _, O), t2.$i = true), O;
    }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
      return O(1000 * t2);
    }, O.en = D[g], O.Ls = D, O.p = {}, O;
  });
});

// ../../node_modules/dayjs/plugin/customParseFormat.js
var require_customParseFormat = __commonJS((exports, module) => {
  (function(e, t) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = t() : typeof define == "function" && define.amd ? define(t) : (e = typeof globalThis != "undefined" ? globalThis : e || self).dayjs_plugin_customParseFormat = t();
  })(exports, function() {
    var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d/, r = /\d\d/, i = /\d\d?/, o = /\d*[^-_:/,()\s\d]+/, s = {}, a = function(e2) {
      return (e2 = +e2) + (e2 > 68 ? 1900 : 2000);
    };
    var f = function(e2) {
      return function(t2) {
        this[e2] = +t2;
      };
    }, h = [/[+-]\d\d:?(\d\d)?|Z/, function(e2) {
      (this.zone || (this.zone = {})).offset = function(e3) {
        if (!e3)
          return 0;
        if (e3 === "Z")
          return 0;
        var t2 = e3.match(/([+-]|\d\d)/g), n2 = 60 * t2[1] + (+t2[2] || 0);
        return n2 === 0 ? 0 : t2[0] === "+" ? -n2 : n2;
      }(e2);
    }], u = function(e2) {
      var t2 = s[e2];
      return t2 && (t2.indexOf ? t2 : t2.s.concat(t2.f));
    }, d = function(e2, t2) {
      var n2, r2 = s.meridiem;
      if (r2) {
        for (var i2 = 1;i2 <= 24; i2 += 1)
          if (e2.indexOf(r2(i2, 0, t2)) > -1) {
            n2 = i2 > 12;
            break;
          }
      } else
        n2 = e2 === (t2 ? "pm" : "PM");
      return n2;
    }, c = { A: [o, function(e2) {
      this.afternoon = d(e2, false);
    }], a: [o, function(e2) {
      this.afternoon = d(e2, true);
    }], Q: [n, function(e2) {
      this.month = 3 * (e2 - 1) + 1;
    }], S: [n, function(e2) {
      this.milliseconds = 100 * +e2;
    }], SS: [r, function(e2) {
      this.milliseconds = 10 * +e2;
    }], SSS: [/\d{3}/, function(e2) {
      this.milliseconds = +e2;
    }], s: [i, f("seconds")], ss: [i, f("seconds")], m: [i, f("minutes")], mm: [i, f("minutes")], H: [i, f("hours")], h: [i, f("hours")], HH: [i, f("hours")], hh: [i, f("hours")], D: [i, f("day")], DD: [r, f("day")], Do: [o, function(e2) {
      var t2 = s.ordinal, n2 = e2.match(/\d+/);
      if (this.day = n2[0], t2)
        for (var r2 = 1;r2 <= 31; r2 += 1)
          t2(r2).replace(/\[|\]/g, "") === e2 && (this.day = r2);
    }], w: [i, f("week")], ww: [r, f("week")], M: [i, f("month")], MM: [r, f("month")], MMM: [o, function(e2) {
      var t2 = u("months"), n2 = (u("monthsShort") || t2.map(function(e3) {
        return e3.slice(0, 3);
      })).indexOf(e2) + 1;
      if (n2 < 1)
        throw new Error;
      this.month = n2 % 12 || n2;
    }], MMMM: [o, function(e2) {
      var t2 = u("months").indexOf(e2) + 1;
      if (t2 < 1)
        throw new Error;
      this.month = t2 % 12 || t2;
    }], Y: [/[+-]?\d+/, f("year")], YY: [r, function(e2) {
      this.year = a(e2);
    }], YYYY: [/\d{4}/, f("year")], Z: h, ZZ: h };
    function l(n2) {
      var r2, i2;
      r2 = n2, i2 = s && s.formats;
      for (var o2 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t2, n3, r3) {
        var o3 = r3 && r3.toUpperCase();
        return n3 || i2[r3] || e[r3] || i2[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t3, n4) {
          return t3 || n4.slice(1);
        });
      })).match(t), a2 = o2.length, f2 = 0;f2 < a2; f2 += 1) {
        var h2 = o2[f2], u2 = c[h2], d2 = u2 && u2[0], l2 = u2 && u2[1];
        o2[f2] = l2 ? { regex: d2, parser: l2 } : h2.replace(/^\[|\]$/g, "");
      }
      return function(e2) {
        for (var t2 = {}, n3 = 0, r3 = 0;n3 < a2; n3 += 1) {
          var i3 = o2[n3];
          if (typeof i3 == "string")
            r3 += i3.length;
          else {
            var { regex: s2, parser: f3 } = i3, h3 = e2.slice(r3), u3 = s2.exec(h3)[0];
            f3.call(t2, u3), e2 = e2.replace(u3, "");
          }
        }
        return function(e3) {
          var t3 = e3.afternoon;
          if (t3 !== undefined) {
            var n4 = e3.hours;
            t3 ? n4 < 12 && (e3.hours += 12) : n4 === 12 && (e3.hours = 0), delete e3.afternoon;
          }
        }(t2), t2;
      };
    }
    return function(e2, t2, n2) {
      n2.p.customParseFormat = true, e2 && e2.parseTwoDigitYear && (a = e2.parseTwoDigitYear);
      var r2 = t2.prototype, i2 = r2.parse;
      r2.parse = function(e3) {
        var { date: t3, utc: r3, args: o2 } = e3;
        this.$u = r3;
        var a2 = o2[1];
        if (typeof a2 == "string") {
          var f2 = o2[2] === true, h2 = o2[3] === true, u2 = f2 || h2, d2 = o2[2];
          h2 && (d2 = o2[2]), s = this.$locale(), !f2 && d2 && (s = n2.Ls[d2]), this.$d = function(e4, t4, n3, r4) {
            try {
              if (["x", "X"].indexOf(t4) > -1)
                return new Date((t4 === "X" ? 1000 : 1) * e4);
              var i3 = l(t4)(e4), o3 = i3.year, s2 = i3.month, a3 = i3.day, f3 = i3.hours, h3 = i3.minutes, u3 = i3.seconds, d3 = i3.milliseconds, c3 = i3.zone, m2 = i3.week, M2 = new Date, Y = a3 || (o3 || s2 ? 1 : M2.getDate()), p = o3 || M2.getFullYear(), v = 0;
              o3 && !s2 || (v = s2 > 0 ? s2 - 1 : M2.getMonth());
              var D, w = f3 || 0, g = h3 || 0, y = u3 || 0, L = d3 || 0;
              return c3 ? new Date(Date.UTC(p, v, Y, w, g, y, L + 60 * c3.offset * 1000)) : n3 ? new Date(Date.UTC(p, v, Y, w, g, y, L)) : (D = new Date(p, v, Y, w, g, y, L), m2 && (D = r4(D).week(m2).toDate()), D);
            } catch (e5) {
              return new Date("");
            }
          }(t3, a2, r3, n2), this.init(), d2 && d2 !== true && (this.$L = this.locale(d2).$L), u2 && t3 != this.format(a2) && (this.$d = new Date("")), s = {};
        } else if (a2 instanceof Array)
          for (var c2 = a2.length, m = 1;m <= c2; m += 1) {
            o2[1] = a2[m - 1];
            var M = n2.apply(this, o2);
            if (M.isValid()) {
              this.$d = M.$d, this.$L = M.$L, this.init();
              break;
            }
            m === c2 && (this.$d = new Date(""));
          }
        else
          i2.call(this, e3);
      };
    };
  });
});

// ../../node_modules/dayjs/plugin/utc.js
var require_utc = __commonJS((exports, module) => {
  (function(t, i) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = i() : typeof define == "function" && define.amd ? define(i) : (t = typeof globalThis != "undefined" ? globalThis : t || self).dayjs_plugin_utc = i();
  })(exports, function() {
    var t = "minute", i = /[+-]\d\d(?::?\d\d)?/g, e = /([+-]|\d\d)/g;
    return function(s, f, n) {
      var u = f.prototype;
      n.utc = function(t2) {
        var i2 = { date: t2, utc: true, args: arguments };
        return new f(i2);
      }, u.utc = function(i2) {
        var e2 = n(this.toDate(), { locale: this.$L, utc: true });
        return i2 ? e2.add(this.utcOffset(), t) : e2;
      }, u.local = function() {
        return n(this.toDate(), { locale: this.$L, utc: false });
      };
      var o = u.parse;
      u.parse = function(t2) {
        t2.utc && (this.$u = true), this.$utils().u(t2.$offset) || (this.$offset = t2.$offset), o.call(this, t2);
      };
      var r = u.init;
      u.init = function() {
        if (this.$u) {
          var t2 = this.$d;
          this.$y = t2.getUTCFullYear(), this.$M = t2.getUTCMonth(), this.$D = t2.getUTCDate(), this.$W = t2.getUTCDay(), this.$H = t2.getUTCHours(), this.$m = t2.getUTCMinutes(), this.$s = t2.getUTCSeconds(), this.$ms = t2.getUTCMilliseconds();
        } else
          r.call(this);
      };
      var a = u.utcOffset;
      u.utcOffset = function(s2, f2) {
        var n2 = this.$utils().u;
        if (n2(s2))
          return this.$u ? 0 : n2(this.$offset) ? a.call(this) : this.$offset;
        if (typeof s2 == "string" && (s2 = function(t2) {
          t2 === undefined && (t2 = "");
          var s3 = t2.match(i);
          if (!s3)
            return null;
          var f3 = ("" + s3[0]).match(e) || ["-", 0, 0], n3 = f3[0], u3 = 60 * +f3[1] + +f3[2];
          return u3 === 0 ? 0 : n3 === "+" ? u3 : -u3;
        }(s2), s2 === null))
          return this;
        var u2 = Math.abs(s2) <= 16 ? 60 * s2 : s2, o2 = this;
        if (f2)
          return o2.$offset = u2, o2.$u = s2 === 0, o2;
        if (s2 !== 0) {
          var r2 = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
          (o2 = this.local().add(u2 + r2, t)).$offset = u2, o2.$x.$localOffset = r2;
        } else
          o2 = this.utc();
        return o2;
      };
      var h = u.format;
      u.format = function(t2) {
        var i2 = t2 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
        return h.call(this, i2);
      }, u.valueOf = function() {
        var t2 = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
        return this.$d.valueOf() - 60000 * t2;
      }, u.isUTC = function() {
        return !!this.$u;
      }, u.toISOString = function() {
        return this.toDate().toISOString();
      }, u.toString = function() {
        return this.toDate().toUTCString();
      };
      var l = u.toDate;
      u.toDate = function(t2) {
        return t2 === "s" && this.$offset ? n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l.call(this);
      };
      var c = u.diff;
      u.diff = function(t2, i2, e2) {
        if (t2 && this.$u === t2.$u)
          return c.call(this, t2, i2, e2);
        var s2 = this.local(), f2 = n(t2).local();
        return c.call(s2, f2, i2, e2);
      };
    };
  });
});

// ../../node_modules/dayjs/plugin/timezone.js
var require_timezone = __commonJS((exports, module) => {
  (function(t, e) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = e() : typeof define == "function" && define.amd ? define(e) : (t = typeof globalThis != "undefined" ? globalThis : t || self).dayjs_plugin_timezone = e();
  })(exports, function() {
    var t = { year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5 }, e = {};
    return function(n, i, o) {
      var r, a = function(t2, n2, i2) {
        i2 === undefined && (i2 = {});
        var o2 = new Date(t2), r2 = function(t3, n3) {
          n3 === undefined && (n3 = {});
          var i3 = n3.timeZoneName || "short", o3 = t3 + "|" + i3, r3 = e[o3];
          return r3 || (r3 = new Intl.DateTimeFormat("en-US", { hour12: false, timeZone: t3, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", timeZoneName: i3 }), e[o3] = r3), r3;
        }(n2, i2);
        return r2.formatToParts(o2);
      }, u = function(e2, n2) {
        for (var i2 = a(e2, n2), r2 = [], u2 = 0;u2 < i2.length; u2 += 1) {
          var f2 = i2[u2], s2 = f2.type, m = f2.value, c = t[s2];
          c >= 0 && (r2[c] = parseInt(m, 10));
        }
        var d = r2[3], l = d === 24 ? 0 : d, h = r2[0] + "-" + r2[1] + "-" + r2[2] + " " + l + ":" + r2[4] + ":" + r2[5] + ":000", v = +e2;
        return (o.utc(h).valueOf() - (v -= v % 1000)) / 60000;
      }, f = i.prototype;
      f.tz = function(t2, e2) {
        t2 === undefined && (t2 = r);
        var n2, i2 = this.utcOffset(), a2 = this.toDate(), u2 = a2.toLocaleString("en-US", { timeZone: t2 }), f2 = Math.round((a2 - new Date(u2)) / 1000 / 60), s2 = 15 * -Math.round(a2.getTimezoneOffset() / 15) - f2;
        if (!Number(s2))
          n2 = this.utcOffset(0, e2);
        else if (n2 = o(u2, { locale: this.$L }).$set("millisecond", this.$ms).utcOffset(s2, true), e2) {
          var m = n2.utcOffset();
          n2 = n2.add(i2 - m, "minute");
        }
        return n2.$x.$timezone = t2, n2;
      }, f.offsetName = function(t2) {
        var e2 = this.$x.$timezone || o.tz.guess(), n2 = a(this.valueOf(), e2, { timeZoneName: t2 }).find(function(t3) {
          return t3.type.toLowerCase() === "timezonename";
        });
        return n2 && n2.value;
      };
      var s = f.startOf;
      f.startOf = function(t2, e2) {
        if (!this.$x || !this.$x.$timezone)
          return s.call(this, t2, e2);
        var n2 = o(this.format("YYYY-MM-DD HH:mm:ss:SSS"), { locale: this.$L });
        return s.call(n2, t2, e2).tz(this.$x.$timezone, true);
      }, o.tz = function(t2, e2, n2) {
        var i2 = n2 && e2, a2 = n2 || e2 || r, f2 = u(+o(), a2);
        if (typeof t2 != "string")
          return o(t2).tz(a2);
        var s2 = function(t3, e3, n3) {
          var i3 = t3 - 60 * e3 * 1000, o2 = u(i3, n3);
          if (e3 === o2)
            return [i3, e3];
          var r2 = u(i3 -= 60 * (o2 - e3) * 1000, n3);
          return o2 === r2 ? [i3, o2] : [t3 - 60 * Math.min(o2, r2) * 1000, Math.max(o2, r2)];
        }(o.utc(t2, i2).valueOf(), f2, a2), m = s2[0], c = s2[1], d = o(m).utcOffset(c);
        return d.$x.$timezone = a2, d;
      }, o.tz.guess = function() {
        return Intl.DateTimeFormat().resolvedOptions().timeZone;
      }, o.tz.setDefault = function(t2) {
        r = t2;
      };
    };
  });
});

// ../../node_modules/elysia/dist/bun/index.js
var eW = Object.create;
var { defineProperty: S6, getPrototypeOf: $X, getOwnPropertyNames: YX } = Object;
var WX = Object.prototype.hasOwnProperty;
var Q1 = ($, Y, W) => {
  W = $ != null ? eW($X($)) : {};
  const X = Y || !$ || !$.__esModule ? S6(W, "default", { value: $, enumerable: true }) : W;
  for (let Z of YX($))
    if (!WX.call(X, Z))
      S6(X, Z, { get: () => $[Z], enumerable: true });
  return X;
};
var J0 = ($, Y) => () => (Y || $((Y = { exports: {} }).exports, Y), Y.exports);
var b6 = J0((O7, a$) => {
  var s1 = function() {
  }, QX = function($, Y, W) {
    this.fn = $, this.context = Y, this.once = W || false;
  }, I6 = function($, Y, W, X, Z) {
    if (typeof W !== "function")
      throw new TypeError("The listener must be a function");
    var Q = new QX(W, X || $, Z), J = V0 ? V0 + Y : Y;
    if (!$._events[J])
      $._events[J] = Q, $._eventsCount++;
    else if (!$._events[J].fn)
      $._events[J].push(Q);
    else
      $._events[J] = [$._events[J], Q];
    return $;
  }, K$ = function($, Y) {
    if (--$._eventsCount === 0)
      $._events = new s1;
    else
      delete $._events[Y];
  }, G0 = function() {
    this._events = new s1, this._eventsCount = 0;
  }, ZX = Object.prototype.hasOwnProperty, V0 = "~";
  if (Object.create) {
    if (s1.prototype = Object.create(null), !new s1().__proto__)
      V0 = false;
  }
  G0.prototype.eventNames = function $() {
    var Y = [], W, X;
    if (this._eventsCount === 0)
      return Y;
    for (X in W = this._events)
      if (ZX.call(W, X))
        Y.push(V0 ? X.slice(1) : X);
    if (Object.getOwnPropertySymbols)
      return Y.concat(Object.getOwnPropertySymbols(W));
    return Y;
  };
  G0.prototype.listeners = function $(Y) {
    var W = V0 ? V0 + Y : Y, X = this._events[W];
    if (!X)
      return [];
    if (X.fn)
      return [X.fn];
    for (var Z = 0, Q = X.length, J = new Array(Q);Z < Q; Z++)
      J[Z] = X[Z].fn;
    return J;
  };
  G0.prototype.listenerCount = function $(Y) {
    var W = V0 ? V0 + Y : Y, X = this._events[W];
    if (!X)
      return 0;
    if (X.fn)
      return 1;
    return X.length;
  };
  G0.prototype.emit = function $(Y, W, X, Z, Q, J) {
    var z = V0 ? V0 + Y : Y;
    if (!this._events[z])
      return false;
    var U = this._events[z], D = arguments.length, B, j;
    if (U.fn) {
      if (U.once)
        this.removeListener(Y, U.fn, undefined, true);
      switch (D) {
        case 1:
          return U.fn.call(U.context), true;
        case 2:
          return U.fn.call(U.context, W), true;
        case 3:
          return U.fn.call(U.context, W, X), true;
        case 4:
          return U.fn.call(U.context, W, X, Z), true;
        case 5:
          return U.fn.call(U.context, W, X, Z, Q), true;
        case 6:
          return U.fn.call(U.context, W, X, Z, Q, J), true;
      }
      for (j = 1, B = new Array(D - 1);j < D; j++)
        B[j - 1] = arguments[j];
      U.fn.apply(U.context, B);
    } else {
      var b = U.length, S;
      for (j = 0;j < b; j++) {
        if (U[j].once)
          this.removeListener(Y, U[j].fn, undefined, true);
        switch (D) {
          case 1:
            U[j].fn.call(U[j].context);
            break;
          case 2:
            U[j].fn.call(U[j].context, W);
            break;
          case 3:
            U[j].fn.call(U[j].context, W, X);
            break;
          case 4:
            U[j].fn.call(U[j].context, W, X, Z);
            break;
          default:
            if (!B)
              for (S = 1, B = new Array(D - 1);S < D; S++)
                B[S - 1] = arguments[S];
            U[j].fn.apply(U[j].context, B);
        }
      }
    }
    return true;
  };
  G0.prototype.on = function $(Y, W, X) {
    return I6(this, Y, W, X, false);
  };
  G0.prototype.once = function $(Y, W, X) {
    return I6(this, Y, W, X, true);
  };
  G0.prototype.removeListener = function $(Y, W, X, Z) {
    var Q = V0 ? V0 + Y : Y;
    if (!this._events[Q])
      return this;
    if (!W)
      return K$(this, Q), this;
    var J = this._events[Q];
    if (J.fn) {
      if (J.fn === W && (!Z || J.once) && (!X || J.context === X))
        K$(this, Q);
    } else {
      for (var z = 0, U = [], D = J.length;z < D; z++)
        if (J[z].fn !== W || Z && !J[z].once || X && J[z].context !== X)
          U.push(J[z]);
      if (U.length)
        this._events[Q] = U.length === 1 ? U[0] : U;
      else
        K$(this, Q);
    }
    return this;
  };
  G0.prototype.removeAllListeners = function $(Y) {
    var W;
    if (Y) {
      if (W = V0 ? V0 + Y : Y, this._events[W])
        K$(this, W);
    } else
      this._events = new s1, this._eventsCount = 0;
    return this;
  };
  G0.prototype.off = G0.prototype.removeListener;
  G0.prototype.addListener = G0.prototype.on;
  G0.prefixed = V0;
  G0.EventEmitter = G0;
  if (typeof a$ !== "undefined")
    a$.exports = G0;
});
var x0 = J0((d6) => {
  var JX = function($) {
    return j$($) && Symbol.asyncIterator in $;
  }, zX = function($) {
    return j$($) && Symbol.iterator in $;
  }, HX = function($) {
    return ArrayBuffer.isView($);
  }, qX = function($) {
    return $ instanceof Promise;
  }, MX = function($) {
    return $ instanceof Uint8Array;
  }, NX = function($) {
    return $ instanceof Date && Number.isFinite($.getTime());
  }, FX = function($, Y) {
    return Y in $;
  }, UX = function($) {
    return j$($) && f6($.constructor) && $.constructor.name === "Object";
  }, j$ = function($) {
    return $ !== null && typeof $ === "object";
  }, AX = function($) {
    return Array.isArray($) && !ArrayBuffer.isView($);
  }, E6 = function($) {
    return $ === undefined;
  }, V6 = function($) {
    return $ === null;
  }, x6 = function($) {
    return typeof $ === "boolean";
  }, e$ = function($) {
    return typeof $ === "number";
  }, BX = function($) {
    return e$($) && Number.isInteger($);
  }, k6 = function($) {
    return typeof $ === "bigint";
  }, g6 = function($) {
    return typeof $ === "string";
  }, f6 = function($) {
    return typeof $ === "function";
  }, T6 = function($) {
    return typeof $ === "symbol";
  }, DX = function($) {
    return k6($) || x6($) || V6($) || e$($) || g6($) || T6($) || E6($);
  };
  Object.defineProperty(d6, "__esModule", { value: true });
  d6.IsValueType = d6.IsSymbol = d6.IsFunction = d6.IsString = d6.IsBigInt = d6.IsInteger = d6.IsNumber = d6.IsBoolean = d6.IsNull = d6.IsUndefined = d6.IsArray = d6.IsObject = d6.IsPlainObject = d6.HasPropertyKey = d6.IsDate = d6.IsUint8Array = d6.IsPromise = d6.IsTypedArray = d6.IsIterator = d6.IsAsyncIterator = undefined;
  d6.IsAsyncIterator = JX;
  d6.IsIterator = zX;
  d6.IsTypedArray = HX;
  d6.IsPromise = qX;
  d6.IsUint8Array = MX;
  d6.IsDate = NX;
  d6.HasPropertyKey = FX;
  d6.IsPlainObject = UX;
  d6.IsObject = j$;
  d6.IsArray = AX;
  d6.IsUndefined = E6;
  d6.IsNull = V6;
  d6.IsBoolean = x6;
  d6.IsNumber = e$;
  d6.IsInteger = BX;
  d6.IsBigInt = k6;
  d6.IsString = g6;
  d6.IsFunction = f6;
  d6.IsSymbol = T6;
  d6.IsValueType = DX;
});
var f0 = J0((m6) => {
  Object.defineProperty(m6, "__esModule", { value: true });
  m6.Type = m6.JsonType = m6.JavaScriptTypeBuilder = m6.JsonTypeBuilder = m6.TypeBuilder = m6.TypeBuilderError = m6.TransformEncodeBuilder = m6.TransformDecodeBuilder = m6.TemplateLiteralDslParser = m6.TemplateLiteralGenerator = m6.TemplateLiteralGeneratorError = m6.TemplateLiteralFinite = m6.TemplateLiteralFiniteError = m6.TemplateLiteralParser = m6.TemplateLiteralParserError = m6.TemplateLiteralResolver = m6.TemplateLiteralPattern = m6.TemplateLiteralPatternError = m6.UnionResolver = m6.KeyArrayResolver = m6.KeyArrayResolverError = m6.KeyResolver = m6.ObjectMap = m6.Intrinsic = m6.IndexedAccessor = m6.TypeClone = m6.TypeExtends = m6.TypeExtendsResult = m6.TypeExtendsError = m6.ExtendsUndefined = m6.TypeGuard = m6.TypeGuardUnknownTypeError = m6.ValueGuard = m6.FormatRegistry = m6.TypeBoxError = m6.TypeRegistry = m6.PatternStringExact = m6.PatternNumberExact = m6.PatternBooleanExact = m6.PatternString = m6.PatternNumber = m6.PatternBoolean = m6.Kind = m6.Hint = m6.Optional = m6.Readonly = m6.Transform = undefined;
  m6.Transform = Symbol.for("TypeBox.Transform");
  m6.Readonly = Symbol.for("TypeBox.Readonly");
  m6.Optional = Symbol.for("TypeBox.Optional");
  m6.Hint = Symbol.for("TypeBox.Hint");
  m6.Kind = Symbol.for("TypeBox.Kind");
  m6.PatternBoolean = "(true|false)";
  m6.PatternNumber = "(0|[1-9][0-9]*)";
  m6.PatternString = "(.*)";
  m6.PatternBooleanExact = `^${m6.PatternBoolean}$`;
  m6.PatternNumberExact = `^${m6.PatternNumber}$`;
  m6.PatternStringExact = `^${m6.PatternString}$`;
  var $8;
  (function($) {
    const Y = new Map;
    function W() {
      return new Map(Y);
    }
    $.Entries = W;
    function X() {
      return Y.clear();
    }
    $.Clear = X;
    function Z(U) {
      return Y.delete(U);
    }
    $.Delete = Z;
    function Q(U) {
      return Y.has(U);
    }
    $.Has = Q;
    function J(U, D) {
      Y.set(U, D);
    }
    $.Set = J;
    function z(U) {
      return Y.get(U);
    }
    $.Get = z;
  })($8 || (m6.TypeRegistry = $8 = {}));

  class $1 extends Error {
    constructor($) {
      super($);
    }
  }
  m6.TypeBoxError = $1;
  var v6;
  (function($) {
    const Y = new Map;
    function W() {
      return new Map(Y);
    }
    $.Entries = W;
    function X() {
      return Y.clear();
    }
    $.Clear = X;
    function Z(U) {
      return Y.delete(U);
    }
    $.Delete = Z;
    function Q(U) {
      return Y.has(U);
    }
    $.Has = Q;
    function J(U, D) {
      Y.set(U, D);
    }
    $.Set = J;
    function z(U) {
      return Y.get(U);
    }
    $.Get = z;
  })(v6 || (m6.FormatRegistry = v6 = {}));
  var V;
  (function($) {
    function Y(D) {
      return Array.isArray(D);
    }
    $.IsArray = Y;
    function W(D) {
      return typeof D === "bigint";
    }
    $.IsBigInt = W;
    function X(D) {
      return typeof D === "boolean";
    }
    $.IsBoolean = X;
    function Z(D) {
      return D === null;
    }
    $.IsNull = Z;
    function Q(D) {
      return typeof D === "number";
    }
    $.IsNumber = Q;
    function J(D) {
      return typeof D === "object" && D !== null;
    }
    $.IsObject = J;
    function z(D) {
      return typeof D === "string";
    }
    $.IsString = z;
    function U(D) {
      return D === undefined;
    }
    $.IsUndefined = U;
  })(V || (m6.ValueGuard = V = {}));

  class i6 extends $1 {
  }
  m6.TypeGuardUnknownTypeError = i6;
  var A;
  (function($) {
    function Y(M) {
      try {
        return new RegExp(M), true;
      } catch {
        return false;
      }
    }
    function W(M) {
      if (!V.IsString(M))
        return false;
      for (let l = 0;l < M.length; l++) {
        const S0 = M.charCodeAt(l);
        if (S0 >= 7 && S0 <= 13 || S0 === 27 || S0 === 127)
          return false;
      }
      return true;
    }
    function X(M) {
      return J(M) || X0(M);
    }
    function Z(M) {
      return V.IsUndefined(M) || V.IsBigInt(M);
    }
    function Q(M) {
      return V.IsUndefined(M) || V.IsNumber(M);
    }
    function J(M) {
      return V.IsUndefined(M) || V.IsBoolean(M);
    }
    function z(M) {
      return V.IsUndefined(M) || V.IsString(M);
    }
    function U(M) {
      return V.IsUndefined(M) || V.IsString(M) && W(M) && Y(M);
    }
    function D(M) {
      return V.IsUndefined(M) || V.IsString(M) && W(M);
    }
    function B(M) {
      return V.IsUndefined(M) || X0(M);
    }
    function j(M) {
      return _(M, "Any") && z(M.$id);
    }
    $.TAny = j;
    function b(M) {
      return _(M, "Array") && M.type === "array" && z(M.$id) && X0(M.items) && Q(M.minItems) && Q(M.maxItems) && J(M.uniqueItems) && B(M.contains) && Q(M.minContains) && Q(M.maxContains);
    }
    $.TArray = b;
    function S(M) {
      return _(M, "AsyncIterator") && M.type === "AsyncIterator" && z(M.$id) && X0(M.items);
    }
    $.TAsyncIterator = S;
    function N(M) {
      return _(M, "BigInt") && M.type === "bigint" && z(M.$id) && Z(M.exclusiveMaximum) && Z(M.exclusiveMinimum) && Z(M.maximum) && Z(M.minimum) && Z(M.multipleOf);
    }
    $.TBigInt = N;
    function O(M) {
      return _(M, "Boolean") && M.type === "boolean" && z(M.$id);
    }
    $.TBoolean = O;
    function P(M) {
      return _(M, "Constructor") && M.type === "Constructor" && z(M.$id) && V.IsArray(M.parameters) && M.parameters.every((l) => X0(l)) && X0(M.returns);
    }
    $.TConstructor = P;
    function F(M) {
      return _(M, "Date") && M.type === "Date" && z(M.$id) && Q(M.exclusiveMaximumTimestamp) && Q(M.exclusiveMinimumTimestamp) && Q(M.maximumTimestamp) && Q(M.minimumTimestamp) && Q(M.multipleOfTimestamp);
    }
    $.TDate = F;
    function w(M) {
      return _(M, "Function") && M.type === "Function" && z(M.$id) && V.IsArray(M.parameters) && M.parameters.every((l) => X0(l)) && X0(M.returns);
    }
    $.TFunction = w;
    function I(M) {
      return _(M, "Integer") && M.type === "integer" && z(M.$id) && Q(M.exclusiveMaximum) && Q(M.exclusiveMinimum) && Q(M.maximum) && Q(M.minimum) && Q(M.multipleOf);
    }
    $.TInteger = I;
    function G(M) {
      return _(M, "Intersect") && (V.IsString(M.type) && M.type !== "object" ? false : true) && V.IsArray(M.allOf) && M.allOf.every((l) => X0(l) && !w0(l)) && z(M.type) && (J(M.unevaluatedProperties) || B(M.unevaluatedProperties)) && z(M.$id);
    }
    $.TIntersect = G;
    function k(M) {
      return _(M, "Iterator") && M.type === "Iterator" && z(M.$id) && X0(M.items);
    }
    $.TIterator = k;
    function _(M, l) {
      return e(M) && M[m6.Kind] === l;
    }
    $.TKindOf = _;
    function e(M) {
      return V.IsObject(M) && m6.Kind in M && V.IsString(M[m6.Kind]);
    }
    $.TKind = e;
    function o(M) {
      return b0(M) && V.IsString(M.const);
    }
    $.TLiteralString = o;
    function r(M) {
      return b0(M) && V.IsNumber(M.const);
    }
    $.TLiteralNumber = r;
    function g0(M) {
      return b0(M) && V.IsBoolean(M.const);
    }
    $.TLiteralBoolean = g0;
    function b0(M) {
      return _(M, "Literal") && z(M.$id) && (V.IsBoolean(M.const) || V.IsNumber(M.const) || V.IsString(M.const));
    }
    $.TLiteral = b0;
    function E0(M) {
      return _(M, "Never") && V.IsObject(M.not) && Object.getOwnPropertyNames(M.not).length === 0;
    }
    $.TNever = E0;
    function H0(M) {
      return _(M, "Not") && X0(M.not);
    }
    $.TNot = H0;
    function z0(M) {
      return _(M, "Null") && M.type === "null" && z(M.$id);
    }
    $.TNull = z0;
    function u0(M) {
      return _(M, "Number") && M.type === "number" && z(M.$id) && Q(M.exclusiveMaximum) && Q(M.exclusiveMinimum) && Q(M.maximum) && Q(M.minimum) && Q(M.multipleOf);
    }
    $.TNumber = u0;
    function a0(M) {
      return _(M, "Object") && M.type === "object" && z(M.$id) && V.IsObject(M.properties) && X(M.additionalProperties) && Q(M.minProperties) && Q(M.maxProperties) && Object.entries(M.properties).every(([l, S0]) => W(l) && X0(S0));
    }
    $.TObject = a0;
    function v0(M) {
      return _(M, "Promise") && M.type === "Promise" && z(M.$id) && X0(M.item);
    }
    $.TPromise = v0;
    function R(M) {
      return _(M, "Record") && M.type === "object" && z(M.$id) && X(M.additionalProperties) && V.IsObject(M.patternProperties) && ((l) => {
        const S0 = Object.getOwnPropertyNames(l.patternProperties);
        return S0.length === 1 && Y(S0[0]) && V.IsObject(l.patternProperties) && X0(l.patternProperties[S0[0]]);
      })(M);
    }
    $.TRecord = R;
    function f(M) {
      return V.IsObject(M) && m6.Hint in M && M[m6.Hint] === "Recursive";
    }
    $.TRecursive = f;
    function i(M) {
      return _(M, "Ref") && z(M.$id) && V.IsString(M.$ref);
    }
    $.TRef = i;
    function n(M) {
      return _(M, "String") && M.type === "string" && z(M.$id) && Q(M.minLength) && Q(M.maxLength) && U(M.pattern) && D(M.format);
    }
    $.TString = n;
    function q0(M) {
      return _(M, "Symbol") && M.type === "symbol" && z(M.$id);
    }
    $.TSymbol = q0;
    function B0(M) {
      return _(M, "TemplateLiteral") && M.type === "string" && V.IsString(M.pattern) && M.pattern[0] === "^" && M.pattern[M.pattern.length - 1] === "$";
    }
    $.TTemplateLiteral = B0;
    function D0(M) {
      return _(M, "This") && z(M.$id) && V.IsString(M.$ref);
    }
    $.TThis = D0;
    function w0(M) {
      return V.IsObject(M) && m6.Transform in M;
    }
    $.TTransform = w0;
    function M0(M) {
      return _(M, "Tuple") && M.type === "array" && z(M.$id) && V.IsNumber(M.minItems) && V.IsNumber(M.maxItems) && M.minItems === M.maxItems && (V.IsUndefined(M.items) && V.IsUndefined(M.additionalItems) && M.minItems === 0 || V.IsArray(M.items) && M.items.every((l) => X0(l)));
    }
    $.TTuple = M0;
    function B1(M) {
      return _(M, "Undefined") && M.type === "undefined" && z(M.$id);
    }
    $.TUndefined = B1;
    function K(M) {
      return E(M) && M.anyOf.every((l) => o(l) || r(l));
    }
    $.TUnionLiteral = K;
    function E(M) {
      return _(M, "Union") && z(M.$id) && V.IsObject(M) && V.IsArray(M.anyOf) && M.anyOf.every((l) => X0(l));
    }
    $.TUnion = E;
    function L(M) {
      return _(M, "Uint8Array") && M.type === "Uint8Array" && z(M.$id) && Q(M.minByteLength) && Q(M.maxByteLength);
    }
    $.TUint8Array = L;
    function p(M) {
      return _(M, "Unknown") && z(M.$id);
    }
    $.TUnknown = p;
    function T(M) {
      return _(M, "Unsafe");
    }
    $.TUnsafe = T;
    function d(M) {
      return _(M, "Void") && M.type === "void" && z(M.$id);
    }
    $.TVoid = d;
    function W0(M) {
      return V.IsObject(M) && M[m6.Readonly] === "Readonly";
    }
    $.TReadonly = W0;
    function j0(M) {
      return V.IsObject(M) && M[m6.Optional] === "Optional";
    }
    $.TOptional = j0;
    function X0(M) {
      return V.IsObject(M) && (j(M) || b(M) || O(M) || N(M) || S(M) || P(M) || F(M) || w(M) || I(M) || G(M) || k(M) || b0(M) || E0(M) || H0(M) || z0(M) || u0(M) || a0(M) || v0(M) || R(M) || i(M) || n(M) || q0(M) || B0(M) || D0(M) || M0(M) || B1(M) || E(M) || L(M) || p(M) || T(M) || d(M) || e(M) && $8.Has(M[m6.Kind]));
    }
    $.TSchema = X0;
  })(A || (m6.TypeGuard = A = {}));
  var p6;
  (function($) {
    function Y(W) {
      return W[m6.Kind] === "Intersect" ? W.allOf.every((X) => Y(X)) : W[m6.Kind] === "Union" ? W.anyOf.some((X) => Y(X)) : W[m6.Kind] === "Undefined" ? true : W[m6.Kind] === "Not" ? !Y(W.not) : false;
    }
    $.Check = Y;
  })(p6 || (m6.ExtendsUndefined = p6 = {}));

  class Z8 extends $1 {
  }
  m6.TypeExtendsError = Z8;
  var C;
  (function($) {
    $[$.Union = 0] = "Union", $[$.True = 1] = "True", $[$.False = 2] = "False";
  })(C || (m6.TypeExtendsResult = C = {}));
  var j1;
  (function($) {
    function Y(H) {
      return H === C.False ? H : C.True;
    }
    function W(H) {
      throw new Z8(H);
    }
    function X(H) {
      return A.TNever(H) || A.TIntersect(H) || A.TUnion(H) || A.TUnknown(H) || A.TAny(H);
    }
    function Z(H, q) {
      return A.TNever(q) ? _(H, q) : A.TIntersect(q) ? w(H, q) : A.TUnion(q) ? s$(H, q) : A.TUnknown(q) ? O6(H, q) : A.TAny(q) ? Q(H, q) : W("StructuralRight");
    }
    function Q(H, q) {
      return C.True;
    }
    function J(H, q) {
      return A.TIntersect(q) ? w(H, q) : A.TUnion(q) && q.anyOf.some(($0) => A.TAny($0) || A.TUnknown($0)) ? C.True : A.TUnion(q) ? C.Union : A.TUnknown(q) ? C.True : A.TAny(q) ? C.True : C.Union;
    }
    function z(H, q) {
      return A.TUnknown(H) ? C.False : A.TAny(H) ? C.Union : A.TNever(H) ? C.True : C.False;
    }
    function U(H, q) {
      return A.TObject(q) && B0(q) ? C.True : X(q) ? Z(H, q) : !A.TArray(q) ? C.False : Y(Q0(H.items, q.items));
    }
    function D(H, q) {
      return X(q) ? Z(H, q) : !A.TAsyncIterator(q) ? C.False : Y(Q0(H.items, q.items));
    }
    function B(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TBigInt(q) ? C.True : C.False;
    }
    function j(H, q) {
      return A.TLiteral(H) && V.IsBoolean(H.const) ? C.True : A.TBoolean(H) ? C.True : C.False;
    }
    function b(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TBoolean(q) ? C.True : C.False;
    }
    function S(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : !A.TConstructor(q) ? C.False : H.parameters.length > q.parameters.length ? C.False : !H.parameters.every(($0, h0) => Y(Q0(q.parameters[h0], $0)) === C.True) ? C.False : Y(Q0(H.returns, q.returns));
    }
    function N(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TDate(q) ? C.True : C.False;
    }
    function O(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : !A.TFunction(q) ? C.False : H.parameters.length > q.parameters.length ? C.False : !H.parameters.every(($0, h0) => Y(Q0(q.parameters[h0], $0)) === C.True) ? C.False : Y(Q0(H.returns, q.returns));
    }
    function P(H, q) {
      return A.TLiteral(H) && V.IsNumber(H.const) ? C.True : A.TNumber(H) || A.TInteger(H) ? C.True : C.False;
    }
    function F(H, q) {
      return A.TInteger(q) || A.TNumber(q) ? C.True : X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : C.False;
    }
    function w(H, q) {
      return q.allOf.every(($0) => Q0(H, $0) === C.True) ? C.True : C.False;
    }
    function I(H, q) {
      return H.allOf.some(($0) => Q0($0, q) === C.True) ? C.True : C.False;
    }
    function G(H, q) {
      return X(q) ? Z(H, q) : !A.TIterator(q) ? C.False : Y(Q0(H.items, q.items));
    }
    function k(H, q) {
      return A.TLiteral(q) && q.const === H.const ? C.True : X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TString(q) ? d(H, q) : A.TNumber(q) ? b0(H, q) : A.TInteger(q) ? P(H, q) : A.TBoolean(q) ? j(H, q) : C.False;
    }
    function _(H, q) {
      return C.False;
    }
    function e(H, q) {
      return C.True;
    }
    function o(H) {
      let [q, $0] = [H, 0];
      while (true) {
        if (!A.TNot(q))
          break;
        q = q.not, $0 += 1;
      }
      return $0 % 2 === 0 ? q : m6.Type.Unknown();
    }
    function r(H, q) {
      return A.TNot(H) ? Q0(o(H), q) : A.TNot(q) ? Q0(H, o(q)) : W("Invalid fallthrough for Not");
    }
    function g0(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TNull(q) ? C.True : C.False;
    }
    function b0(H, q) {
      return A.TLiteralNumber(H) ? C.True : A.TNumber(H) || A.TInteger(H) ? C.True : C.False;
    }
    function E0(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TInteger(q) || A.TNumber(q) ? C.True : C.False;
    }
    function H0(H, q) {
      return Object.getOwnPropertyNames(H.properties).length === q;
    }
    function z0(H) {
      return B0(H);
    }
    function u0(H) {
      return H0(H, 0) || H0(H, 1) && "description" in H.properties && A.TUnion(H.properties.description) && H.properties.description.anyOf.length === 2 && (A.TString(H.properties.description.anyOf[0]) && A.TUndefined(H.properties.description.anyOf[1]) || A.TString(H.properties.description.anyOf[1]) && A.TUndefined(H.properties.description.anyOf[0]));
    }
    function a0(H) {
      return H0(H, 0);
    }
    function v0(H) {
      return H0(H, 0);
    }
    function R(H) {
      return H0(H, 0);
    }
    function f(H) {
      return H0(H, 0);
    }
    function i(H) {
      return B0(H);
    }
    function n(H) {
      const q = m6.Type.Number();
      return H0(H, 0) || H0(H, 1) && "length" in H.properties && Y(Q0(H.properties.length, q)) === C.True;
    }
    function q0(H) {
      return H0(H, 0);
    }
    function B0(H) {
      const q = m6.Type.Number();
      return H0(H, 0) || H0(H, 1) && "length" in H.properties && Y(Q0(H.properties.length, q)) === C.True;
    }
    function D0(H) {
      const q = m6.Type.Function([m6.Type.Any()], m6.Type.Any());
      return H0(H, 0) || H0(H, 1) && "then" in H.properties && Y(Q0(H.properties.then, q)) === C.True;
    }
    function w0(H, q) {
      return Q0(H, q) === C.False ? C.False : A.TOptional(H) && !A.TOptional(q) ? C.False : C.True;
    }
    function M0(H, q) {
      return A.TUnknown(H) ? C.False : A.TAny(H) ? C.Union : A.TNever(H) || A.TLiteralString(H) && z0(q) || A.TLiteralNumber(H) && a0(q) || A.TLiteralBoolean(H) && v0(q) || A.TSymbol(H) && u0(q) || A.TBigInt(H) && R(q) || A.TString(H) && z0(q) || A.TSymbol(H) && u0(q) || A.TNumber(H) && a0(q) || A.TInteger(H) && a0(q) || A.TBoolean(H) && v0(q) || A.TUint8Array(H) && i(q) || A.TDate(H) && f(q) || A.TConstructor(H) && q0(q) || A.TFunction(H) && n(q) ? C.True : A.TRecord(H) && A.TString(E(H)) ? (() => {
        return q[m6.Hint] === "Record" ? C.True : C.False;
      })() : A.TRecord(H) && A.TNumber(E(H)) ? (() => {
        return H0(q, 0) ? C.True : C.False;
      })() : C.False;
    }
    function B1(H, q) {
      return X(q) ? Z(H, q) : A.TRecord(q) ? p(H, q) : !A.TObject(q) ? C.False : (() => {
        for (let $0 of Object.getOwnPropertyNames(q.properties)) {
          if (!($0 in H.properties))
            return C.False;
          if (w0(H.properties[$0], q.properties[$0]) === C.False)
            return C.False;
        }
        return C.True;
      })();
    }
    function K(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) && D0(q) ? C.True : !A.TPromise(q) ? C.False : Y(Q0(H.item, q.item));
    }
    function E(H) {
      return m6.PatternNumberExact in H.patternProperties ? m6.Type.Number() : (m6.PatternStringExact in H.patternProperties) ? m6.Type.String() : W("Unknown record key pattern");
    }
    function L(H) {
      return m6.PatternNumberExact in H.patternProperties ? H.patternProperties[m6.PatternNumberExact] : (m6.PatternStringExact in H.patternProperties) ? H.patternProperties[m6.PatternStringExact] : W("Unable to get record value schema");
    }
    function p(H, q) {
      const [$0, h0] = [E(q), L(q)];
      return A.TLiteralString(H) && A.TNumber($0) && Y(Q0(H, h0)) === C.True ? C.True : A.TUint8Array(H) && A.TNumber($0) ? Q0(H, h0) : A.TString(H) && A.TNumber($0) ? Q0(H, h0) : A.TArray(H) && A.TNumber($0) ? Q0(H, h0) : A.TObject(H) ? (() => {
        for (let aW of Object.getOwnPropertyNames(H.properties))
          if (w0(h0, H.properties[aW]) === C.False)
            return C.False;
        return C.True;
      })() : C.False;
    }
    function T(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : !A.TRecord(q) ? C.False : Q0(L(H), L(q));
    }
    function d(H, q) {
      return A.TLiteral(H) && V.IsString(H.const) ? C.True : A.TString(H) ? C.True : C.False;
    }
    function W0(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TString(q) ? C.True : C.False;
    }
    function j0(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TSymbol(q) ? C.True : C.False;
    }
    function X0(H, q) {
      return A.TTemplateLiteral(H) ? Q0(J1.Resolve(H), q) : A.TTemplateLiteral(q) ? Q0(H, J1.Resolve(q)) : W("Invalid fallthrough for TemplateLiteral");
    }
    function M(H, q) {
      return A.TArray(q) && H.items !== undefined && H.items.every(($0) => Q0($0, q.items) === C.True);
    }
    function l(H, q) {
      return A.TNever(H) ? C.True : A.TUnknown(H) ? C.False : A.TAny(H) ? C.Union : C.False;
    }
    function S0(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) && B0(q) ? C.True : A.TArray(q) && M(H, q) ? C.True : !A.TTuple(q) ? C.False : V.IsUndefined(H.items) && !V.IsUndefined(q.items) || !V.IsUndefined(H.items) && V.IsUndefined(q.items) ? C.False : V.IsUndefined(H.items) && !V.IsUndefined(q.items) ? C.True : H.items.every(($0, h0) => Q0($0, q.items[h0]) === C.True) ? C.True : C.False;
    }
    function l$(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TUint8Array(q) ? C.True : C.False;
    }
    function t$(H, q) {
      return X(q) ? Z(H, q) : A.TObject(q) ? M0(H, q) : A.TRecord(q) ? p(H, q) : A.TVoid(q) ? tW(H, q) : A.TUndefined(q) ? C.True : C.False;
    }
    function s$(H, q) {
      return q.anyOf.some(($0) => Q0(H, $0) === C.True) ? C.True : C.False;
    }
    function cW(H, q) {
      return H.anyOf.every(($0) => Q0($0, q) === C.True) ? C.True : C.False;
    }
    function O6(H, q) {
      return C.True;
    }
    function lW(H, q) {
      return A.TNever(q) ? _(H, q) : A.TIntersect(q) ? w(H, q) : A.TUnion(q) ? s$(H, q) : A.TAny(q) ? Q(H, q) : A.TString(q) ? d(H, q) : A.TNumber(q) ? b0(H, q) : A.TInteger(q) ? P(H, q) : A.TBoolean(q) ? j(H, q) : A.TArray(q) ? z(H, q) : A.TTuple(q) ? l(H, q) : A.TObject(q) ? M0(H, q) : A.TUnknown(q) ? C.True : C.False;
    }
    function tW(H, q) {
      return A.TUndefined(H) ? C.True : A.TUndefined(H) ? C.True : C.False;
    }
    function sW(H, q) {
      return A.TIntersect(q) ? w(H, q) : A.TUnion(q) ? s$(H, q) : A.TUnknown(q) ? O6(H, q) : A.TAny(q) ? Q(H, q) : A.TObject(q) ? M0(H, q) : A.TVoid(q) ? C.True : C.False;
    }
    function Q0(H, q) {
      return A.TTemplateLiteral(H) || A.TTemplateLiteral(q) ? X0(H, q) : A.TNot(H) || A.TNot(q) ? r(H, q) : A.TAny(H) ? J(H, q) : A.TArray(H) ? U(H, q) : A.TBigInt(H) ? B(H, q) : A.TBoolean(H) ? b(H, q) : A.TAsyncIterator(H) ? D(H, q) : A.TConstructor(H) ? S(H, q) : A.TDate(H) ? N(H, q) : A.TFunction(H) ? O(H, q) : A.TInteger(H) ? F(H, q) : A.TIntersect(H) ? I(H, q) : A.TIterator(H) ? G(H, q) : A.TLiteral(H) ? k(H, q) : A.TNever(H) ? e(H, q) : A.TNull(H) ? g0(H, q) : A.TNumber(H) ? E0(H, q) : A.TObject(H) ? B1(H, q) : A.TRecord(H) ? T(H, q) : A.TString(H) ? W0(H, q) : A.TSymbol(H) ? j0(H, q) : A.TTuple(H) ? S0(H, q) : A.TPromise(H) ? K(H, q) : A.TUint8Array(H) ? l$(H, q) : A.TUndefined(H) ? t$(H, q) : A.TUnion(H) ? cW(H, q) : A.TUnknown(H) ? lW(H, q) : A.TVoid(H) ? sW(H, q) : W(`Unknown left type operand '${H[m6.Kind]}'`);
    }
    function rW(H, q) {
      return Q0(H, q);
    }
    $.Extends = rW;
  })(j1 || (m6.TypeExtends = j1 = {}));
  var m;
  (function($) {
    function Y(J) {
      const z = Object.getOwnPropertyNames(J).reduce((D, B) => ({ ...D, [B]: X(J[B]) }), {}), U = Object.getOwnPropertySymbols(J).reduce((D, B) => ({ ...D, [B]: X(J[B]) }), {});
      return { ...z, ...U };
    }
    function W(J) {
      return J.map((z) => X(z));
    }
    function X(J) {
      return V.IsArray(J) ? W(J) : V.IsObject(J) ? Y(J) : J;
    }
    function Z(J) {
      return J.map((z) => Q(z));
    }
    $.Rest = Z;
    function Q(J, z = {}) {
      return { ...X(J), ...z };
    }
    $.Type = Q;
  })(m || (m6.TypeClone = m = {}));
  var Y8;
  (function($) {
    function Y(S) {
      return S.map((N) => {
        const { [m6.Optional]: O, ...P } = m.Type(N);
        return P;
      });
    }
    function W(S) {
      return S.every((N) => A.TOptional(N));
    }
    function X(S) {
      return S.some((N) => A.TOptional(N));
    }
    function Z(S) {
      return W(S.allOf) ? m6.Type.Optional(m6.Type.Intersect(Y(S.allOf))) : S;
    }
    function Q(S) {
      return X(S.anyOf) ? m6.Type.Optional(m6.Type.Union(Y(S.anyOf))) : S;
    }
    function J(S) {
      return S[m6.Kind] === "Intersect" ? Z(S) : S[m6.Kind] === "Union" ? Q(S) : S;
    }
    function z(S, N) {
      const O = S.allOf.reduce((P, F) => {
        const w = j(F, N);
        return w[m6.Kind] === "Never" ? P : [...P, w];
      }, []);
      return J(m6.Type.Intersect(O));
    }
    function U(S, N) {
      const O = S.anyOf.map((P) => j(P, N));
      return J(m6.Type.Union(O));
    }
    function D(S, N) {
      const O = S.properties[N];
      return V.IsUndefined(O) ? m6.Type.Never() : m6.Type.Union([O]);
    }
    function B(S, N) {
      const O = S.items;
      if (V.IsUndefined(O))
        return m6.Type.Never();
      const P = O[N];
      if (V.IsUndefined(P))
        return m6.Type.Never();
      return P;
    }
    function j(S, N) {
      return S[m6.Kind] === "Intersect" ? z(S, N) : S[m6.Kind] === "Union" ? U(S, N) : S[m6.Kind] === "Object" ? D(S, N) : S[m6.Kind] === "Tuple" ? B(S, N) : m6.Type.Never();
    }
    function b(S, N, O = {}) {
      const P = N.map((F) => j(S, F.toString()));
      return J(m6.Type.Union(P, O));
    }
    $.Resolve = b;
  })(Y8 || (m6.IndexedAccessor = Y8 = {}));
  var V1;
  (function($) {
    function Y(B) {
      const [j, b] = [B.slice(0, 1), B.slice(1)];
      return `${j.toLowerCase()}${b}`;
    }
    function W(B) {
      const [j, b] = [B.slice(0, 1), B.slice(1)];
      return `${j.toUpperCase()}${b}`;
    }
    function X(B) {
      return B.toUpperCase();
    }
    function Z(B) {
      return B.toLowerCase();
    }
    function Q(B, j) {
      const b = f1.ParseExact(B.pattern);
      if (!T1.Check(b))
        return { ...B, pattern: J(B.pattern, j) };
      const O = [...d1.Generate(b)].map((w) => m6.Type.Literal(w)), P = z(O, j), F = m6.Type.Union(P);
      return m6.Type.TemplateLiteral([F]);
    }
    function J(B, j) {
      return typeof B === "string" ? j === "Uncapitalize" ? Y(B) : j === "Capitalize" ? W(B) : j === "Uppercase" ? X(B) : j === "Lowercase" ? Z(B) : B : B.toString();
    }
    function z(B, j) {
      if (B.length === 0)
        return [];
      const [b, ...S] = B;
      return [D(b, j), ...z(S, j)];
    }
    function U(B, j) {
      return A.TTemplateLiteral(B) ? Q(B, j) : A.TUnion(B) ? m6.Type.Union(z(B.anyOf, j)) : A.TLiteral(B) ? m6.Type.Literal(J(B.const, j)) : B;
    }
    function D(B, j) {
      return U(B, j);
    }
    $.Map = D;
  })(V1 || (m6.Intrinsic = V1 = {}));
  var x1;
  (function($) {
    function Y(J, z) {
      return m6.Type.Intersect(J.allOf.map((U) => Z(U, z)), { ...J });
    }
    function W(J, z) {
      return m6.Type.Union(J.anyOf.map((U) => Z(U, z)), { ...J });
    }
    function X(J, z) {
      return z(J);
    }
    function Z(J, z) {
      return J[m6.Kind] === "Intersect" ? Y(J, z) : J[m6.Kind] === "Union" ? W(J, z) : J[m6.Kind] === "Object" ? X(J, z) : J;
    }
    function Q(J, z, U) {
      return { ...Z(m.Type(J), z), ...U };
    }
    $.Map = Q;
  })(x1 || (m6.ObjectMap = x1 = {}));
  var P$;
  (function($) {
    function Y(D) {
      return D[0] === "^" && D[D.length - 1] === "$" ? D.slice(1, D.length - 1) : D;
    }
    function W(D, B) {
      return D.allOf.reduce((j, b) => [...j, ...J(b, B)], []);
    }
    function X(D, B) {
      const j = D.anyOf.map((b) => J(b, B));
      return [...j.reduce((b, S) => S.map((N) => j.every((O) => O.includes(N)) ? b.add(N) : b)[0], new Set)];
    }
    function Z(D, B) {
      return Object.getOwnPropertyNames(D.properties);
    }
    function Q(D, B) {
      return B.includePatterns ? Object.getOwnPropertyNames(D.patternProperties) : [];
    }
    function J(D, B) {
      return A.TIntersect(D) ? W(D, B) : A.TUnion(D) ? X(D, B) : A.TObject(D) ? Z(D, B) : A.TRecord(D) ? Q(D, B) : [];
    }
    function z(D, B) {
      return [...new Set(J(D, B))];
    }
    $.ResolveKeys = z;
    function U(D) {
      return `^(${z(D, { includePatterns: true }).map((b) => `(${Y(b)})`).join("|")})$`;
    }
    $.ResolvePattern = U;
  })(P$ || (m6.KeyResolver = P$ = {}));

  class Q8 extends $1 {
  }
  m6.KeyArrayResolverError = Q8;
  var r1;
  (function($) {
    function Y(W) {
      return Array.isArray(W) ? W : A.TUnionLiteral(W) ? W.anyOf.map((X) => X.const.toString()) : A.TLiteral(W) ? [W.const] : A.TTemplateLiteral(W) ? (() => {
        const X = f1.ParseExact(W.pattern);
        if (!T1.Check(X))
          throw new Q8("Cannot resolve keys from infinite template expression");
        return [...d1.Generate(X)];
      })() : [];
    }
    $.Resolve = Y;
  })(r1 || (m6.KeyArrayResolver = r1 = {}));
  var W8;
  (function($) {
    function* Y(X) {
      for (let Z of X.anyOf)
        if (Z[m6.Kind] === "Union")
          yield* Y(Z);
        else
          yield Z;
    }
    function W(X) {
      return m6.Type.Union([...Y(X)], { ...X });
    }
    $.Resolve = W;
  })(W8 || (m6.UnionResolver = W8 = {}));

  class J8 extends $1 {
  }
  m6.TemplateLiteralPatternError = J8;
  var O$;
  (function($) {
    function Y(Q) {
      throw new J8(Q);
    }
    function W(Q) {
      return Q.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function X(Q, J) {
      return A.TTemplateLiteral(Q) ? Q.pattern.slice(1, Q.pattern.length - 1) : A.TUnion(Q) ? `(${Q.anyOf.map((z) => X(z, J)).join("|")})` : A.TNumber(Q) ? `${J}${m6.PatternNumber}` : A.TInteger(Q) ? `${J}${m6.PatternNumber}` : A.TBigInt(Q) ? `${J}${m6.PatternNumber}` : A.TString(Q) ? `${J}${m6.PatternString}` : A.TLiteral(Q) ? `${J}${W(Q.const.toString())}` : A.TBoolean(Q) ? `${J}${m6.PatternBoolean}` : Y(`Unexpected Kind '${Q[m6.Kind]}'`);
    }
    function Z(Q) {
      return `^${Q.map((J) => X(J, "")).join("")}\$`;
    }
    $.Create = Z;
  })(O$ || (m6.TemplateLiteralPattern = O$ = {}));
  var J1;
  (function($) {
    function Y(W) {
      const X = f1.ParseExact(W.pattern);
      if (!T1.Check(X))
        return m6.Type.String();
      const Z = [...d1.Generate(X)].map((Q) => m6.Type.Literal(Q));
      return m6.Type.Union(Z);
    }
    $.Resolve = Y;
  })(J1 || (m6.TemplateLiteralResolver = J1 = {}));

  class S$ extends $1 {
  }
  m6.TemplateLiteralParserError = S$;
  var f1;
  (function($) {
    function Y(S, N, O) {
      return S[N] === O && S.charCodeAt(N - 1) !== 92;
    }
    function W(S, N) {
      return Y(S, N, "(");
    }
    function X(S, N) {
      return Y(S, N, ")");
    }
    function Z(S, N) {
      return Y(S, N, "|");
    }
    function Q(S) {
      if (!(W(S, 0) && X(S, S.length - 1)))
        return false;
      let N = 0;
      for (let O = 0;O < S.length; O++) {
        if (W(S, O))
          N += 1;
        if (X(S, O))
          N -= 1;
        if (N === 0 && O !== S.length - 1)
          return false;
      }
      return true;
    }
    function J(S) {
      return S.slice(1, S.length - 1);
    }
    function z(S) {
      let N = 0;
      for (let O = 0;O < S.length; O++) {
        if (W(S, O))
          N += 1;
        if (X(S, O))
          N -= 1;
        if (Z(S, O) && N === 0)
          return true;
      }
      return false;
    }
    function U(S) {
      for (let N = 0;N < S.length; N++)
        if (W(S, N))
          return true;
      return false;
    }
    function D(S) {
      let [N, O] = [0, 0];
      const P = [];
      for (let w = 0;w < S.length; w++) {
        if (W(S, w))
          N += 1;
        if (X(S, w))
          N -= 1;
        if (Z(S, w) && N === 0) {
          const I = S.slice(O, w);
          if (I.length > 0)
            P.push(j(I));
          O = w + 1;
        }
      }
      const F = S.slice(O);
      if (F.length > 0)
        P.push(j(F));
      if (P.length === 0)
        return { type: "const", const: "" };
      if (P.length === 1)
        return P[0];
      return { type: "or", expr: P };
    }
    function B(S) {
      function N(F, w) {
        if (!W(F, w))
          throw new S$("TemplateLiteralParser: Index must point to open parens");
        let I = 0;
        for (let G = w;G < F.length; G++) {
          if (W(F, G))
            I += 1;
          if (X(F, G))
            I -= 1;
          if (I === 0)
            return [w, G];
        }
        throw new S$("TemplateLiteralParser: Unclosed group parens in expression");
      }
      function O(F, w) {
        for (let I = w;I < F.length; I++)
          if (W(F, I))
            return [w, I];
        return [w, F.length];
      }
      const P = [];
      for (let F = 0;F < S.length; F++)
        if (W(S, F)) {
          const [w, I] = N(S, F), G = S.slice(w, I + 1);
          P.push(j(G)), F = I;
        } else {
          const [w, I] = O(S, F), G = S.slice(w, I);
          if (G.length > 0)
            P.push(j(G));
          F = I - 1;
        }
      return P.length === 0 ? { type: "const", const: "" } : P.length === 1 ? P[0] : { type: "and", expr: P };
    }
    function j(S) {
      return Q(S) ? j(J(S)) : z(S) ? D(S) : U(S) ? B(S) : { type: "const", const: S };
    }
    $.Parse = j;
    function b(S) {
      return j(S.slice(1, S.length - 1));
    }
    $.ParseExact = b;
  })(f1 || (m6.TemplateLiteralParser = f1 = {}));

  class z8 extends $1 {
  }
  m6.TemplateLiteralFiniteError = z8;
  var T1;
  (function($) {
    function Y(J) {
      throw new z8(J);
    }
    function W(J) {
      return J.type === "or" && J.expr.length === 2 && J.expr[0].type === "const" && J.expr[0].const === "0" && J.expr[1].type === "const" && J.expr[1].const === "[1-9][0-9]*";
    }
    function X(J) {
      return J.type === "or" && J.expr.length === 2 && J.expr[0].type === "const" && J.expr[0].const === "true" && J.expr[1].type === "const" && J.expr[1].const === "false";
    }
    function Z(J) {
      return J.type === "const" && J.const === ".*";
    }
    function Q(J) {
      return X(J) ? true : W(J) || Z(J) ? false : J.type === "and" ? J.expr.every((z) => Q(z)) : J.type === "or" ? J.expr.every((z) => Q(z)) : J.type === "const" ? true : Y("Unknown expression type");
    }
    $.Check = Q;
  })(T1 || (m6.TemplateLiteralFinite = T1 = {}));

  class H8 extends $1 {
  }
  m6.TemplateLiteralGeneratorError = H8;
  var d1;
  (function($) {
    function* Y(J) {
      if (J.length === 1)
        return yield* J[0];
      for (let z of J[0])
        for (let U of Y(J.slice(1)))
          yield `${z}${U}`;
    }
    function* W(J) {
      return yield* Y(J.expr.map((z) => [...Q(z)]));
    }
    function* X(J) {
      for (let z of J.expr)
        yield* Q(z);
    }
    function* Z(J) {
      return yield J.const;
    }
    function* Q(J) {
      return J.type === "and" ? yield* W(J) : J.type === "or" ? yield* X(J) : J.type === "const" ? yield* Z(J) : (() => {
        throw new H8("Unknown expression");
      })();
    }
    $.Generate = Q;
  })(d1 || (m6.TemplateLiteralGenerator = d1 = {}));
  var X8;
  (function($) {
    function* Y(Q) {
      const J = Q.trim().replace(/"|'/g, "");
      return J === "boolean" ? yield m6.Type.Boolean() : J === "number" ? yield m6.Type.Number() : J === "bigint" ? yield m6.Type.BigInt() : J === "string" ? yield m6.Type.String() : yield (() => {
        const z = J.split("|").map((U) => m6.Type.Literal(U.trim()));
        return z.length === 0 ? m6.Type.Never() : z.length === 1 ? z[0] : m6.Type.Union(z);
      })();
    }
    function* W(Q) {
      if (Q[1] !== "{") {
        const J = m6.Type.Literal("$"), z = X(Q.slice(1));
        return yield* [J, ...z];
      }
      for (let J = 2;J < Q.length; J++)
        if (Q[J] === "}") {
          const z = Y(Q.slice(2, J)), U = X(Q.slice(J + 1));
          return yield* [...z, ...U];
        }
      yield m6.Type.Literal(Q);
    }
    function* X(Q) {
      for (let J = 0;J < Q.length; J++)
        if (Q[J] === "$") {
          const z = m6.Type.Literal(Q.slice(0, J)), U = W(Q.slice(J));
          return yield* [z, ...U];
        }
      yield m6.Type.Literal(Q);
    }
    function Z(Q) {
      return [...X(Q)];
    }
    $.Parse = Z;
  })(X8 || (m6.TemplateLiteralDslParser = X8 = {}));

  class q8 {
    constructor($) {
      this.schema = $;
    }
    Decode($) {
      return new M8(this.schema, $);
    }
  }
  m6.TransformDecodeBuilder = q8;

  class M8 {
    constructor($, Y) {
      this.schema = $, this.decode = Y;
    }
    Encode($) {
      const Y = m.Type(this.schema);
      return A.TTransform(Y) ? (() => {
        const Z = { Encode: (Q) => Y[m6.Transform].Encode($(Q)), Decode: (Q) => this.decode(Y[m6.Transform].Decode(Q)) };
        return { ...Y, [m6.Transform]: Z };
      })() : (() => {
        const W = { Decode: this.decode, Encode: $ };
        return { ...Y, [m6.Transform]: W };
      })();
    }
  }
  m6.TransformEncodeBuilder = M8;
  var TX = 0;

  class N8 extends $1 {
  }
  m6.TypeBuilderError = N8;

  class F8 {
    Create($) {
      return $;
    }
    Throw($) {
      throw new N8($);
    }
    Discard($, Y) {
      return Y.reduce((W, X) => {
        const { [X]: Z, ...Q } = W;
        return Q;
      }, $);
    }
    Strict($) {
      return JSON.parse(JSON.stringify($));
    }
  }
  m6.TypeBuilder = F8;

  class L$ extends F8 {
    ReadonlyOptional($) {
      return this.Readonly(this.Optional($));
    }
    Readonly($) {
      return { ...m.Type($), [m6.Readonly]: "Readonly" };
    }
    Optional($) {
      return { ...m.Type($), [m6.Optional]: "Optional" };
    }
    Any($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Any" });
    }
    Array($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Array", type: "array", items: m.Type($) });
    }
    Boolean($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Boolean", type: "boolean" });
    }
    Capitalize($, Y = {}) {
      return { ...V1.Map(m.Type($), "Capitalize"), ...Y };
    }
    Composite($, Y) {
      const W = m6.Type.Intersect($, {}), Z = P$.ResolveKeys(W, { includePatterns: false }).reduce((Q, J) => ({ ...Q, [J]: m6.Type.Index(W, [J]) }), {});
      return m6.Type.Object(Z, Y);
    }
    Enum($, Y = {}) {
      const W = Object.getOwnPropertyNames($).filter((Q) => isNaN(Q)).map((Q) => $[Q]), Z = [...new Set(W)].map((Q) => m6.Type.Literal(Q));
      return this.Union(Z, { ...Y, [m6.Hint]: "Enum" });
    }
    Extends($, Y, W, X, Z = {}) {
      switch (j1.Extends($, Y)) {
        case C.Union:
          return this.Union([m.Type(W, Z), m.Type(X, Z)]);
        case C.True:
          return m.Type(W, Z);
        case C.False:
          return m.Type(X, Z);
      }
    }
    Exclude($, Y, W = {}) {
      return A.TTemplateLiteral($) ? this.Exclude(J1.Resolve($), Y, W) : A.TTemplateLiteral(Y) ? this.Exclude($, J1.Resolve(Y), W) : A.TUnion($) ? (() => {
        const X = $.anyOf.filter((Z) => j1.Extends(Z, Y) === C.False);
        return X.length === 1 ? m.Type(X[0], W) : this.Union(X, W);
      })() : j1.Extends($, Y) !== C.False ? this.Never(W) : m.Type($, W);
    }
    Extract($, Y, W = {}) {
      return A.TTemplateLiteral($) ? this.Extract(J1.Resolve($), Y, W) : A.TTemplateLiteral(Y) ? this.Extract($, J1.Resolve(Y), W) : A.TUnion($) ? (() => {
        const X = $.anyOf.filter((Z) => j1.Extends(Z, Y) !== C.False);
        return X.length === 1 ? m.Type(X[0], W) : this.Union(X, W);
      })() : j1.Extends($, Y) !== C.False ? m.Type($, W) : this.Never(W);
    }
    Index($, Y, W = {}) {
      return A.TArray($) && A.TNumber(Y) ? (() => {
        return m.Type($.items, W);
      })() : A.TTuple($) && A.TNumber(Y) ? (() => {
        const Z = (V.IsUndefined($.items) ? [] : $.items).map((Q) => m.Type(Q));
        return this.Union(Z, W);
      })() : (() => {
        const X = r1.Resolve(Y), Z = m.Type($);
        return Y8.Resolve(Z, X, W);
      })();
    }
    Integer($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Integer", type: "integer" });
    }
    Intersect($, Y = {}) {
      if ($.length === 0)
        return m6.Type.Never();
      if ($.length === 1)
        return m.Type($[0], Y);
      if ($.some((Q) => A.TTransform(Q)))
        this.Throw("Cannot intersect transform types");
      const W = $.every((Q) => A.TObject(Q)), X = m.Rest($), Z = A.TSchema(Y.unevaluatedProperties) ? { unevaluatedProperties: m.Type(Y.unevaluatedProperties) } : {};
      return Y.unevaluatedProperties === false || A.TSchema(Y.unevaluatedProperties) || W ? this.Create({ ...Y, ...Z, [m6.Kind]: "Intersect", type: "object", allOf: X }) : this.Create({ ...Y, ...Z, [m6.Kind]: "Intersect", allOf: X });
    }
    KeyOf($, Y = {}) {
      return A.TRecord($) ? (() => {
        const W = Object.getOwnPropertyNames($.patternProperties)[0];
        return W === m6.PatternNumberExact ? this.Number(Y) : W === m6.PatternStringExact ? this.String(Y) : this.Throw("Unable to resolve key type from Record key pattern");
      })() : A.TTuple($) ? (() => {
        const X = (V.IsUndefined($.items) ? [] : $.items).map((Z, Q) => m6.Type.Literal(Q.toString()));
        return this.Union(X, Y);
      })() : A.TArray($) ? (() => {
        return this.Number(Y);
      })() : (() => {
        const W = P$.ResolveKeys($, { includePatterns: false });
        if (W.length === 0)
          return this.Never(Y);
        const X = W.map((Z) => this.Literal(Z));
        return this.Union(X, Y);
      })();
    }
    Literal($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Literal", const: $, type: typeof $ });
    }
    Lowercase($, Y = {}) {
      return { ...V1.Map(m.Type($), "Lowercase"), ...Y };
    }
    Never($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Never", not: {} });
    }
    Not($, Y) {
      return this.Create({ ...Y, [m6.Kind]: "Not", not: m.Type($) });
    }
    Null($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Null", type: "null" });
    }
    Number($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Number", type: "number" });
    }
    Object($, Y = {}) {
      const W = Object.getOwnPropertyNames($), X = W.filter((z) => A.TOptional($[z])), Z = W.filter((z) => !X.includes(z)), Q = A.TSchema(Y.additionalProperties) ? { additionalProperties: m.Type(Y.additionalProperties) } : {}, J = W.reduce((z, U) => ({ ...z, [U]: m.Type($[U]) }), {});
      return Z.length > 0 ? this.Create({ ...Y, ...Q, [m6.Kind]: "Object", type: "object", properties: J, required: Z }) : this.Create({ ...Y, ...Q, [m6.Kind]: "Object", type: "object", properties: J });
    }
    Omit($, Y, W = {}) {
      const X = r1.Resolve(Y);
      return x1.Map(this.Discard(m.Type($), ["$id", m6.Transform]), (Z) => {
        if (V.IsArray(Z.required)) {
          if (Z.required = Z.required.filter((Q) => !X.includes(Q)), Z.required.length === 0)
            delete Z.required;
        }
        for (let Q of Object.getOwnPropertyNames(Z.properties))
          if (X.includes(Q))
            delete Z.properties[Q];
        return this.Create(Z);
      }, W);
    }
    Partial($, Y = {}) {
      return x1.Map(this.Discard(m.Type($), ["$id", m6.Transform]), (W) => {
        const X = Object.getOwnPropertyNames(W.properties).reduce((Z, Q) => {
          return { ...Z, [Q]: this.Optional(W.properties[Q]) };
        }, {});
        return this.Object(X, this.Discard(W, ["required"]));
      }, Y);
    }
    Pick($, Y, W = {}) {
      const X = r1.Resolve(Y);
      return x1.Map(this.Discard(m.Type($), ["$id", m6.Transform]), (Z) => {
        if (V.IsArray(Z.required)) {
          if (Z.required = Z.required.filter((Q) => X.includes(Q)), Z.required.length === 0)
            delete Z.required;
        }
        for (let Q of Object.getOwnPropertyNames(Z.properties))
          if (!X.includes(Q))
            delete Z.properties[Q];
        return this.Create(Z);
      }, W);
    }
    Record($, Y, W = {}) {
      return A.TTemplateLiteral($) ? (() => {
        const X = f1.ParseExact($.pattern);
        return T1.Check(X) ? this.Object([...d1.Generate(X)].reduce((Z, Q) => ({ ...Z, [Q]: m.Type(Y) }), {}), W) : this.Create({ ...W, [m6.Kind]: "Record", type: "object", patternProperties: { [$.pattern]: m.Type(Y) } });
      })() : A.TUnion($) ? (() => {
        const X = W8.Resolve($);
        if (A.TUnionLiteral(X)) {
          const Z = X.anyOf.reduce((Q, J) => ({ ...Q, [J.const]: m.Type(Y) }), {});
          return this.Object(Z, { ...W, [m6.Hint]: "Record" });
        } else
          this.Throw("Record key of type union contains non-literal types");
      })() : A.TLiteral($) ? (() => {
        return V.IsString($.const) || V.IsNumber($.const) ? this.Object({ [$.const]: m.Type(Y) }, W) : this.Throw("Record key of type literal is not of type string or number");
      })() : A.TInteger($) || A.TNumber($) ? (() => {
        return this.Create({ ...W, [m6.Kind]: "Record", type: "object", patternProperties: { [m6.PatternNumberExact]: m.Type(Y) } });
      })() : A.TString($) ? (() => {
        const X = V.IsUndefined($.pattern) ? m6.PatternStringExact : $.pattern;
        return this.Create({ ...W, [m6.Kind]: "Record", type: "object", patternProperties: { [X]: m.Type(Y) } });
      })() : this.Never();
    }
    Recursive($, Y = {}) {
      if (V.IsUndefined(Y.$id))
        Y.$id = `T${TX++}`;
      const W = $({ [m6.Kind]: "This", $ref: `${Y.$id}` });
      return W.$id = Y.$id, this.Create({ ...Y, [m6.Hint]: "Recursive", ...W });
    }
    Ref($, Y = {}) {
      if (V.IsString($))
        return this.Create({ ...Y, [m6.Kind]: "Ref", $ref: $ });
      if (V.IsUndefined($.$id))
        this.Throw("Reference target type must specify an $id");
      return this.Create({ ...Y, [m6.Kind]: "Ref", $ref: $.$id });
    }
    Required($, Y = {}) {
      return x1.Map(this.Discard(m.Type($), ["$id", m6.Transform]), (W) => {
        const X = Object.getOwnPropertyNames(W.properties).reduce((Z, Q) => {
          return { ...Z, [Q]: this.Discard(W.properties[Q], [m6.Optional]) };
        }, {});
        return this.Object(X, W);
      }, Y);
    }
    Rest($) {
      return A.TTuple($) && !V.IsUndefined($.items) ? m.Rest($.items) : A.TIntersect($) ? m.Rest($.allOf) : A.TUnion($) ? m.Rest($.anyOf) : [];
    }
    String($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "String", type: "string" });
    }
    TemplateLiteral($, Y = {}) {
      const W = V.IsString($) ? O$.Create(X8.Parse($)) : O$.Create($);
      return this.Create({ ...Y, [m6.Kind]: "TemplateLiteral", type: "string", pattern: W });
    }
    Transform($) {
      return new q8($);
    }
    Tuple($, Y = {}) {
      const [W, X, Z] = [false, $.length, $.length], Q = m.Rest($), J = $.length > 0 ? { ...Y, [m6.Kind]: "Tuple", type: "array", items: Q, additionalItems: W, minItems: X, maxItems: Z } : { ...Y, [m6.Kind]: "Tuple", type: "array", minItems: X, maxItems: Z };
      return this.Create(J);
    }
    Uncapitalize($, Y = {}) {
      return { ...V1.Map(m.Type($), "Uncapitalize"), ...Y };
    }
    Union($, Y = {}) {
      return A.TTemplateLiteral($) ? J1.Resolve($) : (() => {
        const W = $;
        if (W.length === 0)
          return this.Never(Y);
        if (W.length === 1)
          return this.Create(m.Type(W[0], Y));
        const X = m.Rest(W);
        return this.Create({ ...Y, [m6.Kind]: "Union", anyOf: X });
      })();
    }
    Unknown($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Unknown" });
    }
    Unsafe($ = {}) {
      return this.Create({ ...$, [m6.Kind]: $[m6.Kind] || "Unsafe" });
    }
    Uppercase($, Y = {}) {
      return { ...V1.Map(m.Type($), "Uppercase"), ...Y };
    }
  }
  m6.JsonTypeBuilder = L$;

  class U8 extends L$ {
    AsyncIterator($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "AsyncIterator", type: "AsyncIterator", items: m.Type($) });
    }
    Awaited($, Y = {}) {
      const W = (X) => X.length > 0 ? (() => {
        const [Z, ...Q] = X;
        return [this.Awaited(Z), ...W(Q)];
      })() : X;
      return A.TIntersect($) ? m6.Type.Intersect(W($.allOf)) : A.TUnion($) ? m6.Type.Union(W($.anyOf)) : A.TPromise($) ? this.Awaited($.item) : m.Type($, Y);
    }
    BigInt($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "BigInt", type: "bigint" });
    }
    ConstructorParameters($, Y = {}) {
      return this.Tuple([...$.parameters], { ...Y });
    }
    Constructor($, Y, W) {
      const [X, Z] = [m.Rest($), m.Type(Y)];
      return this.Create({ ...W, [m6.Kind]: "Constructor", type: "Constructor", parameters: X, returns: Z });
    }
    Date($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Date", type: "Date" });
    }
    Function($, Y, W) {
      const [X, Z] = [m.Rest($), m.Type(Y)];
      return this.Create({ ...W, [m6.Kind]: "Function", type: "Function", parameters: X, returns: Z });
    }
    InstanceType($, Y = {}) {
      return m.Type($.returns, Y);
    }
    Iterator($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Iterator", type: "Iterator", items: m.Type($) });
    }
    Parameters($, Y = {}) {
      return this.Tuple($.parameters, { ...Y });
    }
    Promise($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Promise", type: "Promise", item: m.Type($) });
    }
    RegExp($, Y = {}) {
      const W = V.IsString($) ? $ : $.source;
      return this.Create({ ...Y, [m6.Kind]: "String", type: "string", pattern: W });
    }
    RegEx($, Y = {}) {
      return this.RegExp($, Y);
    }
    ReturnType($, Y = {}) {
      return m.Type($.returns, Y);
    }
    Symbol($) {
      return this.Create({ ...$, [m6.Kind]: "Symbol", type: "symbol" });
    }
    Undefined($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Undefined", type: "undefined" });
    }
    Uint8Array($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Uint8Array", type: "Uint8Array" });
    }
    Void($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Void", type: "void" });
    }
  }
  m6.JavaScriptTypeBuilder = U8;
  m6.JsonType = new L$;
  m6.Type = new U8;
});
var P8 = J0((n6) => {
  var w8 = function($, Y) {
    switch (Y) {
      case y.ValueErrorType.ArrayContains:
        return "Expected array to contain at least one matching value";
      case y.ValueErrorType.ArrayMaxContains:
        return `Expected array to contain no more than ${$.maxContains} matching values`;
      case y.ValueErrorType.ArrayMinContains:
        return `Expected array to contain at least ${$.minContains} matching values`;
      case y.ValueErrorType.ArrayMaxItems:
        return `Expected array length to be less or equal to ${$.maxItems}`;
      case y.ValueErrorType.ArrayMinItems:
        return `Expected array length to be greater or equal to ${$.minItems}`;
      case y.ValueErrorType.ArrayUniqueItems:
        return "Expected array elements to be unique";
      case y.ValueErrorType.Array:
        return "Expected array";
      case y.ValueErrorType.AsyncIterator:
        return "Expected AsyncIterator";
      case y.ValueErrorType.BigIntExclusiveMaximum:
        return `Expected bigint to be less than ${$.exclusiveMaximum}`;
      case y.ValueErrorType.BigIntExclusiveMinimum:
        return `Expected bigint to be greater than ${$.exclusiveMinimum}`;
      case y.ValueErrorType.BigIntMaximum:
        return `Expected bigint to be less or equal to ${$.maximum}`;
      case y.ValueErrorType.BigIntMinimum:
        return `Expected bigint to be greater or equal to ${$.minimum}`;
      case y.ValueErrorType.BigIntMultipleOf:
        return `Expected bigint to be a multiple of ${$.multipleOf}`;
      case y.ValueErrorType.BigInt:
        return "Expected bigint";
      case y.ValueErrorType.Boolean:
        return "Expected boolean";
      case y.ValueErrorType.DateExclusiveMinimumTimestamp:
        return `Expected Date timestamp to be greater than ${$.exclusiveMinimumTimestamp}`;
      case y.ValueErrorType.DateExclusiveMaximumTimestamp:
        return `Expected Date timestamp to be less than ${$.exclusiveMaximumTimestamp}`;
      case y.ValueErrorType.DateMinimumTimestamp:
        return `Expected Date timestamp to be greater or equal to ${$.minimumTimestamp}`;
      case y.ValueErrorType.DateMaximumTimestamp:
        return `Expected Date timestamp to be less or equal to ${$.maximumTimestamp}`;
      case y.ValueErrorType.DateMultipleOfTimestamp:
        return `Expected Date timestamp to be a multiple of ${$.multipleOfTimestamp}`;
      case y.ValueErrorType.Date:
        return "Expected Date";
      case y.ValueErrorType.Function:
        return "Expected function";
      case y.ValueErrorType.IntegerExclusiveMaximum:
        return `Expected integer to be less than ${$.exclusiveMaximum}`;
      case y.ValueErrorType.IntegerExclusiveMinimum:
        return `Expected integer to be greater than ${$.exclusiveMinimum}`;
      case y.ValueErrorType.IntegerMaximum:
        return `Expected integer to be less or equal to ${$.maximum}`;
      case y.ValueErrorType.IntegerMinimum:
        return `Expected integer to be greater or equal to ${$.minimum}`;
      case y.ValueErrorType.IntegerMultipleOf:
        return `Expected integer to be a multiple of ${$.multipleOf}`;
      case y.ValueErrorType.Integer:
        return "Expected integer";
      case y.ValueErrorType.IntersectUnevaluatedProperties:
        return "Unexpected property";
      case y.ValueErrorType.Intersect:
        return "Expected all values to match";
      case y.ValueErrorType.Iterator:
        return "Expected Iterator";
      case y.ValueErrorType.Literal:
        return `Expected ${typeof $.const === "string" ? `'${$.const}'` : $.const}`;
      case y.ValueErrorType.Never:
        return "Never";
      case y.ValueErrorType.Not:
        return "Value should not match";
      case y.ValueErrorType.Null:
        return "Expected null";
      case y.ValueErrorType.NumberExclusiveMaximum:
        return `Expected number to be less than ${$.exclusiveMaximum}`;
      case y.ValueErrorType.NumberExclusiveMinimum:
        return `Expected number to be greater than ${$.exclusiveMinimum}`;
      case y.ValueErrorType.NumberMaximum:
        return `Expected number to be less or equal to ${$.maximum}`;
      case y.ValueErrorType.NumberMinimum:
        return `Expected number to be greater or equal to ${$.minimum}`;
      case y.ValueErrorType.NumberMultipleOf:
        return `Expected number to be a multiple of ${$.multipleOf}`;
      case y.ValueErrorType.Number:
        return "Expected number";
      case y.ValueErrorType.Object:
        return "Expected object";
      case y.ValueErrorType.ObjectAdditionalProperties:
        return "Unexpected property";
      case y.ValueErrorType.ObjectMaxProperties:
        return `Expected object to have no more than ${$.maxProperties} properties`;
      case y.ValueErrorType.ObjectMinProperties:
        return `Expected object to have at least ${$.minProperties} properties`;
      case y.ValueErrorType.ObjectRequiredProperty:
        return "Required property";
      case y.ValueErrorType.Promise:
        return "Expected Promise";
      case y.ValueErrorType.StringFormatUnknown:
        return `Unknown format '${$.format}'`;
      case y.ValueErrorType.StringFormat:
        return `Expected string to match '${$.format}' format`;
      case y.ValueErrorType.StringMaxLength:
        return `Expected string length less or equal to ${$.maxLength}`;
      case y.ValueErrorType.StringMinLength:
        return `Expected string length greater or equal to ${$.minLength}`;
      case y.ValueErrorType.StringPattern:
        return `Expected string to match '${$.pattern}'`;
      case y.ValueErrorType.String:
        return "Expected string";
      case y.ValueErrorType.Symbol:
        return "Expected symbol";
      case y.ValueErrorType.TupleLength:
        return `Expected tuple to have ${$.maxItems || 0} elements`;
      case y.ValueErrorType.Tuple:
        return "Expected tuple";
      case y.ValueErrorType.Uint8ArrayMaxByteLength:
        return `Expected byte length less or equal to ${$.maxByteLength}`;
      case y.ValueErrorType.Uint8ArrayMinByteLength:
        return `Expected byte length greater or equal to ${$.minByteLength}`;
      case y.ValueErrorType.Uint8Array:
        return "Expected Uint8Array";
      case y.ValueErrorType.Undefined:
        return "Expected undefined";
      case y.ValueErrorType.Union:
        return "Expected union value";
      case y.ValueErrorType.Void:
        return "Expected void";
      case y.ValueErrorType.Kind:
        return `Expected kind '${$[z1.Kind]}'`;
      default:
        return "Unknown error type";
    }
  };
  Object.defineProperty(n6, "__esModule", { value: true });
  n6.DefaultErrorFunction = n6.TypeSystemPolicy = n6.TypeSystemErrorFunction = n6.TypeSystem = n6.TypeSystemDuplicateFormat = n6.TypeSystemDuplicateTypeKind = undefined;
  var C$ = x0(), y = $$(), z1 = f0();

  class K8 extends z1.TypeBoxError {
    constructor($) {
      super(`Duplicate type kind '${$}' detected`);
    }
  }
  n6.TypeSystemDuplicateTypeKind = K8;

  class j8 extends z1.TypeBoxError {
    constructor($) {
      super(`Duplicate string format '${$}' detected`);
    }
  }
  n6.TypeSystemDuplicateFormat = j8;
  var u6;
  (function($) {
    function Y(X, Z) {
      if (z1.TypeRegistry.Has(X))
        throw new K8(X);
      return z1.TypeRegistry.Set(X, Z), (Q = {}) => z1.Type.Unsafe({ ...Q, [z1.Kind]: X });
    }
    $.Type = Y;
    function W(X, Z) {
      if (z1.FormatRegistry.Has(X))
        throw new j8(X);
      return z1.FormatRegistry.Set(X, Z), X;
    }
    $.Format = W;
  })(u6 || (n6.TypeSystem = u6 = {}));
  var h6;
  (function($) {
    let Y = w8;
    function W() {
      Y = w8;
    }
    $.Reset = W;
    function X(Q) {
      Y = Q;
    }
    $.Set = X;
    function Z() {
      return Y;
    }
    $.Get = Z;
  })(h6 || (n6.TypeSystemErrorFunction = h6 = {}));
  var o6;
  (function($) {
    $.ExactOptionalPropertyTypes = false, $.AllowArrayObject = false, $.AllowNaN = false, $.AllowNullVoid = false;
    function Y(J, z) {
      return $.ExactOptionalPropertyTypes ? z in J : J[z] !== undefined;
    }
    $.IsExactOptionalProperty = Y;
    function W(J) {
      const z = (0, C$.IsObject)(J);
      return $.AllowArrayObject ? z : z && !(0, C$.IsArray)(J);
    }
    $.IsObjectLike = W;
    function X(J) {
      return W(J) && !(J instanceof Date) && !(J instanceof Uint8Array);
    }
    $.IsRecordLike = X;
    function Z(J) {
      const z = (0, C$.IsNumber)(J);
      return $.AllowNaN ? z : z && Number.isFinite(J);
    }
    $.IsNumberLike = Z;
    function Q(J) {
      const z = (0, C$.IsUndefined)(J);
      return $.AllowNullVoid ? z || J === null : z;
    }
    $.IsVoidLike = Q;
  })(o6 || (n6.TypeSystemPolicy = o6 = {}));
  n6.DefaultErrorFunction = w8;
});
var D1 = J0((l6) => {
  var IZ = function($, Y) {
    const W = Y.findIndex((X) => X.$id === $.$ref);
    if (W === -1)
      throw new O8($);
    return Y[W];
  };
  Object.defineProperty(l6, "__esModule", { value: true });
  l6.Deref = l6.TypeDereferenceError = undefined;
  var CZ = f0();

  class O8 extends CZ.TypeBoxError {
    constructor($) {
      super(`Unable to dereference schema with $id '${$.$id}'`);
      this.schema = $;
    }
  }
  l6.TypeDereferenceError = O8;
  l6.Deref = IZ;
});
var Y$ = J0((e6) => {
  function* EZ($) {
    const Y = $ === 0 ? 1 : Math.ceil(Math.floor(Math.log2($) + 1) / 8);
    for (let W = 0;W < Y; W++)
      yield $ >> 8 * (Y - 1 - W) & 255;
  }
  var VZ = function($) {
    R0(T0.Array);
    for (let Y of $)
      v1(Y);
  }, xZ = function($) {
    R0(T0.Boolean), R0($ ? 1 : 0);
  }, kZ = function($) {
    R0(T0.BigInt), r6.setBigInt64(0, $);
    for (let Y of a6)
      R0(Y);
  }, gZ = function($) {
    R0(T0.Date), v1($.getTime());
  }, fZ = function($) {
    R0(T0.Null);
  }, TZ = function($) {
    R0(T0.Number), r6.setFloat64(0, $);
    for (let Y of a6)
      R0(Y);
  }, dZ = function($) {
    R0(T0.Object);
    for (let Y of globalThis.Object.keys($).sort())
      v1(Y), v1($[Y]);
  }, yZ = function($) {
    R0(T0.String);
    for (let Y = 0;Y < $.length; Y++)
      for (let W of EZ($.charCodeAt(Y)))
        R0(W);
  }, vZ = function($) {
    R0(T0.Symbol), v1($.description);
  }, pZ = function($) {
    R0(T0.Uint8Array);
    for (let Y = 0;Y < $.length; Y++)
      R0($[Y]);
  }, iZ = function($) {
    return R0(T0.Undefined);
  }, v1 = function($) {
    if ((0, o0.IsArray)($))
      return VZ($);
    if ((0, o0.IsBoolean)($))
      return xZ($);
    if ((0, o0.IsBigInt)($))
      return kZ($);
    if ((0, o0.IsDate)($))
      return gZ($);
    if ((0, o0.IsNull)($))
      return fZ($);
    if ((0, o0.IsNumber)($))
      return TZ($);
    if ((0, o0.IsPlainObject)($))
      return dZ($);
    if ((0, o0.IsString)($))
      return yZ($);
    if ((0, o0.IsSymbol)($))
      return vZ($);
    if ((0, o0.IsUint8Array)($))
      return pZ($);
    if ((0, o0.IsUndefined)($))
      return iZ($);
    throw new S8($);
  }, R0 = function($) {
    y1 = y1 ^ _Z[$], y1 = y1 * GZ % RZ;
  }, mZ = function($) {
    return y1 = BigInt("14695981039346656037"), v1($), y1;
  };
  Object.defineProperty(e6, "__esModule", { value: true });
  e6.Hash = e6.ByteMarker = e6.ValueHashError = undefined;
  var o0 = x0();

  class S8 extends Error {
    constructor($) {
      super("Unable to hash value");
      this.value = $;
    }
  }
  e6.ValueHashError = S8;
  var T0;
  (function($) {
    $[$.Undefined = 0] = "Undefined", $[$.Null = 1] = "Null", $[$.Boolean = 2] = "Boolean", $[$.Number = 3] = "Number", $[$.String = 4] = "String", $[$.Object = 5] = "Object", $[$.Array = 6] = "Array", $[$.Date = 7] = "Date", $[$.Uint8Array = 8] = "Uint8Array", $[$.Symbol = 9] = "Symbol", $[$.BigInt = 10] = "BigInt";
  })(T0 || (e6.ByteMarker = T0 = {}));
  var y1 = BigInt("14695981039346656037"), [GZ, RZ] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")], _Z = Array.from({ length: 256 }).map(($, Y) => BigInt(Y)), s6 = new Float64Array(1), r6 = new DataView(s6.buffer), a6 = new Uint8Array(s6.buffer);
  e6.Hash = mZ;
});
var $$ = J0((WY) => {
  var t = function($) {
    return $ !== undefined;
  }, g = function($, Y, W, X) {
    return { type: $, schema: Y, path: W, value: X, message: p1.TypeSystemErrorFunction.Get()(Y, $) };
  };
  function* nZ($, Y, W, X) {
  }
  function* cZ($, Y, W, X) {
    if (!(0, U0.IsArray)(X))
      return yield g(x.Array, $, W, X);
    if (t($.minItems) && !(X.length >= $.minItems))
      yield g(x.ArrayMinItems, $, W, X);
    if (t($.maxItems) && !(X.length <= $.maxItems))
      yield g(x.ArrayMaxItems, $, W, X);
    for (let J = 0;J < X.length; J++)
      yield* L0($.items, Y, `${W}/${J}`, X[J]);
    if ($.uniqueItems === true && !function() {
      const J = new Set;
      for (let z of X) {
        const U = (0, oZ.Hash)(z);
        if (J.has(U))
          return false;
        else
          J.add(U);
      }
      return true;
    }())
      yield g(x.ArrayUniqueItems, $, W, X);
    if (!(t($.contains) || t($.minContains) || t($.maxContains)))
      return;
    const Z = t($.contains) ? $.contains : p0.Type.Never(), Q = X.reduce((J, z, U) => L0(Z, Y, `${W}${U}`, z).next().done === true ? J + 1 : J, 0);
    if (Q === 0)
      yield g(x.ArrayContains, $, W, X);
    if ((0, U0.IsNumber)($.minContains) && Q < $.minContains)
      yield g(x.ArrayMinContains, $, W, X);
    if ((0, U0.IsNumber)($.maxContains) && Q > $.maxContains)
      yield g(x.ArrayMaxContains, $, W, X);
  }
  function* lZ($, Y, W, X) {
    if (!(0, U0.IsAsyncIterator)(X))
      yield g(x.AsyncIterator, $, W, X);
  }
  function* tZ($, Y, W, X) {
    if (!(0, U0.IsBigInt)(X))
      return yield g(x.BigInt, $, W, X);
    if (t($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield g(x.BigIntExclusiveMaximum, $, W, X);
    if (t($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield g(x.BigIntExclusiveMinimum, $, W, X);
    if (t($.maximum) && !(X <= $.maximum))
      yield g(x.BigIntMaximum, $, W, X);
    if (t($.minimum) && !(X >= $.minimum))
      yield g(x.BigIntMinimum, $, W, X);
    if (t($.multipleOf) && X % $.multipleOf !== BigInt(0))
      yield g(x.BigIntMultipleOf, $, W, X);
  }
  function* sZ($, Y, W, X) {
    if (!(0, U0.IsBoolean)(X))
      yield g(x.Boolean, $, W, X);
  }
  function* rZ($, Y, W, X) {
    yield* L0($.returns, Y, W, X.prototype);
  }
  function* aZ($, Y, W, X) {
    if (!(0, U0.IsDate)(X))
      return yield g(x.Date, $, W, X);
    if (t($.exclusiveMaximumTimestamp) && !(X.getTime() < $.exclusiveMaximumTimestamp))
      yield g(x.DateExclusiveMaximumTimestamp, $, W, X);
    if (t($.exclusiveMinimumTimestamp) && !(X.getTime() > $.exclusiveMinimumTimestamp))
      yield g(x.DateExclusiveMinimumTimestamp, $, W, X);
    if (t($.maximumTimestamp) && !(X.getTime() <= $.maximumTimestamp))
      yield g(x.DateMaximumTimestamp, $, W, X);
    if (t($.minimumTimestamp) && !(X.getTime() >= $.minimumTimestamp))
      yield g(x.DateMinimumTimestamp, $, W, X);
    if (t($.multipleOfTimestamp) && X.getTime() % $.multipleOfTimestamp !== 0)
      yield g(x.DateMultipleOfTimestamp, $, W, X);
  }
  function* eZ($, Y, W, X) {
    if (!(0, U0.IsFunction)(X))
      yield g(x.Function, $, W, X);
  }
  function* $Q($, Y, W, X) {
    if (!(0, U0.IsInteger)(X))
      return yield g(x.Integer, $, W, X);
    if (t($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield g(x.IntegerExclusiveMaximum, $, W, X);
    if (t($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield g(x.IntegerExclusiveMinimum, $, W, X);
    if (t($.maximum) && !(X <= $.maximum))
      yield g(x.IntegerMaximum, $, W, X);
    if (t($.minimum) && !(X >= $.minimum))
      yield g(x.IntegerMinimum, $, W, X);
    if (t($.multipleOf) && X % $.multipleOf !== 0)
      yield g(x.IntegerMultipleOf, $, W, X);
  }
  function* YQ($, Y, W, X) {
    for (let Z of $.allOf) {
      const Q = L0(Z, Y, W, X).next();
      if (!Q.done)
        yield g(x.Intersect, $, W, X), yield Q.value;
    }
    if ($.unevaluatedProperties === false) {
      const Z = new RegExp(p0.KeyResolver.ResolvePattern($));
      for (let Q of Object.getOwnPropertyNames(X))
        if (!Z.test(Q))
          yield g(x.IntersectUnevaluatedProperties, $, `${W}/${Q}`, X);
    }
    if (typeof $.unevaluatedProperties === "object") {
      const Z = new RegExp(p0.KeyResolver.ResolvePattern($));
      for (let Q of Object.getOwnPropertyNames(X))
        if (!Z.test(Q)) {
          const J = L0($.unevaluatedProperties, Y, `${W}/${Q}`, X[Q]).next();
          if (!J.done)
            yield J.value;
        }
    }
  }
  function* WQ($, Y, W, X) {
    if (!(0, U0.IsIterator)(X))
      yield g(x.Iterator, $, W, X);
  }
  function* XQ($, Y, W, X) {
    if (X !== $.const)
      yield g(x.Literal, $, W, X);
  }
  function* ZQ($, Y, W, X) {
    yield g(x.Never, $, W, X);
  }
  function* QQ($, Y, W, X) {
    if (L0($.not, Y, W, X).next().done === true)
      yield g(x.Not, $, W, X);
  }
  function* JQ($, Y, W, X) {
    if (!(0, U0.IsNull)(X))
      yield g(x.Null, $, W, X);
  }
  function* zQ($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsNumberLike(X))
      return yield g(x.Number, $, W, X);
    if (t($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield g(x.NumberExclusiveMaximum, $, W, X);
    if (t($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield g(x.NumberExclusiveMinimum, $, W, X);
    if (t($.maximum) && !(X <= $.maximum))
      yield g(x.NumberMaximum, $, W, X);
    if (t($.minimum) && !(X >= $.minimum))
      yield g(x.NumberMinimum, $, W, X);
    if (t($.multipleOf) && X % $.multipleOf !== 0)
      yield g(x.NumberMultipleOf, $, W, X);
  }
  function* HQ($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsObjectLike(X))
      return yield g(x.Object, $, W, X);
    if (t($.minProperties) && !(Object.getOwnPropertyNames(X).length >= $.minProperties))
      yield g(x.ObjectMinProperties, $, W, X);
    if (t($.maxProperties) && !(Object.getOwnPropertyNames(X).length <= $.maxProperties))
      yield g(x.ObjectMaxProperties, $, W, X);
    const Z = Array.isArray($.required) ? $.required : [], Q = Object.getOwnPropertyNames($.properties), J = Object.getOwnPropertyNames(X);
    for (let z of Z) {
      if (J.includes(z))
        continue;
      yield g(x.ObjectRequiredProperty, $.properties[z], `${W}/${z}`, undefined);
    }
    if ($.additionalProperties === false) {
      for (let z of J)
        if (!Q.includes(z))
          yield g(x.ObjectAdditionalProperties, $, `${W}/${z}`, X[z]);
    }
    if (typeof $.additionalProperties === "object")
      for (let z of J) {
        if (Q.includes(z))
          continue;
        yield* L0($.additionalProperties, Y, `${W}/${z}`, X[z]);
      }
    for (let z of Q) {
      const U = $.properties[z];
      if ($.required && $.required.includes(z)) {
        if (yield* L0(U, Y, `${W}/${z}`, X[z]), p0.ExtendsUndefined.Check($) && !(z in X))
          yield g(x.ObjectRequiredProperty, U, `${W}/${z}`, undefined);
      } else if (p1.TypeSystemPolicy.IsExactOptionalProperty(X, z))
        yield* L0(U, Y, `${W}/${z}`, X[z]);
    }
  }
  function* qQ($, Y, W, X) {
    if (!(0, U0.IsPromise)(X))
      yield g(x.Promise, $, W, X);
  }
  function* MQ($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsRecordLike(X))
      return yield g(x.Object, $, W, X);
    if (t($.minProperties) && !(Object.getOwnPropertyNames(X).length >= $.minProperties))
      yield g(x.ObjectMinProperties, $, W, X);
    if (t($.maxProperties) && !(Object.getOwnPropertyNames(X).length <= $.maxProperties))
      yield g(x.ObjectMaxProperties, $, W, X);
    const [Z, Q] = Object.entries($.patternProperties)[0], J = new RegExp(Z);
    for (let [z, U] of Object.entries(X))
      if (J.test(z))
        yield* L0(Q, Y, `${W}/${z}`, U);
    if (typeof $.additionalProperties === "object") {
      for (let [z, U] of Object.entries(X))
        if (!J.test(z))
          yield* L0($.additionalProperties, Y, `${W}/${z}`, U);
    }
    if ($.additionalProperties === false)
      for (let [z, U] of Object.entries(X)) {
        if (J.test(z))
          continue;
        return yield g(x.ObjectAdditionalProperties, $, `${W}/${z}`, U);
      }
  }
  function* NQ($, Y, W, X) {
    yield* L0((0, YY.Deref)($, Y), Y, W, X);
  }
  function* FQ($, Y, W, X) {
    if (!(0, U0.IsString)(X))
      return yield g(x.String, $, W, X);
    if (t($.minLength) && !(X.length >= $.minLength))
      yield g(x.StringMinLength, $, W, X);
    if (t($.maxLength) && !(X.length <= $.maxLength))
      yield g(x.StringMaxLength, $, W, X);
    if ((0, U0.IsString)($.pattern)) {
      if (!new RegExp($.pattern).test(X))
        yield g(x.StringPattern, $, W, X);
    }
    if ((0, U0.IsString)($.format)) {
      if (!p0.FormatRegistry.Has($.format))
        yield g(x.StringFormatUnknown, $, W, X);
      else if (!p0.FormatRegistry.Get($.format)(X))
        yield g(x.StringFormat, $, W, X);
    }
  }
  function* UQ($, Y, W, X) {
    if (!(0, U0.IsSymbol)(X))
      yield g(x.Symbol, $, W, X);
  }
  function* AQ($, Y, W, X) {
    if (!(0, U0.IsString)(X))
      return yield g(x.String, $, W, X);
    if (!new RegExp($.pattern).test(X))
      yield g(x.StringPattern, $, W, X);
  }
  function* BQ($, Y, W, X) {
    yield* L0((0, YY.Deref)($, Y), Y, W, X);
  }
  function* DQ($, Y, W, X) {
    if (!(0, U0.IsArray)(X))
      return yield g(x.Tuple, $, W, X);
    if ($.items === undefined && X.length !== 0)
      return yield g(x.TupleLength, $, W, X);
    if (X.length !== $.maxItems)
      return yield g(x.TupleLength, $, W, X);
    if (!$.items)
      return;
    for (let Z = 0;Z < $.items.length; Z++)
      yield* L0($.items[Z], Y, `${W}/${Z}`, X[Z]);
  }
  function* wQ($, Y, W, X) {
    if (!(0, U0.IsUndefined)(X))
      yield g(x.Undefined, $, W, X);
  }
  function* KQ($, Y, W, X) {
    let Z = 0;
    for (let Q of $.anyOf) {
      const J = [...L0(Q, Y, W, X)];
      if (J.length === 0)
        return;
      Z += J.length;
    }
    if (Z > 0)
      yield g(x.Union, $, W, X);
  }
  function* jQ($, Y, W, X) {
    if (!(0, U0.IsUint8Array)(X))
      return yield g(x.Uint8Array, $, W, X);
    if (t($.maxByteLength) && !(X.length <= $.maxByteLength))
      yield g(x.Uint8ArrayMaxByteLength, $, W, X);
    if (t($.minByteLength) && !(X.length >= $.minByteLength))
      yield g(x.Uint8ArrayMinByteLength, $, W, X);
  }
  function* PQ($, Y, W, X) {
  }
  function* OQ($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsVoidLike(X))
      yield g(x.Void, $, W, X);
  }
  function* SQ($, Y, W, X) {
    if (!p0.TypeRegistry.Get($[p0.Kind])($, X))
      yield g(x.Kind, $, W, X);
  }
  function* L0($, Y, W, X) {
    const Z = t($.$id) ? [...Y, $] : Y, Q = $;
    switch (Q[p0.Kind]) {
      case "Any":
        return yield* nZ(Q, Z, W, X);
      case "Array":
        return yield* cZ(Q, Z, W, X);
      case "AsyncIterator":
        return yield* lZ(Q, Z, W, X);
      case "BigInt":
        return yield* tZ(Q, Z, W, X);
      case "Boolean":
        return yield* sZ(Q, Z, W, X);
      case "Constructor":
        return yield* rZ(Q, Z, W, X);
      case "Date":
        return yield* aZ(Q, Z, W, X);
      case "Function":
        return yield* eZ(Q, Z, W, X);
      case "Integer":
        return yield* $Q(Q, Z, W, X);
      case "Intersect":
        return yield* YQ(Q, Z, W, X);
      case "Iterator":
        return yield* WQ(Q, Z, W, X);
      case "Literal":
        return yield* XQ(Q, Z, W, X);
      case "Never":
        return yield* ZQ(Q, Z, W, X);
      case "Not":
        return yield* QQ(Q, Z, W, X);
      case "Null":
        return yield* JQ(Q, Z, W, X);
      case "Number":
        return yield* zQ(Q, Z, W, X);
      case "Object":
        return yield* HQ(Q, Z, W, X);
      case "Promise":
        return yield* qQ(Q, Z, W, X);
      case "Record":
        return yield* MQ(Q, Z, W, X);
      case "Ref":
        return yield* NQ(Q, Z, W, X);
      case "String":
        return yield* FQ(Q, Z, W, X);
      case "Symbol":
        return yield* UQ(Q, Z, W, X);
      case "TemplateLiteral":
        return yield* AQ(Q, Z, W, X);
      case "This":
        return yield* BQ(Q, Z, W, X);
      case "Tuple":
        return yield* DQ(Q, Z, W, X);
      case "Undefined":
        return yield* wQ(Q, Z, W, X);
      case "Union":
        return yield* KQ(Q, Z, W, X);
      case "Uint8Array":
        return yield* jQ(Q, Z, W, X);
      case "Unknown":
        return yield* PQ(Q, Z, W, X);
      case "Void":
        return yield* OQ(Q, Z, W, X);
      default:
        if (!p0.TypeRegistry.Has(Q[p0.Kind]))
          throw new L8($);
        return yield* SQ(Q, Z, W, X);
    }
  }
  var LQ = function(...$) {
    const Y = $.length === 3 ? L0($[0], $[1], "", $[2]) : L0($[0], [], "", $[1]);
    return new C8(Y);
  };
  Object.defineProperty(WY, "__esModule", { value: true });
  WY.Errors = WY.ValueErrorIterator = WY.ValueErrorsUnknownTypeError = WY.ValueErrorType = undefined;
  var U0 = x0(), p1 = P8(), YY = D1(), oZ = Y$(), p0 = f0(), x;
  (function($) {
    $[$.ArrayContains = 0] = "ArrayContains", $[$.ArrayMaxContains = 1] = "ArrayMaxContains", $[$.ArrayMaxItems = 2] = "ArrayMaxItems", $[$.ArrayMinContains = 3] = "ArrayMinContains", $[$.ArrayMinItems = 4] = "ArrayMinItems", $[$.ArrayUniqueItems = 5] = "ArrayUniqueItems", $[$.Array = 6] = "Array", $[$.AsyncIterator = 7] = "AsyncIterator", $[$.BigIntExclusiveMaximum = 8] = "BigIntExclusiveMaximum", $[$.BigIntExclusiveMinimum = 9] = "BigIntExclusiveMinimum", $[$.BigIntMaximum = 10] = "BigIntMaximum", $[$.BigIntMinimum = 11] = "BigIntMinimum", $[$.BigIntMultipleOf = 12] = "BigIntMultipleOf", $[$.BigInt = 13] = "BigInt", $[$.Boolean = 14] = "Boolean", $[$.DateExclusiveMaximumTimestamp = 15] = "DateExclusiveMaximumTimestamp", $[$.DateExclusiveMinimumTimestamp = 16] = "DateExclusiveMinimumTimestamp", $[$.DateMaximumTimestamp = 17] = "DateMaximumTimestamp", $[$.DateMinimumTimestamp = 18] = "DateMinimumTimestamp", $[$.DateMultipleOfTimestamp = 19] = "DateMultipleOfTimestamp", $[$.Date = 20] = "Date", $[$.Function = 21] = "Function", $[$.IntegerExclusiveMaximum = 22] = "IntegerExclusiveMaximum", $[$.IntegerExclusiveMinimum = 23] = "IntegerExclusiveMinimum", $[$.IntegerMaximum = 24] = "IntegerMaximum", $[$.IntegerMinimum = 25] = "IntegerMinimum", $[$.IntegerMultipleOf = 26] = "IntegerMultipleOf", $[$.Integer = 27] = "Integer", $[$.IntersectUnevaluatedProperties = 28] = "IntersectUnevaluatedProperties", $[$.Intersect = 29] = "Intersect", $[$.Iterator = 30] = "Iterator", $[$.Kind = 31] = "Kind", $[$.Literal = 32] = "Literal", $[$.Never = 33] = "Never", $[$.Not = 34] = "Not", $[$.Null = 35] = "Null", $[$.NumberExclusiveMaximum = 36] = "NumberExclusiveMaximum", $[$.NumberExclusiveMinimum = 37] = "NumberExclusiveMinimum", $[$.NumberMaximum = 38] = "NumberMaximum", $[$.NumberMinimum = 39] = "NumberMinimum", $[$.NumberMultipleOf = 40] = "NumberMultipleOf", $[$.Number = 41] = "Number", $[$.ObjectAdditionalProperties = 42] = "ObjectAdditionalProperties", $[$.ObjectMaxProperties = 43] = "ObjectMaxProperties", $[$.ObjectMinProperties = 44] = "ObjectMinProperties", $[$.ObjectRequiredProperty = 45] = "ObjectRequiredProperty", $[$.Object = 46] = "Object", $[$.Promise = 47] = "Promise", $[$.StringFormatUnknown = 48] = "StringFormatUnknown", $[$.StringFormat = 49] = "StringFormat", $[$.StringMaxLength = 50] = "StringMaxLength", $[$.StringMinLength = 51] = "StringMinLength", $[$.StringPattern = 52] = "StringPattern", $[$.String = 53] = "String", $[$.Symbol = 54] = "Symbol", $[$.TupleLength = 55] = "TupleLength", $[$.Tuple = 56] = "Tuple", $[$.Uint8ArrayMaxByteLength = 57] = "Uint8ArrayMaxByteLength", $[$.Uint8ArrayMinByteLength = 58] = "Uint8ArrayMinByteLength", $[$.Uint8Array = 59] = "Uint8Array", $[$.Undefined = 60] = "Undefined", $[$.Union = 61] = "Union", $[$.Void = 62] = "Void";
  })(x || (WY.ValueErrorType = x = {}));

  class L8 extends p0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  WY.ValueErrorsUnknownTypeError = L8;

  class C8 {
    constructor($) {
      this.iterator = $;
    }
    [Symbol.iterator]() {
      return this.iterator;
    }
    First() {
      const $ = this.iterator.next();
      return $.done ? undefined : $.value;
    }
  }
  WY.ValueErrorIterator = C8;
  WY.Errors = LQ;
});
var I$ = J0((O1) => {
  var GQ = O1 && O1.__createBinding || (Object.create ? function($, Y, W, X) {
    if (X === undefined)
      X = W;
    var Z = Object.getOwnPropertyDescriptor(Y, W);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[W];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, W, X) {
    if (X === undefined)
      X = W;
    $[X] = Y[W];
  }), RQ = O1 && O1.__exportStar || function($, Y) {
    for (var W in $)
      if (W !== "default" && !Object.prototype.hasOwnProperty.call(Y, W))
        GQ(Y, $, W);
  };
  Object.defineProperty(O1, "__esModule", { value: true });
  RQ($$(), O1);
});
var b$ = J0((QY) => {
  Object.defineProperty(QY, "__esModule", { value: true });
  QY.ValuePointer = QY.ValuePointerRootDeleteError = QY.ValuePointerRootSetError = undefined;

  class I8 extends Error {
    constructor($, Y, W) {
      super("Cannot set root value");
      this.value = $, this.path = Y, this.update = W;
    }
  }
  QY.ValuePointerRootSetError = I8;

  class b8 extends Error {
    constructor($, Y) {
      super("Cannot delete root value");
      this.value = $, this.path = Y;
    }
  }
  QY.ValuePointerRootDeleteError = b8;
  var ZY;
  (function($) {
    function Y(z) {
      return z.indexOf("~") === -1 ? z : z.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    function* W(z) {
      if (z === "")
        return;
      let [U, D] = [0, 0];
      for (let B = 0;B < z.length; B++)
        if (z.charAt(B) === "/")
          if (B === 0)
            U = B + 1;
          else
            D = B, yield Y(z.slice(U, D)), U = B + 1;
        else
          D = B;
      yield Y(z.slice(U));
    }
    $.Format = W;
    function X(z, U, D) {
      if (U === "")
        throw new I8(z, U, D);
      let [B, j, b] = [null, z, ""];
      for (let S of W(U)) {
        if (j[S] === undefined)
          j[S] = {};
        B = j, j = j[S], b = S;
      }
      B[b] = D;
    }
    $.Set = X;
    function Z(z, U) {
      if (U === "")
        throw new b8(z, U);
      let [D, B, j] = [null, z, ""];
      for (let b of W(U)) {
        if (B[b] === undefined || B[b] === null)
          return;
        D = B, B = B[b], j = b;
      }
      if (Array.isArray(D)) {
        const b = parseInt(j);
        D.splice(b, 1);
      } else
        delete D[j];
    }
    $.Delete = Z;
    function Q(z, U) {
      if (U === "")
        return true;
      let [D, B, j] = [null, z, ""];
      for (let b of W(U)) {
        if (B[b] === undefined)
          return false;
        D = B, B = B[b], j = b;
      }
      return Object.getOwnPropertyNames(D).includes(j);
    }
    $.Has = Q;
    function J(z, U) {
      if (U === "")
        return z;
      let D = z;
      for (let B of W(U)) {
        if (D[B] === undefined)
          return;
        D = D[B];
      }
      return D;
    }
    $.Get = J;
  })(ZY || (QY.ValuePointer = ZY = {}));
});
var i1 = J0((zY) => {
  var VQ = function($) {
    return [...Object.getOwnPropertyNames($), ...Object.getOwnPropertySymbols($)].reduce((W, X) => ({ ...W, [X]: G8($[X]) }), {});
  }, xQ = function($) {
    return $.map((Y) => G8(Y));
  }, kQ = function($) {
    return $.slice();
  }, gQ = function($) {
    return new Date($.toISOString());
  }, fQ = function($) {
    return $;
  }, G8 = function($) {
    if ((0, W$.IsArray)($))
      return xQ($);
    if ((0, W$.IsDate)($))
      return gQ($);
    if ((0, W$.IsPlainObject)($))
      return VQ($);
    if ((0, W$.IsTypedArray)($))
      return kQ($);
    if ((0, W$.IsValueType)($))
      return fQ($);
    throw new Error("ValueClone: Unable to clone value");
  };
  Object.defineProperty(zY, "__esModule", { value: true });
  zY.Clone = undefined;
  var W$ = x0();
  zY.Clone = G8;
});
var V8 = J0((NY) => {
  var X$ = function($, Y) {
    return { type: "update", path: $, value: Y };
  }, qY = function($, Y) {
    return { type: "insert", path: $, value: Y };
  }, MY = function($) {
    return { type: "delete", path: $ };
  };
  function* TQ($, Y, W) {
    if (!(0, _0.IsPlainObject)(W))
      return yield X$($, W);
    const X = [...Object.keys(Y), ...Object.getOwnPropertySymbols(Y)], Z = [...Object.keys(W), ...Object.getOwnPropertySymbols(W)];
    for (let Q of X) {
      if ((0, _0.IsSymbol)(Q))
        throw new m1(Q);
      if ((0, _0.IsUndefined)(W[Q]) && Z.includes(Q))
        yield X$(`${$}/${String(Q)}`, undefined);
    }
    for (let Q of Z) {
      if ((0, _0.IsUndefined)(Y[Q]) || (0, _0.IsUndefined)(W[Q]))
        continue;
      if ((0, _0.IsSymbol)(Q))
        throw new m1(Q);
      yield* G$(`${$}/${String(Q)}`, Y[Q], W[Q]);
    }
    for (let Q of Z) {
      if ((0, _0.IsSymbol)(Q))
        throw new m1(Q);
      if ((0, _0.IsUndefined)(Y[Q]))
        yield qY(`${$}/${String(Q)}`, W[Q]);
    }
    for (let Q of X.reverse()) {
      if ((0, _0.IsSymbol)(Q))
        throw new m1(Q);
      if ((0, _0.IsUndefined)(W[Q]) && !Z.includes(Q))
        yield MY(`${$}/${String(Q)}`);
    }
  }
  function* dQ($, Y, W) {
    if (!(0, _0.IsArray)(W))
      return yield X$($, W);
    for (let X = 0;X < Math.min(Y.length, W.length); X++)
      yield* G$(`${$}/${X}`, Y[X], W[X]);
    for (let X = 0;X < W.length; X++) {
      if (X < Y.length)
        continue;
      yield qY(`${$}/${X}`, W[X]);
    }
    for (let X = Y.length - 1;X >= 0; X--) {
      if (X < W.length)
        continue;
      yield MY(`${$}/${X}`);
    }
  }
  function* yQ($, Y, W) {
    if (!(0, _0.IsTypedArray)(W) || Y.length !== W.length || Object.getPrototypeOf(Y).constructor.name !== Object.getPrototypeOf(W).constructor.name)
      return yield X$($, W);
    for (let X = 0;X < Math.min(Y.length, W.length); X++)
      yield* G$(`${$}/${X}`, Y[X], W[X]);
  }
  function* vQ($, Y, W) {
    if (Y === W)
      return;
    yield X$($, W);
  }
  function* G$($, Y, W) {
    if ((0, _0.IsPlainObject)(Y))
      return yield* TQ($, Y, W);
    if ((0, _0.IsArray)(Y))
      return yield* dQ($, Y, W);
    if ((0, _0.IsTypedArray)(Y))
      return yield* yQ($, Y, W);
    if ((0, _0.IsValueType)(Y))
      return yield* vQ($, Y, W);
    throw new E8(Y);
  }
  var pQ = function($, Y) {
    return [...G$("", $, Y)];
  }, iQ = function($) {
    return $.length > 0 && $[0].path === "" && $[0].type === "update";
  }, mQ = function($) {
    return $.length === 0;
  }, uQ = function($, Y) {
    if (iQ(Y))
      return (0, _8.Clone)(Y[0].value);
    if (mQ(Y))
      return (0, _8.Clone)($);
    const W = (0, _8.Clone)($);
    for (let X of Y)
      switch (X.type) {
        case "insert": {
          R8.ValuePointer.Set(W, X.path, X.value);
          break;
        }
        case "update": {
          R8.ValuePointer.Set(W, X.path, X.value);
          break;
        }
        case "delete": {
          R8.ValuePointer.Delete(W, X.path);
          break;
        }
      }
    return W;
  };
  Object.defineProperty(NY, "__esModule", { value: true });
  NY.Patch = NY.Diff = NY.ValueDeltaUnableToDiffUnknownValue = NY.ValueDeltaObjectWithSymbolKeyError = NY.Edit = NY.Delete = NY.Update = NY.Insert = undefined;
  var _0 = x0(), i0 = f0(), R8 = b$(), _8 = i1();
  NY.Insert = i0.Type.Object({ type: i0.Type.Literal("insert"), path: i0.Type.String(), value: i0.Type.Unknown() });
  NY.Update = i0.Type.Object({ type: i0.Type.Literal("update"), path: i0.Type.String(), value: i0.Type.Unknown() });
  NY.Delete = i0.Type.Object({ type: i0.Type.Literal("delete"), path: i0.Type.String() });
  NY.Edit = i0.Type.Union([NY.Insert, NY.Update, NY.Delete]);

  class m1 extends Error {
    constructor($) {
      super("Cannot diff objects with symbol keys");
      this.key = $;
    }
  }
  NY.ValueDeltaObjectWithSymbolKeyError = m1;

  class E8 extends Error {
    constructor($) {
      super("Unable to create diff edits for unknown value");
      this.value = $;
    }
  }
  NY.ValueDeltaUnableToDiffUnknownValue = E8;
  NY.Diff = pQ;
  NY.Patch = uQ;
});
var jY = J0((wY) => {
  var lQ = function($, Y, W, X) {
    if (!(0, d0.IsPlainObject)(W))
      R$.ValuePointer.Set($, Y, (0, x8.Clone)(X));
    else {
      const Z = Object.keys(W), Q = Object.keys(X);
      for (let J of Z)
        if (!Q.includes(J))
          delete W[J];
      for (let J of Q)
        if (!Z.includes(J))
          W[J] = null;
      for (let J of Q)
        f8($, `${Y}/${J}`, W[J], X[J]);
    }
  }, tQ = function($, Y, W, X) {
    if (!(0, d0.IsArray)(W))
      R$.ValuePointer.Set($, Y, (0, x8.Clone)(X));
    else {
      for (let Z = 0;Z < X.length; Z++)
        f8($, `${Y}/${Z}`, W[Z], X[Z]);
      W.splice(X.length);
    }
  }, sQ = function($, Y, W, X) {
    if ((0, d0.IsTypedArray)(W) && W.length === X.length)
      for (let Z = 0;Z < W.length; Z++)
        W[Z] = X[Z];
    else
      R$.ValuePointer.Set($, Y, (0, x8.Clone)(X));
  }, rQ = function($, Y, W, X) {
    if (W === X)
      return;
    R$.ValuePointer.Set($, Y, X);
  }, f8 = function($, Y, W, X) {
    if ((0, d0.IsArray)(X))
      return tQ($, Y, W, X);
    if ((0, d0.IsTypedArray)(X))
      return sQ($, Y, W, X);
    if ((0, d0.IsPlainObject)(X))
      return lQ($, Y, W, X);
    if ((0, d0.IsValueType)(X))
      return rQ($, Y, W, X);
  }, DY = function($) {
    return (0, d0.IsTypedArray)($) || (0, d0.IsValueType)($);
  }, aQ = function($, Y) {
    return (0, d0.IsPlainObject)($) && (0, d0.IsArray)(Y) || (0, d0.IsArray)($) && (0, d0.IsPlainObject)(Y);
  }, eQ = function($, Y) {
    if (DY($) || DY(Y))
      throw new g8;
    if (aQ($, Y))
      throw new k8;
    f8($, "", $, Y);
  };
  Object.defineProperty(wY, "__esModule", { value: true });
  wY.Mutate = wY.ValueMutateInvalidRootMutationError = wY.ValueMutateTypeMismatchError = undefined;
  var d0 = x0(), R$ = b$(), x8 = i1();

  class k8 extends Error {
    constructor() {
      super("Cannot assign due type mismatch of assignable values");
    }
  }
  wY.ValueMutateTypeMismatchError = k8;

  class g8 extends Error {
    constructor() {
      super("Only object and array types can be mutated at the root level");
    }
  }
  wY.ValueMutateInvalidRootMutationError = g8;
  wY.Mutate = eQ;
});
var SY = J0((PY) => {
  var W4 = function($, Y) {
    if (!(0, H1.IsPlainObject)(Y))
      return false;
    const W = [...Object.keys($), ...Object.getOwnPropertySymbols($)], X = [...Object.keys(Y), ...Object.getOwnPropertySymbols(Y)];
    if (W.length !== X.length)
      return false;
    return W.every((Z) => _$($[Z], Y[Z]));
  }, X4 = function($, Y) {
    return (0, H1.IsDate)(Y) && $.getTime() === Y.getTime();
  }, Z4 = function($, Y) {
    if (!(0, H1.IsArray)(Y) || $.length !== Y.length)
      return false;
    return $.every((W, X) => _$(W, Y[X]));
  }, Q4 = function($, Y) {
    if (!(0, H1.IsTypedArray)(Y) || $.length !== Y.length || Object.getPrototypeOf($).constructor.name !== Object.getPrototypeOf(Y).constructor.name)
      return false;
    return $.every((W, X) => _$(W, Y[X]));
  }, J4 = function($, Y) {
    return $ === Y;
  }, _$ = function($, Y) {
    if ((0, H1.IsPlainObject)($))
      return W4($, Y);
    if ((0, H1.IsDate)($))
      return X4($, Y);
    if ((0, H1.IsTypedArray)($))
      return Q4($, Y);
    if ((0, H1.IsArray)($))
      return Z4($, Y);
    if ((0, H1.IsValueType)($))
      return J4($, Y);
    throw new Error("ValueEquals: Unable to compare value");
  };
  Object.defineProperty(PY, "__esModule", { value: true });
  PY.Equal = undefined;
  var H1 = x0();
  PY.Equal = _$;
});
var E$ = J0((q1) => {
  var z4 = q1 && q1.__createBinding || (Object.create ? function($, Y, W, X) {
    if (X === undefined)
      X = W;
    var Z = Object.getOwnPropertyDescriptor(Y, W);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[W];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, W, X) {
    if (X === undefined)
      X = W;
    $[X] = Y[W];
  }), H4 = q1 && q1.__exportStar || function($, Y) {
    for (var W in $)
      if (W !== "default" && !Object.prototype.hasOwnProperty.call(Y, W))
        z4(Y, $, W);
  };
  Object.defineProperty(q1, "__esModule", { value: true });
  q1.ValueErrorType = undefined;
  var q4 = $$();
  Object.defineProperty(q1, "ValueErrorType", { enumerable: true, get: function() {
    return q4.ValueErrorType;
  } });
  H4(P8(), q1);
});
var Q$ = J0((CY) => {
  var N4 = function($) {
    return $[C0.Kind] === "Any" || $[C0.Kind] === "Unknown";
  }, s = function($) {
    return $ !== undefined;
  }, F4 = function($, Y, W) {
    return true;
  }, U4 = function($, Y, W) {
    if (!(0, A0.IsArray)(W))
      return false;
    if (s($.minItems) && !(W.length >= $.minItems))
      return false;
    if (s($.maxItems) && !(W.length <= $.maxItems))
      return false;
    if (!W.every((Q) => I0($.items, Y, Q)))
      return false;
    if ($.uniqueItems === true && !function() {
      const Q = new Set;
      for (let J of W) {
        const z = (0, M4.Hash)(J);
        if (Q.has(z))
          return false;
        else
          Q.add(z);
      }
      return true;
    }())
      return false;
    if (!(s($.contains) || (0, A0.IsNumber)($.minContains) || (0, A0.IsNumber)($.maxContains)))
      return true;
    const X = s($.contains) ? $.contains : C0.Type.Never(), Z = W.reduce((Q, J) => I0(X, Y, J) ? Q + 1 : Q, 0);
    if (Z === 0)
      return false;
    if ((0, A0.IsNumber)($.minContains) && Z < $.minContains)
      return false;
    if ((0, A0.IsNumber)($.maxContains) && Z > $.maxContains)
      return false;
    return true;
  }, A4 = function($, Y, W) {
    return (0, A0.IsAsyncIterator)(W);
  }, B4 = function($, Y, W) {
    if (!(0, A0.IsBigInt)(W))
      return false;
    if (s($.exclusiveMaximum) && !(W < $.exclusiveMaximum))
      return false;
    if (s($.exclusiveMinimum) && !(W > $.exclusiveMinimum))
      return false;
    if (s($.maximum) && !(W <= $.maximum))
      return false;
    if (s($.minimum) && !(W >= $.minimum))
      return false;
    if (s($.multipleOf) && W % $.multipleOf !== BigInt(0))
      return false;
    return true;
  }, D4 = function($, Y, W) {
    return (0, A0.IsBoolean)(W);
  }, w4 = function($, Y, W) {
    return I0($.returns, Y, W.prototype);
  }, K4 = function($, Y, W) {
    if (!(0, A0.IsDate)(W))
      return false;
    if (s($.exclusiveMaximumTimestamp) && !(W.getTime() < $.exclusiveMaximumTimestamp))
      return false;
    if (s($.exclusiveMinimumTimestamp) && !(W.getTime() > $.exclusiveMinimumTimestamp))
      return false;
    if (s($.maximumTimestamp) && !(W.getTime() <= $.maximumTimestamp))
      return false;
    if (s($.minimumTimestamp) && !(W.getTime() >= $.minimumTimestamp))
      return false;
    if (s($.multipleOfTimestamp) && W.getTime() % $.multipleOfTimestamp !== 0)
      return false;
    return true;
  }, j4 = function($, Y, W) {
    return (0, A0.IsFunction)(W);
  }, P4 = function($, Y, W) {
    if (!(0, A0.IsInteger)(W))
      return false;
    if (s($.exclusiveMaximum) && !(W < $.exclusiveMaximum))
      return false;
    if (s($.exclusiveMinimum) && !(W > $.exclusiveMinimum))
      return false;
    if (s($.maximum) && !(W <= $.maximum))
      return false;
    if (s($.minimum) && !(W >= $.minimum))
      return false;
    if (s($.multipleOf) && W % $.multipleOf !== 0)
      return false;
    return true;
  }, O4 = function($, Y, W) {
    const X = $.allOf.every((Z) => I0(Z, Y, W));
    if ($.unevaluatedProperties === false) {
      const Z = new RegExp(C0.KeyResolver.ResolvePattern($)), Q = Object.getOwnPropertyNames(W).every((J) => Z.test(J));
      return X && Q;
    } else if (C0.TypeGuard.TSchema($.unevaluatedProperties)) {
      const Z = new RegExp(C0.KeyResolver.ResolvePattern($)), Q = Object.getOwnPropertyNames(W).every((J) => Z.test(J) || I0($.unevaluatedProperties, Y, W[J]));
      return X && Q;
    } else
      return X;
  }, S4 = function($, Y, W) {
    return (0, A0.IsIterator)(W);
  }, L4 = function($, Y, W) {
    return W === $.const;
  }, C4 = function($, Y, W) {
    return false;
  }, I4 = function($, Y, W) {
    return !I0($.not, Y, W);
  }, b4 = function($, Y, W) {
    return (0, A0.IsNull)(W);
  }, G4 = function($, Y, W) {
    if (!Z$.TypeSystemPolicy.IsNumberLike(W))
      return false;
    if (s($.exclusiveMaximum) && !(W < $.exclusiveMaximum))
      return false;
    if (s($.exclusiveMinimum) && !(W > $.exclusiveMinimum))
      return false;
    if (s($.minimum) && !(W >= $.minimum))
      return false;
    if (s($.maximum) && !(W <= $.maximum))
      return false;
    if (s($.multipleOf) && W % $.multipleOf !== 0)
      return false;
    return true;
  }, R4 = function($, Y, W) {
    if (!Z$.TypeSystemPolicy.IsObjectLike(W))
      return false;
    if (s($.minProperties) && !(Object.getOwnPropertyNames(W).length >= $.minProperties))
      return false;
    if (s($.maxProperties) && !(Object.getOwnPropertyNames(W).length <= $.maxProperties))
      return false;
    const X = Object.getOwnPropertyNames($.properties);
    for (let Z of X) {
      const Q = $.properties[Z];
      if ($.required && $.required.includes(Z)) {
        if (!I0(Q, Y, W[Z]))
          return false;
        if ((C0.ExtendsUndefined.Check(Q) || N4(Q)) && !(Z in W))
          return false;
      } else if (Z$.TypeSystemPolicy.IsExactOptionalProperty(W, Z) && !I0(Q, Y, W[Z]))
        return false;
    }
    if ($.additionalProperties === false) {
      const Z = Object.getOwnPropertyNames(W);
      if ($.required && $.required.length === X.length && Z.length === X.length)
        return true;
      else
        return Z.every((Q) => X.includes(Q));
    } else if (typeof $.additionalProperties === "object")
      return Object.getOwnPropertyNames(W).every((Q) => X.includes(Q) || I0($.additionalProperties, Y, W[Q]));
    else
      return true;
  }, _4 = function($, Y, W) {
    return (0, A0.IsPromise)(W);
  }, E4 = function($, Y, W) {
    if (!Z$.TypeSystemPolicy.IsRecordLike(W))
      return false;
    if (s($.minProperties) && !(Object.getOwnPropertyNames(W).length >= $.minProperties))
      return false;
    if (s($.maxProperties) && !(Object.getOwnPropertyNames(W).length <= $.maxProperties))
      return false;
    const [X, Z] = Object.entries($.patternProperties)[0], Q = new RegExp(X), J = Object.entries(W).every(([D, B]) => {
      return Q.test(D) ? I0(Z, Y, B) : true;
    }), z = typeof $.additionalProperties === "object" ? Object.entries(W).every(([D, B]) => {
      return !Q.test(D) ? I0($.additionalProperties, Y, B) : true;
    }) : true, U = $.additionalProperties === false ? Object.getOwnPropertyNames(W).every((D) => {
      return Q.test(D);
    }) : true;
    return J && z && U;
  }, V4 = function($, Y, W) {
    return I0((0, LY.Deref)($, Y), Y, W);
  }, x4 = function($, Y, W) {
    if (!(0, A0.IsString)(W))
      return false;
    if (s($.minLength)) {
      if (!(W.length >= $.minLength))
        return false;
    }
    if (s($.maxLength)) {
      if (!(W.length <= $.maxLength))
        return false;
    }
    if (s($.pattern)) {
      if (!new RegExp($.pattern).test(W))
        return false;
    }
    if (s($.format)) {
      if (!C0.FormatRegistry.Has($.format))
        return false;
      return C0.FormatRegistry.Get($.format)(W);
    }
    return true;
  }, k4 = function($, Y, W) {
    return (0, A0.IsSymbol)(W);
  }, g4 = function($, Y, W) {
    return (0, A0.IsString)(W) && new RegExp($.pattern).test(W);
  }, f4 = function($, Y, W) {
    return I0((0, LY.Deref)($, Y), Y, W);
  }, T4 = function($, Y, W) {
    if (!(0, A0.IsArray)(W))
      return false;
    if ($.items === undefined && W.length !== 0)
      return false;
    if (W.length !== $.maxItems)
      return false;
    if (!$.items)
      return true;
    for (let X = 0;X < $.items.length; X++)
      if (!I0($.items[X], Y, W[X]))
        return false;
    return true;
  }, d4 = function($, Y, W) {
    return (0, A0.IsUndefined)(W);
  }, y4 = function($, Y, W) {
    return $.anyOf.some((X) => I0(X, Y, W));
  }, v4 = function($, Y, W) {
    if (!(0, A0.IsUint8Array)(W))
      return false;
    if (s($.maxByteLength) && !(W.length <= $.maxByteLength))
      return false;
    if (s($.minByteLength) && !(W.length >= $.minByteLength))
      return false;
    return true;
  }, p4 = function($, Y, W) {
    return true;
  }, i4 = function($, Y, W) {
    return Z$.TypeSystemPolicy.IsVoidLike(W);
  }, m4 = function($, Y, W) {
    if (!C0.TypeRegistry.Has($[C0.Kind]))
      return false;
    return C0.TypeRegistry.Get($[C0.Kind])($, W);
  }, I0 = function($, Y, W) {
    const X = s($.$id) ? [...Y, $] : Y, Z = $;
    switch (Z[C0.Kind]) {
      case "Any":
        return F4(Z, X, W);
      case "Array":
        return U4(Z, X, W);
      case "AsyncIterator":
        return A4(Z, X, W);
      case "BigInt":
        return B4(Z, X, W);
      case "Boolean":
        return D4(Z, X, W);
      case "Constructor":
        return w4(Z, X, W);
      case "Date":
        return K4(Z, X, W);
      case "Function":
        return j4(Z, X, W);
      case "Integer":
        return P4(Z, X, W);
      case "Intersect":
        return O4(Z, X, W);
      case "Iterator":
        return S4(Z, X, W);
      case "Literal":
        return L4(Z, X, W);
      case "Never":
        return C4(Z, X, W);
      case "Not":
        return I4(Z, X, W);
      case "Null":
        return b4(Z, X, W);
      case "Number":
        return G4(Z, X, W);
      case "Object":
        return R4(Z, X, W);
      case "Promise":
        return _4(Z, X, W);
      case "Record":
        return E4(Z, X, W);
      case "Ref":
        return V4(Z, X, W);
      case "String":
        return x4(Z, X, W);
      case "Symbol":
        return k4(Z, X, W);
      case "TemplateLiteral":
        return g4(Z, X, W);
      case "This":
        return f4(Z, X, W);
      case "Tuple":
        return T4(Z, X, W);
      case "Undefined":
        return d4(Z, X, W);
      case "Union":
        return y4(Z, X, W);
      case "Uint8Array":
        return v4(Z, X, W);
      case "Unknown":
        return p4(Z, X, W);
      case "Void":
        return i4(Z, X, W);
      default:
        if (!C0.TypeRegistry.Has(Z[C0.Kind]))
          throw new T8(Z);
        return m4(Z, X, W);
    }
  }, u4 = function(...$) {
    return $.length === 3 ? I0($[0], $[1], $[2]) : I0($[0], [], $[1]);
  };
  Object.defineProperty(CY, "__esModule", { value: true });
  CY.Check = CY.ValueCheckUnknownTypeError = undefined;
  var A0 = x0(), Z$ = E$(), LY = D1(), M4 = Y$(), C0 = f0();

  class T8 extends C0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  CY.ValueCheckUnknownTypeError = T8;
  CY.Check = u4;
});
var u8 = J0((_Y) => {
  var n4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return {};
  }, c4 = function($, Y) {
    if ($.uniqueItems === true && !(0, a.HasPropertyKey)($, "default"))
      throw new Error("ValueCreate.Array: Array with the uniqueItems constraint requires a default value");
    else if ("contains" in $ && !(0, a.HasPropertyKey)($, "default"))
      throw new Error("ValueCreate.Array: Array with the contains constraint requires a default value");
    else if ("default" in $)
      return $.default;
    else if ($.minItems !== undefined)
      return Array.from({ length: $.minItems }).map((W) => {
        return y0($.items, Y);
      });
    else
      return [];
  }, l4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return async function* () {
      }();
  }, t4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return BigInt(0);
  }, s4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return false;
  }, r4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const W = y0($.returns, Y);
      if (typeof W === "object" && !Array.isArray(W))
        return class {
          constructor() {
            for (let [X, Z] of Object.entries(W)) {
              const Q = this;
              Q[X] = Z;
            }
          }
        };
      else
        return class {
        };
    }
  }, a4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimumTimestamp !== undefined)
      return new Date($.minimumTimestamp);
    else
      return new Date(0);
  }, e4 = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return () => y0($.returns, Y);
  }, $J = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimum !== undefined)
      return $.minimum;
    else
      return 0;
  }, YJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const W = $.allOf.reduce((X, Z) => {
        const Q = y0(Z, Y);
        return typeof Q === "object" ? { ...X, ...Q } : Q;
      }, {});
      if (!(0, o4.Check)($, Y, W))
        throw new p8($);
      return W;
    }
  }, WJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return function* () {
      }();
  }, XJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return $.const;
  }, ZJ = function($, Y) {
    throw new y8($);
  }, QJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      throw new v8($);
  }, JJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return null;
  }, zJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimum !== undefined)
      return $.minimum;
    else
      return 0;
  }, HJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const W = new Set($.required);
      return $.default || Object.entries($.properties).reduce((X, [Z, Q]) => {
        return W.has(Z) ? { ...X, [Z]: y0(Q, Y) } : { ...X };
      }, {});
    }
  }, qJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return Promise.resolve(y0($.item, Y));
  }, MJ = function($, Y) {
    const [W, X] = Object.entries($.patternProperties)[0];
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if (!(W === k0.PatternStringExact || W === k0.PatternNumberExact))
      return W.slice(1, W.length - 1).split("|").reduce((Q, J) => {
        return { ...Q, [J]: y0(X, Y) };
      }, {});
    else
      return {};
  }, NJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return y0((0, GY.Deref)($, Y), Y);
  }, FJ = function($, Y) {
    if ($.pattern !== undefined)
      if (!(0, a.HasPropertyKey)($, "default"))
        throw new Error("ValueCreate.String: String types with patterns must specify a default value");
      else
        return $.default;
    else if ($.format !== undefined)
      if (!(0, a.HasPropertyKey)($, "default"))
        throw new Error("ValueCreate.String: String types with formats must specify a default value");
      else
        return $.default;
    else if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minLength !== undefined)
      return Array.from({ length: $.minLength }).map(() => ".").join("");
    else
      return "";
  }, UJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ("value" in $)
      return Symbol.for($.value);
    else
      return Symbol();
  }, AJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    const W = k0.TemplateLiteralParser.ParseExact($.pattern);
    if (!k0.TemplateLiteralFinite.Check(W))
      throw new i8($);
    return k0.TemplateLiteralGenerator.Generate(W).next().value;
  }, BJ = function($, Y) {
    if (RY++ > bY)
      throw new m8($, bY);
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return y0((0, GY.Deref)($, Y), Y);
  }, DJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    if ($.items === undefined)
      return [];
    else
      return Array.from({ length: $.minItems }).map((W, X) => y0($.items[X], Y));
  }, wJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return;
  }, KJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.anyOf.length === 0)
      throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
    else
      return y0($.anyOf[0], Y);
  }, jJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minByteLength !== undefined)
      return new Uint8Array($.minByteLength);
    else
      return new Uint8Array(0);
  }, PJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return {};
  }, OJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      return;
  }, SJ = function($, Y) {
    if ((0, a.HasPropertyKey)($, "default"))
      return $.default;
    else
      throw new Error("User defined types must specify a default value");
  }, y0 = function($, Y) {
    const W = (0, a.IsString)($.$id) ? [...Y, $] : Y, X = $;
    switch (X[k0.Kind]) {
      case "Any":
        return n4(X, W);
      case "Array":
        return c4(X, W);
      case "AsyncIterator":
        return l4(X, W);
      case "BigInt":
        return t4(X, W);
      case "Boolean":
        return s4(X, W);
      case "Constructor":
        return r4(X, W);
      case "Date":
        return a4(X, W);
      case "Function":
        return e4(X, W);
      case "Integer":
        return $J(X, W);
      case "Intersect":
        return YJ(X, W);
      case "Iterator":
        return WJ(X, W);
      case "Literal":
        return XJ(X, W);
      case "Never":
        return ZJ(X, W);
      case "Not":
        return QJ(X, W);
      case "Null":
        return JJ(X, W);
      case "Number":
        return zJ(X, W);
      case "Object":
        return HJ(X, W);
      case "Promise":
        return qJ(X, W);
      case "Record":
        return MJ(X, W);
      case "Ref":
        return NJ(X, W);
      case "String":
        return FJ(X, W);
      case "Symbol":
        return UJ(X, W);
      case "TemplateLiteral":
        return AJ(X, W);
      case "This":
        return BJ(X, W);
      case "Tuple":
        return DJ(X, W);
      case "Undefined":
        return wJ(X, W);
      case "Union":
        return KJ(X, W);
      case "Uint8Array":
        return jJ(X, W);
      case "Unknown":
        return PJ(X, W);
      case "Void":
        return OJ(X, W);
      default:
        if (!k0.TypeRegistry.Has(X[k0.Kind]))
          throw new d8(X);
        return SJ(X, W);
    }
  }, LJ = function(...$) {
    return RY = 0, $.length === 2 ? y0($[0], $[1]) : y0($[0], []);
  };
  Object.defineProperty(_Y, "__esModule", { value: true });
  _Y.Create = _Y.ValueCreateRecursiveInstantiationError = _Y.ValueCreateTempateLiteralTypeError = _Y.ValueCreateIntersectTypeError = _Y.ValueCreateNotTypeError = _Y.ValueCreateNeverTypeError = _Y.ValueCreateUnknownTypeError = undefined;
  var a = x0(), o4 = Q$(), GY = D1(), k0 = f0();

  class d8 extends k0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  _Y.ValueCreateUnknownTypeError = d8;

  class y8 extends k0.TypeBoxError {
    constructor($) {
      super("Never types cannot be created");
      this.schema = $;
    }
  }
  _Y.ValueCreateNeverTypeError = y8;

  class v8 extends k0.TypeBoxError {
    constructor($) {
      super("Not types must have a default value");
      this.schema = $;
    }
  }
  _Y.ValueCreateNotTypeError = v8;

  class p8 extends k0.TypeBoxError {
    constructor($) {
      super("Intersect produced invalid value. Consider using a default value.");
      this.schema = $;
    }
  }
  _Y.ValueCreateIntersectTypeError = p8;

  class i8 extends k0.TypeBoxError {
    constructor($) {
      super("Can only create template literal values from patterns that produce finite sequences. Consider using a default value.");
      this.schema = $;
    }
  }
  _Y.ValueCreateTempateLiteralTypeError = i8;

  class m8 extends k0.TypeBoxError {
    constructor($, Y) {
      super("Value cannot be created as recursive type may produce value of infinite size. Consider using a default.");
      this.schema = $, this.recursiveMaxDepth = Y;
    }
  }
  _Y.ValueCreateRecursiveInstantiationError = m8;
  var bY = 512, RY = 0;
  _Y.Create = LJ;
});
var dY = J0((fY) => {
  var kY = function($, Y, W) {
    return (0, m0.Check)($, Y, W) ? (0, u1.Clone)(W) : (0, N1.Create)($, Y);
  }, o8 = function($, Y, W) {
    return (0, m0.Check)($, Y, W) ? W : (0, N1.Create)($, Y);
  }, EJ = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return (0, u1.Clone)(W);
    const X = (0, w1.IsArray)(W) ? (0, u1.Clone)(W) : (0, N1.Create)($, Y), Z = (0, w1.IsNumber)($.minItems) && X.length < $.minItems ? [...X, ...Array.from({ length: $.minItems - X.length }, () => null)] : X, J = ((0, w1.IsNumber)($.maxItems) && Z.length > $.maxItems ? Z.slice(0, $.maxItems) : Z).map((U) => Y1($.items, Y, U));
    if ($.uniqueItems !== true)
      return J;
    const z = [...new Set(J)];
    if (!(0, m0.Check)($, Y, z))
      throw new n8($, z);
    return z;
  }, VJ = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return (0, N1.Create)($, Y);
    const X = new Set($.returns.required || []), Z = function() {
    };
    for (let [Q, J] of Object.entries($.returns.properties)) {
      if (!X.has(Q) && W.prototype[Q] === undefined)
        continue;
      Z.prototype[Q] = Y1(J, Y, W.prototype[Q]);
    }
    return Z;
  }, xJ = function($, Y, W) {
    const X = (0, N1.Create)($, Y), Z = (0, w1.IsPlainObject)(X) && (0, w1.IsPlainObject)(W) ? { ...X, ...W } : W;
    return (0, m0.Check)($, Y, Z) ? Z : (0, N1.Create)($, Y);
  }, kJ = function($, Y, W) {
    throw new c8($);
  }, gJ = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return W;
    if (W === null || typeof W !== "object")
      return (0, N1.Create)($, Y);
    const X = new Set($.required || []), Z = {};
    for (let [Q, J] of Object.entries($.properties)) {
      if (!X.has(Q) && W[Q] === undefined)
        continue;
      Z[Q] = Y1(J, Y, W[Q]);
    }
    if (typeof $.additionalProperties === "object") {
      const Q = Object.getOwnPropertyNames($.properties);
      for (let J of Object.getOwnPropertyNames(W)) {
        if (Q.includes(J))
          continue;
        Z[J] = Y1($.additionalProperties, Y, W[J]);
      }
    }
    return Z;
  }, fJ = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return (0, u1.Clone)(W);
    if (W === null || typeof W !== "object" || Array.isArray(W) || W instanceof Date)
      return (0, N1.Create)($, Y);
    const X = Object.getOwnPropertyNames($.patternProperties)[0], Z = $.patternProperties[X], Q = {};
    for (let [J, z] of Object.entries(W))
      Q[J] = Y1(Z, Y, z);
    return Q;
  }, TJ = function($, Y, W) {
    return Y1((0, VY.Deref)($, Y), Y, W);
  }, dJ = function($, Y, W) {
    return Y1((0, VY.Deref)($, Y), Y, W);
  }, yJ = function($, Y, W) {
    if ((0, m0.Check)($, Y, W))
      return (0, u1.Clone)(W);
    if (!(0, w1.IsArray)(W))
      return (0, N1.Create)($, Y);
    if ($.items === undefined)
      return [];
    return $.items.map((X, Z) => Y1(X, Y, W[Z]));
  }, vJ = function($, Y, W) {
    return (0, m0.Check)($, Y, W) ? (0, u1.Clone)(W) : h8.Create($, Y, W);
  }, Y1 = function($, Y, W) {
    const X = (0, w1.IsString)($.$id) ? [...Y, $] : Y, Z = $;
    switch ($[M1.Kind]) {
      case "Array":
        return EJ(Z, X, W);
      case "Constructor":
        return VJ(Z, X, W);
      case "Intersect":
        return xJ(Z, X, W);
      case "Never":
        return kJ(Z, X, W);
      case "Object":
        return gJ(Z, X, W);
      case "Record":
        return fJ(Z, X, W);
      case "Ref":
        return TJ(Z, X, W);
      case "This":
        return dJ(Z, X, W);
      case "Tuple":
        return yJ(Z, X, W);
      case "Union":
        return vJ(Z, X, W);
      case "Date":
      case "Symbol":
      case "Uint8Array":
        return kY($, Y, W);
      case "Any":
      case "AsyncIterator":
      case "BigInt":
      case "Boolean":
      case "Function":
      case "Integer":
      case "Iterator":
      case "Literal":
      case "Not":
      case "Null":
      case "Number":
      case "Promise":
      case "String":
      case "TemplateLiteral":
      case "Undefined":
      case "Unknown":
      case "Void":
        return o8(Z, X, W);
      default:
        if (!M1.TypeRegistry.Has(Z[M1.Kind]))
          throw new l8(Z);
        return o8(Z, X, W);
    }
  }, gY = function(...$) {
    return $.length === 3 ? Y1($[0], $[1], $[2]) : Y1($[0], [], $[1]);
  };
  Object.defineProperty(fY, "__esModule", { value: true });
  fY.Cast = fY.Default = fY.DefaultClone = fY.ValueCastUnknownTypeError = fY.ValueCastRecursiveTypeError = fY.ValueCastNeverTypeError = fY.ValueCastArrayUniqueItemsTypeError = undefined;
  var w1 = x0(), N1 = u8(), m0 = Q$(), u1 = i1(), VY = D1(), M1 = f0();

  class n8 extends M1.TypeBoxError {
    constructor($, Y) {
      super("Array cast produced invalid data due to uniqueItems constraint");
      this.schema = $, this.value = Y;
    }
  }
  fY.ValueCastArrayUniqueItemsTypeError = n8;

  class c8 extends M1.TypeBoxError {
    constructor($) {
      super("Never types cannot be cast");
      this.schema = $;
    }
  }
  fY.ValueCastNeverTypeError = c8;

  class xY extends M1.TypeBoxError {
    constructor($) {
      super("Cannot cast recursive schemas");
      this.schema = $;
    }
  }
  fY.ValueCastRecursiveTypeError = xY;

  class l8 extends M1.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  fY.ValueCastUnknownTypeError = l8;
  var h8;
  (function($) {
    function Y(Z, Q, J) {
      if (Z[M1.Kind] === "Object" && typeof J === "object" && !(0, w1.IsNull)(J)) {
        const z = Z, U = Object.getOwnPropertyNames(J), D = Object.entries(z.properties), [B, j] = [1 / D.length, D.length];
        return D.reduce((b, [S, N]) => {
          const O = N[M1.Kind] === "Literal" && N.const === J[S] ? j : 0, P = (0, m0.Check)(N, Q, J[S]) ? B : 0, F = U.includes(S) ? B : 0;
          return b + (O + P + F);
        }, 0);
      } else
        return (0, m0.Check)(Z, Q, J) ? 1 : 0;
    }
    function W(Z, Q, J) {
      let [z, U] = [Z.anyOf[0], 0];
      for (let D of Z.anyOf) {
        const B = Y(D, Q, J);
        if (B > U)
          z = D, U = B;
      }
      return z;
    }
    function X(Z, Q, J) {
      if ("default" in Z)
        return Z.default;
      else {
        const z = W(Z, Q, J);
        return gY(z, Q, J);
      }
    }
    $.Create = X;
  })(h8 || (h8 = {}));
  fY.DefaultClone = kY;
  fY.Default = o8;
  fY.Cast = gY;
});
var hY = J0((mY) => {
  var V$ = function($) {
    return (0, Z0.IsString)($) && !isNaN($) && !isNaN(parseFloat($));
  }, lJ = function($) {
    return (0, Z0.IsBigInt)($) || (0, Z0.IsBoolean)($) || (0, Z0.IsNumber)($);
  }, J$ = function($) {
    return $ === true || (0, Z0.IsNumber)($) && $ === 1 || (0, Z0.IsBigInt)($) && $ === BigInt("1") || (0, Z0.IsString)($) && ($.toLowerCase() === "true" || $ === "1");
  }, z$ = function($) {
    return $ === false || (0, Z0.IsNumber)($) && ($ === 0 || Object.is($, -0)) || (0, Z0.IsBigInt)($) && $ === BigInt("0") || (0, Z0.IsString)($) && ($.toLowerCase() === "false" || $ === "0" || $ === "-0");
  }, tJ = function($) {
    return (0, Z0.IsString)($) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test($);
  }, sJ = function($) {
    return (0, Z0.IsString)($) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test($);
  }, rJ = function($) {
    return (0, Z0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test($);
  }, aJ = function($) {
    return (0, Z0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test($);
  }, eJ = function($) {
    return (0, Z0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test($);
  }, $9 = function($, Y) {
    const W = pY($);
    return W === Y ? W : $;
  }, Y9 = function($, Y) {
    const W = iY($);
    return W === Y ? W : $;
  }, W9 = function($, Y) {
    const W = vY($);
    return W === Y ? W : $;
  }, X9 = function($, Y) {
    if (typeof $.const === "string")
      return $9(Y, $.const);
    else if (typeof $.const === "number")
      return Y9(Y, $.const);
    else if (typeof $.const === "boolean")
      return W9(Y, $.const);
    else
      return (0, nJ.Clone)(Y);
  }, vY = function($) {
    return J$($) ? true : z$($) ? false : $;
  }, Z9 = function($) {
    return V$($) ? BigInt(parseInt($)) : (0, Z0.IsNumber)($) ? BigInt($ | 0) : z$($) ? BigInt(0) : J$($) ? BigInt(1) : $;
  }, pY = function($) {
    return lJ($) ? $.toString() : (0, Z0.IsSymbol)($) && $.description !== undefined ? $.description.toString() : $;
  }, iY = function($) {
    return V$($) ? parseFloat($) : J$($) ? 1 : z$($) ? 0 : $;
  }, Q9 = function($) {
    return V$($) ? parseInt($) : (0, Z0.IsNumber)($) ? $ | 0 : J$($) ? 1 : z$($) ? 0 : $;
  }, J9 = function($) {
    return (0, Z0.IsString)($) && $.toLowerCase() === "null" ? null : $;
  }, z9 = function($) {
    return (0, Z0.IsString)($) && $ === "undefined" ? undefined : $;
  }, H9 = function($) {
    return (0, Z0.IsDate)($) ? $ : (0, Z0.IsNumber)($) ? new Date($) : J$($) ? new Date(1) : z$($) ? new Date(0) : V$($) ? new Date(parseInt($)) : sJ($) ? new Date(`1970-01-01T${$}.000Z`) : tJ($) ? new Date(`1970-01-01T${$}`) : aJ($) ? new Date(`${$}.000Z`) : rJ($) ? new Date($) : eJ($) ? new Date(`${$}T00:00:00.000Z`) : $;
  }, t8 = function($) {
    return $;
  }, q9 = function($, Y, W) {
    if ((0, Z0.IsArray)(W))
      return W.map((X) => n0($.items, Y, X));
    return W;
  }, M9 = function($, Y, W) {
    return Z9(W);
  }, N9 = function($, Y, W) {
    return vY(W);
  }, F9 = function($, Y, W) {
    return H9(W);
  }, U9 = function($, Y, W) {
    return Q9(W);
  }, A9 = function($, Y, W) {
    return $.allOf.every((X) => h1.TypeGuard.TObject(X)) ? n0(h1.Type.Composite($.allOf), Y, W) : n0($.allOf[0], Y, W);
  }, B9 = function($, Y, W) {
    return X9($, W);
  }, D9 = function($, Y, W) {
    return J9(W);
  }, w9 = function($, Y, W) {
    return iY(W);
  }, K9 = function($, Y, W) {
    if ((0, Z0.IsObject)(W))
      return Object.getOwnPropertyNames($.properties).reduce((X, Z) => {
        return W[Z] !== undefined ? { ...X, [Z]: n0($.properties[Z], Y, W[Z]) } : { ...X };
      }, W);
    return W;
  }, j9 = function($, Y, W) {
    const X = Object.getOwnPropertyNames($.patternProperties)[0], Z = $.patternProperties[X], Q = {};
    for (let [J, z] of Object.entries(W))
      Q[J] = n0(Z, Y, z);
    return Q;
  }, P9 = function($, Y, W) {
    return n0((0, yY.Deref)($, Y), Y, W);
  }, O9 = function($, Y, W) {
    return pY(W);
  }, S9 = function($, Y, W) {
    return (0, Z0.IsString)(W) || (0, Z0.IsNumber)(W) ? Symbol(W) : W;
  }, L9 = function($, Y, W) {
    return n0((0, yY.Deref)($, Y), Y, W);
  }, C9 = function($, Y, W) {
    if ((0, Z0.IsArray)(W) && !(0, Z0.IsUndefined)($.items))
      return W.map((X, Z) => {
        return Z < $.items.length ? n0($.items[Z], Y, X) : X;
      });
    return W;
  }, I9 = function($, Y, W) {
    return z9(W);
  }, b9 = function($, Y, W) {
    for (let X of $.anyOf) {
      const Z = n0(X, Y, W);
      if ((0, cJ.Check)(X, Y, Z))
        return Z;
    }
    return W;
  }, n0 = function($, Y, W) {
    const X = (0, Z0.IsString)($.$id) ? [...Y, $] : Y, Z = $;
    switch ($[h1.Kind]) {
      case "Array":
        return q9(Z, X, W);
      case "BigInt":
        return M9(Z, X, W);
      case "Boolean":
        return N9(Z, X, W);
      case "Date":
        return F9(Z, X, W);
      case "Integer":
        return U9(Z, X, W);
      case "Intersect":
        return A9(Z, X, W);
      case "Literal":
        return B9(Z, X, W);
      case "Null":
        return D9(Z, X, W);
      case "Number":
        return w9(Z, X, W);
      case "Object":
        return K9(Z, X, W);
      case "Record":
        return j9(Z, X, W);
      case "Ref":
        return P9(Z, X, W);
      case "String":
        return O9(Z, X, W);
      case "Symbol":
        return S9(Z, X, W);
      case "This":
        return L9(Z, X, W);
      case "Tuple":
        return C9(Z, X, W);
      case "Undefined":
        return I9(Z, X, W);
      case "Union":
        return b9(Z, X, W);
      case "Any":
      case "AsyncIterator":
      case "Constructor":
      case "Function":
      case "Iterator":
      case "Never":
      case "Promise":
      case "TemplateLiteral":
      case "Uint8Array":
      case "Unknown":
      case "Void":
        return t8(W);
      default:
        if (!h1.TypeRegistry.Has(Z[h1.Kind]))
          throw new s8(Z);
        return t8(W);
    }
  }, G9 = function(...$) {
    return $.length === 3 ? n0($[0], $[1], $[2]) : n0($[0], [], $[1]);
  };
  Object.defineProperty(mY, "__esModule", { value: true });
  mY.Convert = mY.Default = mY.ValueConvertUnknownTypeError = undefined;
  var Z0 = x0(), nJ = i1(), cJ = Q$(), yY = D1(), h1 = f0();

  class s8 extends h1.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  mY.ValueConvertUnknownTypeError = s8;
  mY.Default = t8;
  mY.Convert = G9;
});
var e8 = J0((sY) => {
  Object.defineProperty(sY, "__esModule", { value: true });
  sY.EncodeTransform = sY.DecodeTransform = sY.HasTransform = sY.TransformEncodeError = sY.TransformDecodeError = sY.TransformEncodeCheckError = sY.TransformDecodeCheckError = sY.TransformUnknownTypeError = undefined;
  var c0 = x0(), o1 = D1(), h = f0();

  class H$ extends h.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  sY.TransformUnknownTypeError = H$;

  class lY extends h.TypeBoxError {
    constructor($, Y, W) {
      super("Unable to decode due to invalid value");
      this.schema = $, this.value = Y, this.error = W;
    }
  }
  sY.TransformDecodeCheckError = lY;

  class tY extends h.TypeBoxError {
    constructor($, Y, W) {
      super("Unable to encode due to invalid value");
      this.schema = $, this.value = Y, this.error = W;
    }
  }
  sY.TransformEncodeCheckError = tY;

  class r8 extends h.TypeBoxError {
    constructor($, Y, W) {
      super(`${W instanceof Error ? W.message : "Unknown error"}`);
      this.schema = $, this.value = Y;
    }
  }
  sY.TransformDecodeError = r8;

  class a8 extends h.TypeBoxError {
    constructor($, Y, W) {
      super(`${W instanceof Error ? W.message : "Unknown error"}`);
      this.schema = $, this.value = Y;
    }
  }
  sY.TransformEncodeError = a8;
  var oY;
  (function($) {
    function Y(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.items, I);
    }
    function W(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.items, I);
    }
    function X(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.returns, I) || w.parameters.some((G) => O(G, I));
    }
    function Z(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.returns, I) || w.parameters.some((G) => O(G, I));
    }
    function Q(w, I) {
      return h.TypeGuard.TTransform(w) || h.TypeGuard.TTransform(w.unevaluatedProperties) || w.allOf.some((G) => O(G, I));
    }
    function J(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.items, I);
    }
    function z(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.not, I);
    }
    function U(w, I) {
      return h.TypeGuard.TTransform(w) || Object.values(w.properties).some((G) => O(G, I)) || h.TypeGuard.TSchema(w.additionalProperties) && O(w.additionalProperties, I);
    }
    function D(w, I) {
      return h.TypeGuard.TTransform(w) || O(w.item, I);
    }
    function B(w, I) {
      const G = Object.getOwnPropertyNames(w.patternProperties)[0], k = w.patternProperties[G];
      return h.TypeGuard.TTransform(w) || O(k, I) || h.TypeGuard.TSchema(w.additionalProperties) && h.TypeGuard.TTransform(w.additionalProperties);
    }
    function j(w, I) {
      if (h.TypeGuard.TTransform(w))
        return true;
      return O((0, o1.Deref)(w, I), I);
    }
    function b(w, I) {
      if (h.TypeGuard.TTransform(w))
        return true;
      return O((0, o1.Deref)(w, I), I);
    }
    function S(w, I) {
      return h.TypeGuard.TTransform(w) || h.TypeGuard.TSchema(w.items) && w.items.some((G) => O(G, I));
    }
    function N(w, I) {
      return h.TypeGuard.TTransform(w) || w.anyOf.some((G) => O(G, I));
    }
    function O(w, I) {
      const G = (0, c0.IsString)(w.$id) ? [...I, w] : I, k = w;
      if (w.$id && P.has(w.$id))
        return false;
      if (w.$id)
        P.add(w.$id);
      switch (w[h.Kind]) {
        case "Array":
          return Y(k, G);
        case "AsyncIterator":
          return W(k, G);
        case "Constructor":
          return X(k, G);
        case "Function":
          return Z(k, G);
        case "Intersect":
          return Q(k, G);
        case "Iterator":
          return J(k, G);
        case "Not":
          return z(k, G);
        case "Object":
          return U(k, G);
        case "Promise":
          return D(k, G);
        case "Record":
          return B(k, G);
        case "Ref":
          return j(k, G);
        case "This":
          return b(k, G);
        case "Tuple":
          return S(k, G);
        case "Union":
          return N(k, G);
        case "Any":
        case "BigInt":
        case "Boolean":
        case "Date":
        case "Integer":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "String":
        case "Symbol":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return h.TypeGuard.TTransform(w);
        default:
          if (!h.TypeRegistry.Has(k[h.Kind]))
            throw new H$(k);
          return h.TypeGuard.TTransform(w);
      }
    }
    const P = new Set;
    function F(w, I) {
      return P.clear(), O(w, I);
    }
    $.Has = F;
  })(oY || (sY.HasTransform = oY = {}));
  var nY;
  (function($) {
    function Y(N, O) {
      try {
        return h.TypeGuard.TTransform(N) ? N[h.Transform].Decode(O) : O;
      } catch (P) {
        throw new r8(N, O, P);
      }
    }
    function W(N, O, P) {
      const F = P.map((w) => j(N.items, O, w));
      return Y(N, F);
    }
    function X(N, O, P) {
      if (!(0, c0.IsPlainObject)(P) || (0, c0.IsValueType)(P))
        return Y(N, P);
      const F = h.KeyResolver.ResolveKeys(N, { includePatterns: false }), w = Object.entries(P).reduce((G, [k, _]) => {
        return !F.includes(k) ? { ...G, [k]: _ } : { ...G, [k]: Y(h.IndexedAccessor.Resolve(N, [k]), _) };
      }, {});
      if (!h.TypeGuard.TTransform(N.unevaluatedProperties))
        return Y(N, w);
      const I = Object.entries(w).reduce((G, [k, _]) => {
        return F.includes(k) ? { ...G, [k]: _ } : { ...G, [k]: Y(N.unevaluatedProperties, _) };
      }, {});
      return Y(N, I);
    }
    function Z(N, O, P) {
      const F = j(N.not, O, P);
      return Y(N, F);
    }
    function Q(N, O, P) {
      if (!(0, c0.IsPlainObject)(P))
        return Y(N, P);
      const F = Object.entries(P).reduce((G, [k, _]) => {
        return !(k in N.properties) ? { ...G, [k]: _ } : { ...G, [k]: j(N.properties[k], O, _) };
      }, {});
      if (!h.TypeGuard.TSchema(N.additionalProperties))
        return Y(N, F);
      const w = N.additionalProperties, I = Object.entries(F).reduce((G, [k, _]) => {
        return k in N.properties ? { ...G, [k]: _ } : { ...G, [k]: j(w, O, _) };
      }, {});
      return Y(N, I);
    }
    function J(N, O, P) {
      if (!(0, c0.IsPlainObject)(P))
        return Y(N, P);
      const F = Object.getOwnPropertyNames(N.patternProperties)[0], w = N.patternProperties[F], I = new RegExp(F), G = Object.entries(P).reduce((e, [o, r]) => {
        return !I.test(o) ? { ...e, [o]: r } : { ...e, [o]: j(w, O, r) };
      }, {});
      if (!h.TypeGuard.TSchema(N.additionalProperties))
        return Y(N, G);
      const k = N.additionalProperties, _ = Object.entries(G).reduce((e, [o, r]) => {
        return I.test(o) ? { ...e, [o]: r } : { ...e, [o]: j(k, O, r) };
      }, {});
      return Y(N, _);
    }
    function z(N, O, P) {
      const F = (0, o1.Deref)(N, O), w = j(F, O, P);
      return Y(N, w);
    }
    function U(N, O, P) {
      const F = (0, o1.Deref)(N, O), w = j(F, O, P);
      return Y(N, w);
    }
    function D(N, O, P) {
      const F = (0, c0.IsArray)(N.items) ? N.items.map((w, I) => j(w, O, P[I])) : [];
      return Y(N, F);
    }
    function B(N, O, P) {
      const F = Y(N, P);
      for (let w of N.anyOf) {
        if (!b(w, O, F))
          continue;
        return j(w, O, F);
      }
      return F;
    }
    function j(N, O, P) {
      const F = typeof N.$id === "string" ? [...O, N] : O, w = N;
      switch (N[h.Kind]) {
        case "Array":
          return W(w, F, P);
        case "Intersect":
          return X(w, F, P);
        case "Not":
          return Z(w, F, P);
        case "Object":
          return Q(w, F, P);
        case "Record":
          return J(w, F, P);
        case "Ref":
          return z(w, F, P);
        case "Symbol":
          return Y(w, P);
        case "This":
          return U(w, F, P);
        case "Tuple":
          return D(w, F, P);
        case "Union":
          return B(w, F, P);
        case "Any":
        case "AsyncIterator":
        case "BigInt":
        case "Boolean":
        case "Constructor":
        case "Date":
        case "Function":
        case "Integer":
        case "Iterator":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "Promise":
        case "String":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return Y(w, P);
        default:
          if (!h.TypeRegistry.Has(w[h.Kind]))
            throw new H$(w);
          return Y(w, P);
      }
    }
    let b = () => false;
    function S(N, O, P, F) {
      return b = F, j(N, O, P);
    }
    $.Decode = S;
  })(nY || (sY.DecodeTransform = nY = {}));
  var cY;
  (function($) {
    function Y(N, O) {
      try {
        return h.TypeGuard.TTransform(N) ? N[h.Transform].Encode(O) : O;
      } catch (P) {
        throw new a8(N, O, P);
      }
    }
    function W(N, O, P) {
      return Y(N, P).map((w) => j(N.items, O, w));
    }
    function X(N, O, P) {
      const F = Y(N, P);
      if (!(0, c0.IsPlainObject)(P) || (0, c0.IsValueType)(P))
        return F;
      const w = h.KeyResolver.ResolveKeys(N, { includePatterns: false }), I = Object.entries(F).reduce((G, [k, _]) => {
        return !w.includes(k) ? { ...G, [k]: _ } : { ...G, [k]: Y(h.IndexedAccessor.Resolve(N, [k]), _) };
      }, {});
      if (!h.TypeGuard.TTransform(N.unevaluatedProperties))
        return Y(N, I);
      return Object.entries(I).reduce((G, [k, _]) => {
        return w.includes(k) ? { ...G, [k]: _ } : { ...G, [k]: Y(N.unevaluatedProperties, _) };
      }, {});
    }
    function Z(N, O, P) {
      const F = Y(N, P);
      return Y(N.not, F);
    }
    function Q(N, O, P) {
      const F = Y(N, P);
      if (!(0, c0.IsPlainObject)(P))
        return F;
      const w = Object.entries(F).reduce((G, [k, _]) => {
        return !(k in N.properties) ? { ...G, [k]: _ } : { ...G, [k]: j(N.properties[k], O, _) };
      }, {});
      if (!h.TypeGuard.TSchema(N.additionalProperties))
        return w;
      const I = N.additionalProperties;
      return Object.entries(w).reduce((G, [k, _]) => {
        return k in N.properties ? { ...G, [k]: _ } : { ...G, [k]: j(I, O, _) };
      }, {});
    }
    function J(N, O, P) {
      const F = Y(N, P);
      if (!(0, c0.IsPlainObject)(P))
        return F;
      const w = Object.getOwnPropertyNames(N.patternProperties)[0], I = N.patternProperties[w], G = new RegExp(w), k = Object.entries(F).reduce((e, [o, r]) => {
        return !G.test(o) ? { ...e, [o]: r } : { ...e, [o]: j(I, O, r) };
      }, {});
      if (!h.TypeGuard.TSchema(N.additionalProperties))
        return Y(N, k);
      const _ = N.additionalProperties;
      return Object.entries(k).reduce((e, [o, r]) => {
        return G.test(o) ? { ...e, [o]: r } : { ...e, [o]: j(_, O, r) };
      }, {});
    }
    function z(N, O, P) {
      const F = (0, o1.Deref)(N, O), w = j(F, O, P);
      return Y(N, w);
    }
    function U(N, O, P) {
      const F = (0, o1.Deref)(N, O), w = j(F, O, P);
      return Y(N, w);
    }
    function D(N, O, P) {
      const F = Y(N, P);
      return (0, c0.IsArray)(N.items) ? N.items.map((w, I) => j(w, O, F[I])) : [];
    }
    function B(N, O, P) {
      for (let F of N.anyOf) {
        if (!b(F, O, P))
          continue;
        const w = j(F, O, P);
        return Y(N, w);
      }
      return Y(N, P);
    }
    function j(N, O, P) {
      const F = typeof N.$id === "string" ? [...O, N] : O, w = N;
      switch (N[h.Kind]) {
        case "Array":
          return W(w, F, P);
        case "Intersect":
          return X(w, F, P);
        case "Not":
          return Z(w, F, P);
        case "Object":
          return Q(w, F, P);
        case "Record":
          return J(w, F, P);
        case "Ref":
          return z(w, F, P);
        case "This":
          return U(w, F, P);
        case "Tuple":
          return D(w, F, P);
        case "Union":
          return B(w, F, P);
        case "Any":
        case "AsyncIterator":
        case "BigInt":
        case "Boolean":
        case "Constructor":
        case "Date":
        case "Function":
        case "Integer":
        case "Iterator":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "Promise":
        case "String":
        case "Symbol":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return Y(w, P);
        default:
          if (!h.TypeRegistry.Has(w[h.Kind]))
            throw new H$(w);
          return Y(w, P);
      }
    }
    let b = () => false;
    function S(N, O, P, F) {
      return b = F, j(N, O, P);
    }
    $.Encode = S;
  })(cY || (sY.EncodeTransform = cY = {}));
});
var JW = J0((ZW) => {
  Object.defineProperty(ZW, "__esModule", { value: true });
  ZW.Value = undefined;
  var aY = I$(), d9 = jY(), y9 = Y$(), v9 = SY(), eY = dY(), p9 = i1(), $W = hY(), YW = u8(), x$ = Q$(), WW = V8(), k$ = e8(), XW;
  (function($) {
    function Y(...N) {
      return eY.Cast.apply(eY, N);
    }
    $.Cast = Y;
    function W(...N) {
      return YW.Create.apply(YW, N);
    }
    $.Create = W;
    function X(...N) {
      return x$.Check.apply(x$, N);
    }
    $.Check = X;
    function Z(...N) {
      return $W.Convert.apply($W, N);
    }
    $.Convert = Z;
    function Q(N) {
      return p9.Clone(N);
    }
    $.Clone = Q;
    function J(...N) {
      const [O, P, F] = N.length === 3 ? [N[0], N[1], N[2]] : [N[0], [], N[1]];
      if (!X(O, P, F))
        throw new k$.TransformDecodeCheckError(O, F, U(O, P, F).First());
      return k$.DecodeTransform.Decode(O, P, F, x$.Check);
    }
    $.Decode = J;
    function z(...N) {
      const [O, P, F] = N.length === 3 ? [N[0], N[1], N[2]] : [N[0], [], N[1]], w = k$.EncodeTransform.Encode(O, P, F, x$.Check);
      if (!X(O, P, w))
        throw new k$.TransformEncodeCheckError(O, F, U(O, P, F).First());
      return w;
    }
    $.Encode = z;
    function U(...N) {
      return aY.Errors.apply(aY, N);
    }
    $.Errors = U;
    function D(N, O) {
      return v9.Equal(N, O);
    }
    $.Equal = D;
    function B(N, O) {
      return WW.Diff(N, O);
    }
    $.Diff = B;
    function j(N) {
      return y9.Hash(N);
    }
    $.Hash = j;
    function b(N, O) {
      return WW.Patch(N, O);
    }
    $.Patch = b;
    function S(N, O) {
      d9.Mutate(N, O);
    }
    $.Mutate = S;
  })(XW || (ZW.Value = XW = {}));
});
var $6 = J0((W1) => {
  Object.defineProperty(W1, "__esModule", { value: true });
  W1.Value = W1.ValuePointer = W1.Delete = W1.Update = W1.Insert = W1.Edit = W1.ValueErrorIterator = W1.ValueErrorType = undefined;
  var zW = I$();
  Object.defineProperty(W1, "ValueErrorType", { enumerable: true, get: function() {
    return zW.ValueErrorType;
  } });
  Object.defineProperty(W1, "ValueErrorIterator", { enumerable: true, get: function() {
    return zW.ValueErrorIterator;
  } });
  var g$ = V8();
  Object.defineProperty(W1, "Edit", { enumerable: true, get: function() {
    return g$.Edit;
  } });
  Object.defineProperty(W1, "Insert", { enumerable: true, get: function() {
    return g$.Insert;
  } });
  Object.defineProperty(W1, "Update", { enumerable: true, get: function() {
    return g$.Update;
  } });
  Object.defineProperty(W1, "Delete", { enumerable: true, get: function() {
    return g$.Delete;
  } });
  var i9 = b$();
  Object.defineProperty(W1, "ValuePointer", { enumerable: true, get: function() {
    return i9.ValuePointer;
  } });
  var m9 = JW();
  Object.defineProperty(W1, "Value", { enumerable: true, get: function() {
    return m9.Value;
  } });
});
var UW = J0((NW) => {
  Object.defineProperty(NW, "__esModule", { value: true });
  NW.TypeCompiler = NW.Policy = NW.TypeCompilerTypeGuardError = NW.TypeCompilerUnknownTypeError = NW.TypeCheck = undefined;
  var N$ = e8(), c = x0(), r9 = $$(), F$ = E$(), a9 = D1(), e9 = Y$(), F0 = f0();

  class Q6 {
    constructor($, Y, W, X) {
      this.schema = $, this.references = Y, this.checkFunc = W, this.code = X, this.hasTransform = N$.HasTransform.Has($, Y);
    }
    Code() {
      return this.code;
    }
    Errors($) {
      return (0, r9.Errors)(this.schema, this.references, $);
    }
    Check($) {
      return this.checkFunc($);
    }
    Decode($) {
      if (!this.checkFunc($))
        throw new N$.TransformDecodeCheckError(this.schema, $, this.Errors($).First());
      return this.hasTransform ? N$.DecodeTransform.Decode(this.schema, this.references, $, (Y, W, X) => this.Check(X)) : $;
    }
    Encode($) {
      const Y = this.hasTransform ? N$.EncodeTransform.Encode(this.schema, this.references, $, (W, X, Z) => this.Check(Z)) : $;
      if (!this.checkFunc(Y))
        throw new N$.TransformEncodeCheckError(this.schema, $, this.Errors($).First());
      return Y;
    }
  }
  NW.TypeCheck = Q6;
  var F1;
  (function($) {
    function Y(Q) {
      return Q === 36;
    }
    $.DollarSign = Y;
    function W(Q) {
      return Q === 95;
    }
    $.IsUnderscore = W;
    function X(Q) {
      return Q >= 65 && Q <= 90 || Q >= 97 && Q <= 122;
    }
    $.IsAlpha = X;
    function Z(Q) {
      return Q >= 48 && Q <= 57;
    }
    $.IsNumeric = Z;
  })(F1 || (F1 = {}));
  var v$;
  (function($) {
    function Y(Q) {
      if (Q.length === 0)
        return false;
      return F1.IsNumeric(Q.charCodeAt(0));
    }
    function W(Q) {
      if (Y(Q))
        return false;
      for (let J = 0;J < Q.length; J++) {
        const z = Q.charCodeAt(J);
        if (!(F1.IsAlpha(z) || F1.IsNumeric(z) || F1.DollarSign(z) || F1.IsUnderscore(z)))
          return false;
      }
      return true;
    }
    function X(Q) {
      return Q.replace(/'/g, "\\'");
    }
    function Z(Q, J) {
      return W(J) ? `${Q}.${J}` : `${Q}['${X(J)}']`;
    }
    $.Encode = Z;
  })(v$ || (v$ = {}));
  var X6;
  (function($) {
    function Y(W) {
      const X = [];
      for (let Z = 0;Z < W.length; Z++) {
        const Q = W.charCodeAt(Z);
        if (F1.IsNumeric(Q) || F1.IsAlpha(Q))
          X.push(W.charAt(Z));
        else
          X.push(`_${Q}_`);
      }
      return X.join("").replace(/__/g, "_");
    }
    $.Encode = Y;
  })(X6 || (X6 = {}));
  var Z6;
  (function($) {
    function Y(W) {
      return W.replace(/'/g, "\\'");
    }
    $.Escape = Y;
  })(Z6 || (Z6 = {}));

  class J6 extends F0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  NW.TypeCompilerUnknownTypeError = J6;

  class p$ extends F0.TypeBoxError {
    constructor($) {
      super("Preflight validation check failed to guard for the given schema");
      this.schema = $;
    }
  }
  NW.TypeCompilerTypeGuardError = p$;
  var L1;
  (function($) {
    function Y(J, z, U) {
      return F$.TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${z}' in ${J} ? ${U} : true)` : `(${v$.Encode(J, z)} !== undefined ? ${U} : true)`;
    }
    $.IsExactOptionalProperty = Y;
    function W(J) {
      return !F$.TypeSystemPolicy.AllowArrayObject ? `(typeof ${J} === 'object' && ${J} !== null && !Array.isArray(${J}))` : `(typeof ${J} === 'object' && ${J} !== null)`;
    }
    $.IsObjectLike = W;
    function X(J) {
      return !F$.TypeSystemPolicy.AllowArrayObject ? `(typeof ${J} === 'object' && ${J} !== null && !Array.isArray(${J}) && !(${J} instanceof Date) && !(${J} instanceof Uint8Array))` : `(typeof ${J} === 'object' && ${J} !== null && !(${J} instanceof Date) && !(${J} instanceof Uint8Array))`;
    }
    $.IsRecordLike = X;
    function Z(J) {
      return !F$.TypeSystemPolicy.AllowNaN ? `(typeof ${J} === 'number' && Number.isFinite(${J}))` : `typeof ${J} === 'number'`;
    }
    $.IsNumberLike = Z;
    function Q(J) {
      return F$.TypeSystemPolicy.AllowNullVoid ? `(${J} === undefined || ${J} === null)` : `${J} === undefined`;
    }
    $.IsVoidLike = Q;
  })(L1 || (NW.Policy = L1 = {}));
  var MW;
  (function($) {
    function Y(K) {
      return K[F0.Kind] === "Any" || K[F0.Kind] === "Unknown";
    }
    function* W(K, E, L) {
      yield "true";
    }
    function* X(K, E, L) {
      yield `Array.isArray(${L})`;
      const [p, T] = [B0("value", "any"), B0("acc", "number")];
      if ((0, c.IsNumber)(K.maxItems))
        yield `${L}.length <= ${K.maxItems}`;
      if ((0, c.IsNumber)(K.minItems))
        yield `${L}.length >= ${K.minItems}`;
      const d = f(K.items, E, "value");
      if (yield `${L}.every((${p}) => ${d})`, F0.TypeGuard.TSchema(K.contains) || (0, c.IsNumber)(K.minContains) || (0, c.IsNumber)(K.maxContains)) {
        const W0 = F0.TypeGuard.TSchema(K.contains) ? K.contains : F0.Type.Never(), j0 = f(W0, E, "value"), X0 = (0, c.IsNumber)(K.minContains) ? [`(count >= ${K.minContains})`] : [], M = (0, c.IsNumber)(K.maxContains) ? [`(count <= ${K.maxContains})`] : [], l = `const count = value.reduce((${T}, ${p}) => ${j0} ? acc + 1 : acc, 0)`, S0 = ["(count > 0)", ...X0, ...M].join(" && ");
        yield `((${p}) => { ${l}; return ${S0}})(${L})`;
      }
      if (K.uniqueItems === true)
        yield `((${p}) => { const set = new Set(); for(const element of value) { const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true } )(${L})`;
    }
    function* Z(K, E, L) {
      yield `(typeof value === 'object' && Symbol.asyncIterator in ${L})`;
    }
    function* Q(K, E, L) {
      if (yield `(typeof ${L} === 'bigint')`, (0, c.IsBigInt)(K.exclusiveMaximum))
        yield `${L} < BigInt(${K.exclusiveMaximum})`;
      if ((0, c.IsBigInt)(K.exclusiveMinimum))
        yield `${L} > BigInt(${K.exclusiveMinimum})`;
      if ((0, c.IsBigInt)(K.maximum))
        yield `${L} <= BigInt(${K.maximum})`;
      if ((0, c.IsBigInt)(K.minimum))
        yield `${L} >= BigInt(${K.minimum})`;
      if ((0, c.IsBigInt)(K.multipleOf))
        yield `(${L} % BigInt(${K.multipleOf})) === 0`;
    }
    function* J(K, E, L) {
      yield `(typeof ${L} === 'boolean')`;
    }
    function* z(K, E, L) {
      yield* v0(K.returns, E, `${L}.prototype`);
    }
    function* U(K, E, L) {
      if (yield `(${L} instanceof Date) && Number.isFinite(${L}.getTime())`, (0, c.IsNumber)(K.exclusiveMaximumTimestamp))
        yield `${L}.getTime() < ${K.exclusiveMaximumTimestamp}`;
      if ((0, c.IsNumber)(K.exclusiveMinimumTimestamp))
        yield `${L}.getTime() > ${K.exclusiveMinimumTimestamp}`;
      if ((0, c.IsNumber)(K.maximumTimestamp))
        yield `${L}.getTime() <= ${K.maximumTimestamp}`;
      if ((0, c.IsNumber)(K.minimumTimestamp))
        yield `${L}.getTime() >= ${K.minimumTimestamp}`;
      if ((0, c.IsNumber)(K.multipleOfTimestamp))
        yield `(${L}.getTime() % ${K.multipleOfTimestamp}) === 0`;
    }
    function* D(K, E, L) {
      yield `(typeof ${L} === 'function')`;
    }
    function* B(K, E, L) {
      if (yield `(typeof ${L} === 'number' && Number.isInteger(${L}))`, (0, c.IsNumber)(K.exclusiveMaximum))
        yield `${L} < ${K.exclusiveMaximum}`;
      if ((0, c.IsNumber)(K.exclusiveMinimum))
        yield `${L} > ${K.exclusiveMinimum}`;
      if ((0, c.IsNumber)(K.maximum))
        yield `${L} <= ${K.maximum}`;
      if ((0, c.IsNumber)(K.minimum))
        yield `${L} >= ${K.minimum}`;
      if ((0, c.IsNumber)(K.multipleOf))
        yield `(${L} % ${K.multipleOf}) === 0`;
    }
    function* j(K, E, L) {
      const p = K.allOf.map((T) => f(T, E, L)).join(" && ");
      if (K.unevaluatedProperties === false) {
        const T = n(`${new RegExp(F0.KeyResolver.ResolvePattern(K))};`), d = `Object.getOwnPropertyNames(${L}).every(key => ${T}.test(key))`;
        yield `(${p} && ${d})`;
      } else if (F0.TypeGuard.TSchema(K.unevaluatedProperties)) {
        const T = n(`${new RegExp(F0.KeyResolver.ResolvePattern(K))};`), d = `Object.getOwnPropertyNames(${L}).every(key => ${T}.test(key) || ${f(K.unevaluatedProperties, E, `${L}[key]`)})`;
        yield `(${p} && ${d})`;
      } else
        yield `(${p})`;
    }
    function* b(K, E, L) {
      yield `(typeof value === 'object' && Symbol.iterator in ${L})`;
    }
    function* S(K, E, L) {
      if (typeof K.const === "number" || typeof K.const === "boolean")
        yield `(${L} === ${K.const})`;
      else
        yield `(${L} === '${Z6.Escape(K.const)}')`;
    }
    function* N(K, E, L) {
      yield "false";
    }
    function* O(K, E, L) {
      yield `(!${f(K.not, E, L)})`;
    }
    function* P(K, E, L) {
      yield `(${L} === null)`;
    }
    function* F(K, E, L) {
      if (yield L1.IsNumberLike(L), (0, c.IsNumber)(K.exclusiveMaximum))
        yield `${L} < ${K.exclusiveMaximum}`;
      if ((0, c.IsNumber)(K.exclusiveMinimum))
        yield `${L} > ${K.exclusiveMinimum}`;
      if ((0, c.IsNumber)(K.maximum))
        yield `${L} <= ${K.maximum}`;
      if ((0, c.IsNumber)(K.minimum))
        yield `${L} >= ${K.minimum}`;
      if ((0, c.IsNumber)(K.multipleOf))
        yield `(${L} % ${K.multipleOf}) === 0`;
    }
    function* w(K, E, L) {
      if (yield L1.IsObjectLike(L), (0, c.IsNumber)(K.minProperties))
        yield `Object.getOwnPropertyNames(${L}).length >= ${K.minProperties}`;
      if ((0, c.IsNumber)(K.maxProperties))
        yield `Object.getOwnPropertyNames(${L}).length <= ${K.maxProperties}`;
      const p = Object.getOwnPropertyNames(K.properties);
      for (let T of p) {
        const d = v$.Encode(L, T), W0 = K.properties[T];
        if (K.required && K.required.includes(T)) {
          if (yield* v0(W0, E, d), F0.ExtendsUndefined.Check(W0) || Y(W0))
            yield `('${T}' in ${L})`;
        } else {
          const j0 = f(W0, E, d);
          yield L1.IsExactOptionalProperty(L, T, j0);
        }
      }
      if (K.additionalProperties === false)
        if (K.required && K.required.length === p.length)
          yield `Object.getOwnPropertyNames(${L}).length === ${p.length}`;
        else {
          const T = `[${p.map((d) => `'${d}'`).join(", ")}]`;
          yield `Object.getOwnPropertyNames(${L}).every(key => ${T}.includes(key))`;
        }
      if (typeof K.additionalProperties === "object") {
        const T = f(K.additionalProperties, E, `${L}[key]`), d = `[${p.map((W0) => `'${W0}'`).join(", ")}]`;
        yield `(Object.getOwnPropertyNames(${L}).every(key => ${d}.includes(key) || ${T}))`;
      }
    }
    function* I(K, E, L) {
      yield `(typeof value === 'object' && typeof ${L}.then === 'function')`;
    }
    function* G(K, E, L) {
      if (yield L1.IsRecordLike(L), (0, c.IsNumber)(K.minProperties))
        yield `Object.getOwnPropertyNames(${L}).length >= ${K.minProperties}`;
      if ((0, c.IsNumber)(K.maxProperties))
        yield `Object.getOwnPropertyNames(${L}).length <= ${K.maxProperties}`;
      const [p, T] = Object.entries(K.patternProperties)[0], d = n(`${new RegExp(p)}`), W0 = f(T, E, "value"), j0 = F0.TypeGuard.TSchema(K.additionalProperties) ? f(K.additionalProperties, E, L) : K.additionalProperties === false ? "false" : "true", X0 = `(${d}.test(key) ? ${W0} : ${j0})`;
      yield `(Object.entries(${L}).every(([key, value]) => ${X0}))`;
    }
    function* k(K, E, L) {
      const p = (0, a9.Deref)(K, E);
      if (R.functions.has(K.$ref))
        return yield `${i(K.$ref)}(${L})`;
      yield* v0(p, E, L);
    }
    function* _(K, E, L) {
      if (yield `(typeof ${L} === 'string')`, (0, c.IsNumber)(K.maxLength))
        yield `${L}.length <= ${K.maxLength}`;
      if ((0, c.IsNumber)(K.minLength))
        yield `${L}.length >= ${K.minLength}`;
      if (K.pattern !== undefined)
        yield `${n(`${new RegExp(K.pattern)};`)}.test(${L})`;
      if (K.format !== undefined)
        yield `format('${K.format}', ${L})`;
    }
    function* e(K, E, L) {
      yield `(typeof ${L} === 'symbol')`;
    }
    function* o(K, E, L) {
      yield `(typeof ${L} === 'string')`, yield `${n(`${new RegExp(K.pattern)};`)}.test(${L})`;
    }
    function* r(K, E, L) {
      yield `${i(K.$ref)}(${L})`;
    }
    function* g0(K, E, L) {
      if (yield `Array.isArray(${L})`, K.items === undefined)
        return yield `${L}.length === 0`;
      yield `(${L}.length === ${K.maxItems})`;
      for (let p = 0;p < K.items.length; p++)
        yield `${f(K.items[p], E, `${L}[${p}]`)}`;
    }
    function* b0(K, E, L) {
      yield `${L} === undefined`;
    }
    function* E0(K, E, L) {
      yield `(${K.anyOf.map((T) => f(T, E, L)).join(" || ")})`;
    }
    function* H0(K, E, L) {
      if (yield `${L} instanceof Uint8Array`, (0, c.IsNumber)(K.maxByteLength))
        yield `(${L}.length <= ${K.maxByteLength})`;
      if ((0, c.IsNumber)(K.minByteLength))
        yield `(${L}.length >= ${K.minByteLength})`;
    }
    function* z0(K, E, L) {
      yield "true";
    }
    function* u0(K, E, L) {
      yield L1.IsVoidLike(L);
    }
    function* a0(K, E, L) {
      const p = R.instances.size;
      R.instances.set(p, K), yield `kind('${K[F0.Kind]}', ${p}, ${L})`;
    }
    function* v0(K, E, L, p = true) {
      const T = (0, c.IsString)(K.$id) ? [...E, K] : E, d = K;
      if (p && (0, c.IsString)(K.$id)) {
        const W0 = i(K.$id);
        if (R.functions.has(W0))
          return yield `${W0}(${L})`;
        else {
          const j0 = q0(W0, K, E, "value", false);
          return R.functions.set(W0, j0), yield `${W0}(${L})`;
        }
      }
      switch (d[F0.Kind]) {
        case "Any":
          return yield* W(d, T, L);
        case "Array":
          return yield* X(d, T, L);
        case "AsyncIterator":
          return yield* Z(d, T, L);
        case "BigInt":
          return yield* Q(d, T, L);
        case "Boolean":
          return yield* J(d, T, L);
        case "Constructor":
          return yield* z(d, T, L);
        case "Date":
          return yield* U(d, T, L);
        case "Function":
          return yield* D(d, T, L);
        case "Integer":
          return yield* B(d, T, L);
        case "Intersect":
          return yield* j(d, T, L);
        case "Iterator":
          return yield* b(d, T, L);
        case "Literal":
          return yield* S(d, T, L);
        case "Never":
          return yield* N(d, T, L);
        case "Not":
          return yield* O(d, T, L);
        case "Null":
          return yield* P(d, T, L);
        case "Number":
          return yield* F(d, T, L);
        case "Object":
          return yield* w(d, T, L);
        case "Promise":
          return yield* I(d, T, L);
        case "Record":
          return yield* G(d, T, L);
        case "Ref":
          return yield* k(d, T, L);
        case "String":
          return yield* _(d, T, L);
        case "Symbol":
          return yield* e(d, T, L);
        case "TemplateLiteral":
          return yield* o(d, T, L);
        case "This":
          return yield* r(d, T, L);
        case "Tuple":
          return yield* g0(d, T, L);
        case "Undefined":
          return yield* b0(d, T, L);
        case "Union":
          return yield* E0(d, T, L);
        case "Uint8Array":
          return yield* H0(d, T, L);
        case "Unknown":
          return yield* z0(d, T, L);
        case "Void":
          return yield* u0(d, T, L);
        default:
          if (!F0.TypeRegistry.Has(d[F0.Kind]))
            throw new J6(K);
          return yield* a0(d, T, L);
      }
    }
    const R = { language: "javascript", functions: new Map, variables: new Map, instances: new Map };
    function f(K, E, L, p = true) {
      return `(${[...v0(K, E, L, p)].join(" && ")})`;
    }
    function i(K) {
      return `check_${X6.Encode(K)}`;
    }
    function n(K) {
      const E = `local_${R.variables.size}`;
      return R.variables.set(E, `const ${E} = ${K}`), E;
    }
    function q0(K, E, L, p, T = true) {
      const [d, W0] = ["\n", (l) => "".padStart(l, " ")], j0 = B0("value", "any"), X0 = D0("boolean"), M = [...v0(E, L, p, T)].map((l) => `${W0(4)}${l}`).join(` &&${d}`);
      return `function ${K}(${j0})${X0} {${d}${W0(2)}return (${d}${M}${d}${W0(2)})\n}`;
    }
    function B0(K, E) {
      const L = R.language === "typescript" ? `: ${E}` : "";
      return `${K}${L}`;
    }
    function D0(K) {
      return R.language === "typescript" ? `: ${K}` : "";
    }
    function w0(K, E, L) {
      const p = q0("check", K, E, "value"), T = B0("value", "any"), d = D0("boolean"), W0 = [...R.functions.values()], j0 = [...R.variables.values()], X0 = (0, c.IsString)(K.$id) ? `return function check(${T})${d} {\n  return ${i(K.$id)}(value)\n}` : `return ${p}`;
      return [...j0, ...W0, X0].join("\n");
    }
    function M0(...K) {
      const E = { language: "javascript" }, [L, p, T] = K.length === 2 && (0, c.IsArray)(K[1]) ? [K[0], K[1], E] : K.length === 2 && !(0, c.IsArray)(K[1]) ? [K[0], [], K[1]] : K.length === 3 ? [K[0], K[1], K[2]] : K.length === 1 ? [K[0], [], E] : [null, [], E];
      if (R.language = T.language, R.variables.clear(), R.functions.clear(), R.instances.clear(), !F0.TypeGuard.TSchema(L))
        throw new p$(L);
      for (let d of p)
        if (!F0.TypeGuard.TSchema(d))
          throw new p$(d);
      return w0(L, p, T);
    }
    $.Code = M0;
    function B1(K, E = []) {
      const L = M0(K, E, { language: "javascript" }), p = globalThis.Function("kind", "format", "hash", L), T = new Map(R.instances);
      function d(M, l, S0) {
        if (!F0.TypeRegistry.Has(M) || !T.has(l))
          return false;
        const l$ = F0.TypeRegistry.Get(M), t$ = T.get(l);
        return l$(t$, S0);
      }
      function W0(M, l) {
        if (!F0.FormatRegistry.Has(M))
          return false;
        return F0.FormatRegistry.Get(M)(l);
      }
      function j0(M) {
        return (0, e9.Hash)(M);
      }
      const X0 = p(d, W0, j0);
      return new Q6(K, E, X0, L);
    }
    $.Compile = B1;
  })(MW || (NW.TypeCompiler = MW = {}));
});
var BW = J0((l0) => {
  var Z7 = l0 && l0.__createBinding || (Object.create ? function($, Y, W, X) {
    if (X === undefined)
      X = W;
    var Z = Object.getOwnPropertyDescriptor(Y, W);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[W];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, W, X) {
    if (X === undefined)
      X = W;
    $[X] = Y[W];
  }), Q7 = l0 && l0.__exportStar || function($, Y) {
    for (var W in $)
      if (W !== "default" && !Object.prototype.hasOwnProperty.call(Y, W))
        Z7(Y, $, W);
  };
  Object.defineProperty(l0, "__esModule", { value: true });
  l0.ValueErrorIterator = l0.ValueErrorType = undefined;
  var AW = I$();
  Object.defineProperty(l0, "ValueErrorType", { enumerable: true, get: function() {
    return AW.ValueErrorType;
  } });
  Object.defineProperty(l0, "ValueErrorIterator", { enumerable: true, get: function() {
    return AW.ValueErrorIterator;
  } });
  Q7(UW(), l0);
});
var bW = J0((K5, IW) => {
  var H7 = function($) {
    var Y = $.indexOf("%");
    if (Y === -1)
      return $;
    var W = $.length, X = "", Z = 0, Q = 0, J = Y, z = LW;
    while (Y > -1 && Y < W) {
      var U = CW($[Y + 1], 4), D = CW($[Y + 2], 0), B = U | D, j = U6[B];
      if (z = U6[256 + z + j], Q = Q << 6 | B & U6[364 + j], z === LW)
        X += $.slice(Z, J), X += Q <= 65535 ? String.fromCharCode(Q) : String.fromCharCode(55232 + (Q >> 10), 56320 + (Q & 1023)), Q = 0, Z = Y + 3, Y = J = $.indexOf("%", Z);
      else if (z === z7)
        return null;
      else {
        if (Y += 3, Y < W && $.charCodeAt(Y) === 37)
          continue;
        return null;
      }
    }
    return X + $.slice(Z);
  }, CW = function($, Y) {
    var W = q7[$];
    return W === undefined ? 255 : W << Y;
  }, LW = 12, z7 = 0, U6 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7], q7 = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  IW.exports = H7;
});
var VW = J0((j5, EW) => {
  var M7 = function($) {
    const Y = new _W;
    if (typeof $ !== "string")
      return Y;
    let W = $.length, X = "", Z = "", Q = -1, J = -1, z = false, U = false, D = false, B = false, j = false, b = 0;
    for (let S = 0;S < W + 1; S++)
      if (b = S !== W ? $.charCodeAt(S) : 38, b === 38) {
        if (j = J > Q, !j)
          J = S;
        if (X = $.slice(Q + 1, J), j || X.length > 0) {
          if (D)
            X = X.replace(RW, " ");
          if (z)
            X = GW(X) || X;
          if (j) {
            if (Z = $.slice(J + 1, S), B)
              Z = Z.replace(RW, " ");
            if (U)
              Z = GW(Z) || Z;
          }
          const N = Y[X];
          if (N === undefined)
            Y[X] = Z;
          else if (N.pop)
            N.push(Z);
          else
            Y[X] = [N, Z];
        }
        Z = "", Q = S, J = S, z = false, U = false, D = false, B = false;
      } else if (b === 61)
        if (J <= Q)
          J = S;
        else
          U = true;
      else if (b === 43)
        if (J > Q)
          B = true;
        else
          D = true;
      else if (b === 37)
        if (J > Q)
          U = true;
        else
          z = true;
    return Y;
  }, GW = bW(), RW = /\+/g, _W = function() {
  };
  _W.prototype = Object.create(null);
  EW.exports = M7;
});
var kW = J0((P5, xW) => {
  var F7 = function($) {
    const Y = $.length;
    if (Y === 0)
      return "";
    let W = "", X = 0, Z = 0;
    $:
      for (;Z < Y; Z++) {
        let Q = $.charCodeAt(Z);
        while (Q < 128) {
          if (N7[Q] !== 1) {
            if (X < Z)
              W += $.slice(X, Z);
            X = Z + 1, W += Z1[Q];
          }
          if (++Z === Y)
            break $;
          Q = $.charCodeAt(Z);
        }
        if (X < Z)
          W += $.slice(X, Z);
        if (Q < 2048) {
          X = Z + 1, W += Z1[192 | Q >> 6] + Z1[128 | Q & 63];
          continue;
        }
        if (Q < 55296 || Q >= 57344) {
          X = Z + 1, W += Z1[224 | Q >> 12] + Z1[128 | Q >> 6 & 63] + Z1[128 | Q & 63];
          continue;
        }
        if (++Z, Z >= Y)
          throw new Error("URI malformed");
        const J = $.charCodeAt(Z) & 1023;
        X = Z + 1, Q = 65536 + ((Q & 1023) << 10 | J), W += Z1[240 | Q >> 18] + Z1[128 | Q >> 12 & 63] + Z1[128 | Q >> 6 & 63] + Z1[128 | Q & 63];
      }
    if (X === 0)
      return $;
    if (X < Y)
      return W + $.slice(X);
    return W;
  }, Z1 = Array.from({ length: 256 }, ($, Y) => "%" + ((Y < 16 ? "0" : "") + Y.toString(16)).toUpperCase()), N7 = new Int8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0]);
  xW.exports = { encodeString: F7 };
});
var TW = J0((O5, fW) => {
  var gW = function($) {
    const Y = typeof $;
    if (Y === "string")
      return A6($);
    else if (Y === "bigint")
      return $.toString();
    else if (Y === "boolean")
      return $ ? "true" : "false";
    else if (Y === "number" && Number.isFinite($))
      return $ < 1000000000000000000000 ? "" + $ : A6("" + $);
    return "";
  }, U7 = function($) {
    let Y = "";
    if ($ === null || typeof $ !== "object")
      return Y;
    const W = "&", X = Object.keys($), Z = X.length;
    let Q = 0;
    for (let J = 0;J < Z; J++) {
      const z = X[J], U = $[z], D = A6(z) + "=";
      if (J)
        Y += W;
      if (Array.isArray(U)) {
        Q = U.length;
        for (let B = 0;B < Q; B++) {
          if (B)
            Y += W;
          Y += D, Y += gW(U[B]);
        }
      } else
        Y += D, Y += gW(U);
    }
    return Y;
  }, { encodeString: A6 } = kW();
  fW.exports = U7;
});
var B6 = J0((S5, B$) => {
  var dW = VW(), yW = TW(), vW = { parse: dW, stringify: yW };
  B$.exports = vW;
  B$.exports.default = vW;
  B$.exports.parse = dW;
  B$.exports.stringify = yW;
});
var _1 = ($, Y) => ({ part: $, store: null, inert: Y !== undefined ? new Map(Y.map((W) => [W.part.charCodeAt(0), W])) : null, params: null, wildcardStore: null });
var L6 = ($, Y) => ({ ...$, part: Y });
var C6 = ($) => ({ paramName: $, store: null, inert: null });

class E1 {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g };
  add($, Y, W) {
    let X;
    if (typeof Y != "string")
      throw TypeError("Route path must be a string");
    Y === "" ? Y = "/" : Y[0] !== "/" && (Y = `/${Y}`), this.history.push([$, Y, W]);
    let Z = Y[Y.length - 1] === "*";
    Z && (Y = Y.slice(0, -1));
    let Q = Y.split(E1.regex.static), J = Y.match(E1.regex.params) || [];
    Q[Q.length - 1] === "" && Q.pop(), X = this.root[$] ? this.root[$] : this.root[$] = _1("/");
    let z = 0;
    for (let U = 0;U < Q.length; ++U) {
      let D = Q[U];
      if (U > 0) {
        let B = J[z++].slice(1);
        if (X.params === null)
          X.params = C6(B);
        else if (X.params.paramName !== B)
          throw Error(`Cannot create route "${Y}" with parameter "${B}" because a route already exists with a different parameter name ("${X.params.paramName}") in the same location`);
        let j = X.params;
        if (j.inert === null) {
          X = j.inert = _1(D);
          continue;
        }
        X = j.inert;
      }
      for (let B = 0;; ) {
        if (B === D.length) {
          if (B < X.part.length) {
            let j = L6(X, X.part.slice(B));
            Object.assign(X, _1(D, [j]));
          }
          break;
        }
        if (B === X.part.length) {
          if (X.inert === null)
            X.inert = new Map;
          else if (X.inert.has(D.charCodeAt(B))) {
            X = X.inert.get(D.charCodeAt(B)), D = D.slice(B), B = 0;
            continue;
          }
          let j = _1(D.slice(B));
          X.inert.set(D.charCodeAt(B), j), X = j;
          break;
        }
        if (D[B] !== X.part[B]) {
          let j = L6(X, X.part.slice(B)), b = _1(D.slice(B));
          Object.assign(X, _1(X.part.slice(0, B), [j, b])), X = b;
          break;
        }
        ++B;
      }
    }
    if (z < J.length) {
      let U = J[z], D = U.slice(1);
      if (X.params === null)
        X.params = C6(D);
      else if (X.params.paramName !== D)
        throw Error(`Cannot create route "${Y}" with parameter "${D}" because a route already exists with a different parameter name ("${X.params.paramName}") in the same location`);
      return X.params.store === null && (X.params.store = W), X.params.store;
    }
    return Z ? (X.wildcardStore === null && (X.wildcardStore = W), X.wildcardStore) : (X.store === null && (X.store = W), X.store);
  }
  find($, Y) {
    let W = this.root[$];
    return W ? r$(Y, Y.length, W, 0) : null;
  }
}
var r$ = ($, Y, W, X) => {
  let Z = W?.part, Q = X + Z.length;
  if (Z.length > 1) {
    if (Q > Y)
      return null;
    if (Z.length < 15) {
      for (let J = 1, z = X + 1;J < Z.length; ++J, ++z)
        if (Z.charCodeAt(J) !== $.charCodeAt(z))
          return null;
    } else if ($.substring(X, Q) !== Z)
      return null;
  }
  if (Q === Y)
    return W.store !== null ? { store: W.store, params: {} } : W.wildcardStore !== null ? { store: W.wildcardStore, params: { "*": "" } } : null;
  if (W.inert !== null) {
    let J = W.inert.get($.charCodeAt(Q));
    if (J !== undefined) {
      let z = r$($, Y, J, Q);
      if (z !== null)
        return z;
    }
  }
  if (W.params !== null) {
    let J = W.params, z = $.indexOf("/", Q);
    if (z !== Q) {
      if (z === -1 || z >= Y) {
        if (J.store !== null) {
          let U = {};
          return U[J.paramName] = $.substring(Q, Y), { store: J.store, params: U };
        }
      } else if (J.inert !== null) {
        let U = r$($, Y, J.inert, z);
        if (U !== null)
          return U.params[J.paramName] = $.substring(Q, z), U;
      }
    }
  }
  return W.wildcardStore !== null ? { store: W.wildcardStore, params: { "*": $.substring(Q, Y) } } : null;
};
var G6 = Q1(b6(), 1);
var R6 = G6.default;
var _6 = ($, Y) => {
  return async function W(X) {
    const Z = X.id;
    if (X.event === "request" && X.type === "begin") {
      const Q = () => {
        let O, P, F = -1;
        const w = [], I = [];
        let G = false;
        const k = new Promise((o) => {
          O = (r) => {
            if (G)
              return;
            else
              G = true;
            o(r);
          };
        });
        let _ = false;
        const e = new Promise((o) => {
          P = (r) => {
            if (_)
              return;
            else
              _ = true;
            if (F === -1)
              F = 0;
            for (;F < I.length; F++) {
              let g0;
              const b0 = { name: "anonymous", time: performance.now(), skip: true, end: new Promise((E0) => {
                E0(g0);
              }), children: [] };
              g0 = performance.now(), w[F](b0);
            }
            o(r);
          };
        });
        return { signal: k, consumeChild(o) {
          switch (o.type) {
            case "begin":
              w[++F]({ name: o.name, time: o.time, skip: false, end: new Promise((r) => {
                I.push(r);
              }) });
              break;
            case "end":
              I[F](o.time);
              break;
          }
        }, consume(o) {
          switch (o.type) {
            case "begin":
              const r = [], g0 = o.unit ?? 0;
              for (let b0 = 0;b0 < g0; b0++) {
                let E0;
                r.push(new Promise((H0) => {
                  E0 = H0;
                })), w.push(E0);
              }
              O({ name: o.name, time: o.time, skip: false, end: e, children: r });
              break;
            case "end":
              P(o.time);
              break;
          }
        }, resolve() {
          if (G && _)
            return;
          let o;
          const r = { name: "anonymous", time: performance.now(), skip: true, end: new Promise((g0) => {
            g0(o);
          }), children: [] };
          o = performance.now(), O(r), P(o);
        } };
      }, J = Q(), z = Q(), U = Q(), D = Q(), B = Q(), j = Q(), b = Q(), S = Q();
      J.consume(X);
      const N = (O) => {
        if (O.id === Z)
          switch (O.event) {
            case "request":
              J.consume(O);
              break;
            case "request.unit":
              J.consumeChild(O);
              break;
            case "parse":
              z.consume(O);
              break;
            case "parse.unit":
              z.consumeChild(O);
              break;
            case "transform":
              U.consume(O);
              break;
            case "transform.unit":
              U.consumeChild(O);
              break;
            case "beforeHandle":
              D.consume(O);
              break;
            case "beforeHandle.unit":
              D.consumeChild(O);
              break;
            case "handle":
              B.consume(O);
              break;
            case "afterHandle":
              j.consume(O);
              break;
            case "afterHandle.unit":
              j.consumeChild(O);
              break;
            case "error":
              b.consume(O);
              break;
            case "error.unit":
              b.consumeChild(O);
              break;
            case "response":
              if (O.type === "begin")
                J.resolve(), z.resolve(), U.resolve(), D.resolve(), B.resolve(), j.resolve(), b.resolve();
              else
                $.off("event", N);
              S.consume(O);
              break;
            case "response.unit":
              S.consumeChild(O);
              break;
          }
      };
      $.on("event", N), await Y({ id: X.id, context: X.ctx, set: X.ctx?.set, store: X.ctx?.store, time: X.time, request: J.signal, parse: z.signal, transform: U.signal, beforeHandle: D.signal, handle: B.signal, afterHandle: j.signal, error: b.signal, response: S.signal }), $.emit(`res${Z}`, undefined);
    }
  };
};
var Y6 = Q1($6(), 1);
var HW = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var n1 = Symbol("ErrorCode");
var q$ = (HW?.NODE_ENV ?? HW?.ENV) === "production";

class f$ extends Error {
  code = "INTERNAL_SERVER_ERROR";
  status = 500;
  constructor($) {
    super($ ?? "INTERNAL_SERVER_ERROR");
  }
}

class S1 extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor($) {
    super($ ?? "NOT_FOUND");
  }
}
class M$ extends Error {
  $;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor($, Y) {
    super(Y ?? `"${$}" has invalid cookie signature`);
    this.key = $;
  }
}

class P0 extends Error {
  $;
  Y;
  W;
  code = "VALIDATION";
  status = 400;
  constructor($, Y, W) {
    const X = q$ ? undefined : Y.Errors(W).First(), Z = X?.schema.error ? typeof X.schema.error === "function" ? X.schema.error($, Y, W) : X.schema.error : undefined, Q = q$ ? Z ?? `Invalid ${$ ?? X?.schema.error ?? X?.message}` : Z ?? `Invalid ${$}, '${X?.path?.slice(1) || "type"}': ${X?.message}` + "\n\nExpected: " + JSON.stringify(Y6.Value.Create(Y.schema), null, 2) + "\n\nFound: " + JSON.stringify(W, null, 2);
    super(Q);
    this.type = $;
    this.validator = Y;
    this.value = W;
    Object.setPrototypeOf(this, P0.prototype);
  }
  get all() {
    return [...this.validator.Errors(this.value)];
  }
  get model() {
    return Y6.Value.Create(this.validator.schema);
  }
  toResponse($) {
    return new Response(this.message, { status: 400, headers: $ });
  }
}
var W6 = { open($) {
  $.data.open?.($);
}, message($, Y) {
  $.data.message?.($, Y);
}, drain($) {
  $.data.drain?.($);
}, close($, Y, W) {
  $.data.close?.($, Y, W);
} };

class c1 {
  $;
  Y;
  validator;
  constructor($, Y) {
    this.raw = $;
    this.data = Y;
    this.validator = $.data.validator;
  }
  get publish() {
    return ($, Y = undefined, W) => {
      if (this.validator?.Check(Y) === false)
        throw new P0("message", this.validator, Y);
      if (typeof Y === "object")
        Y = JSON.stringify(Y);
      return this.raw.publish($, Y, W), this;
    };
  }
  get send() {
    return ($) => {
      if (this.validator?.Check($) === false)
        throw new P0("message", this.validator, $);
      if (typeof $ === "object")
        $ = JSON.stringify($);
      return this.raw.send($), this;
    };
  }
  get subscribe() {
    return ($) => {
      return this.raw.subscribe($), this;
    };
  }
  get unsubscribe() {
    return ($) => {
      return this.raw.unsubscribe($), this;
    };
  }
  get cork() {
    return ($) => {
      return this.raw.cork($), this;
    };
  }
  get close() {
    return () => {
      return this.raw.close(), this;
    };
  }
  get terminate() {
    return this.raw.terminate.bind(this.raw);
  }
  get isSubscribed() {
    return this.raw.isSubscribed.bind(this.raw);
  }
  get remoteAddress() {
    return this.raw.remoteAddress;
  }
}
var o9 = function($, Y) {
  if (typeof $ !== "string")
    throw new TypeError("argument str must be a string");
  var W = {}, X = Y || {}, Z = X.decode || c9, Q = 0;
  while (Q < $.length) {
    var J = $.indexOf("=", Q);
    if (J === -1)
      break;
    var z = $.indexOf(";", Q);
    if (z === -1)
      z = $.length;
    else if (z < J) {
      Q = $.lastIndexOf(";", J - 1) + 1;
      continue;
    }
    var U = $.slice(Q, J).trim();
    if (W[U] === undefined) {
      var D = $.slice(J + 1, z).trim();
      if (D.charCodeAt(0) === 34)
        D = D.slice(1, -1);
      W[U] = s9(D, Z);
    }
    Q = z + 1;
  }
  return W;
};
var n9 = function($, Y, W) {
  var X = W || {}, Z = X.encode || l9;
  if (typeof Z !== "function")
    throw new TypeError("option encode is invalid");
  if (!T$.test($))
    throw new TypeError("argument name is invalid");
  var Q = Z(Y);
  if (Q && !T$.test(Q))
    throw new TypeError("argument val is invalid");
  var J = $ + "=" + Q;
  if (X.maxAge != null) {
    var z = X.maxAge - 0;
    if (isNaN(z) || !isFinite(z))
      throw new TypeError("option maxAge is invalid");
    J += "; Max-Age=" + Math.floor(z);
  }
  if (X.domain) {
    if (!T$.test(X.domain))
      throw new TypeError("option domain is invalid");
    J += "; Domain=" + X.domain;
  }
  if (X.path) {
    if (!T$.test(X.path))
      throw new TypeError("option path is invalid");
    J += "; Path=" + X.path;
  }
  if (X.expires) {
    var U = X.expires;
    if (!t9(U) || isNaN(U.valueOf()))
      throw new TypeError("option expires is invalid");
    J += "; Expires=" + U.toUTCString();
  }
  if (X.httpOnly)
    J += "; HttpOnly";
  if (X.secure)
    J += "; Secure";
  if (X.priority) {
    var D = typeof X.priority === "string" ? X.priority.toLowerCase() : X.priority;
    switch (D) {
      case "low":
        J += "; Priority=Low";
        break;
      case "medium":
        J += "; Priority=Medium";
        break;
      case "high":
        J += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (X.sameSite) {
    var B = typeof X.sameSite === "string" ? X.sameSite.toLowerCase() : X.sameSite;
    switch (B) {
      case true:
        J += "; SameSite=Strict";
        break;
      case "lax":
        J += "; SameSite=Lax";
        break;
      case "strict":
        J += "; SameSite=Strict";
        break;
      case "none":
        J += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return J;
};
var c9 = function($) {
  return $.indexOf("%") !== -1 ? decodeURIComponent($) : $;
};
var l9 = function($) {
  return encodeURIComponent($);
};
var t9 = function($) {
  return h9.call($) === "[object Date]" || $ instanceof Date;
};
var s9 = function($, Y) {
  try {
    return Y($);
  } catch (W) {
    return $;
  }
};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var d$ = o9;
var y$ = n9;
var h9 = Object.prototype.toString;
var T$ = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
var i$ = Q1(f0(), 1);
var U$ = Q1($6(), 1);
var H6 = Q1(BW(), 1);
var z6 = ($) => $ && typeof $ === "object" && !Array.isArray($);
var J7 = ($) => typeof $ === "function" && /^\s*class\s+/.test($.toString()) || $.toString().startsWith("[object ") || t0(Object.getPrototypeOf($));
var U1 = ($, Y, { skipKeys: W } = {}) => {
  if (z6($) && z6(Y))
    for (let [X, Z] of Object.entries(Y)) {
      if (W?.includes(X))
        continue;
      if (!z6(Z)) {
        $[X] = Z;
        continue;
      }
      if (!(X in $)) {
        $[X] = Z;
        continue;
      }
      if (J7(Z)) {
        $[X] = Z;
        continue;
      }
      $[X] = U1($[X], Z);
    }
  return $;
};
var DW = ($, Y) => U1($, Y, { skipKeys: ["properties"] });
var O0 = ($, Y) => {
  const W = [...Array.isArray($) ? $ : [$]], X = [];
  for (let Z of W)
    if (Z.$elysiaChecksum)
      X.push(Z.$elysiaChecksum);
  for (let Z of Array.isArray(Y) ? Y : [Y])
    if (!X.includes(Z?.$elysiaChecksum))
      W.push(Z);
  return W;
};
var C1 = ($, Y) => {
  return { body: Y?.body ?? $?.body, headers: Y?.headers ?? $?.headers, params: Y?.params ?? $?.params, query: Y?.query ?? $?.query, response: Y?.response ?? $?.response, type: $?.type || Y?.type, detail: U1(Y?.detail ?? {}, $?.detail ?? {}), parse: O0($?.parse ?? [], Y?.parse ?? []), transform: O0($?.transform ?? [], Y?.transform ?? []), beforeHandle: O0($?.beforeHandle ?? [], Y?.beforeHandle ?? []), afterHandle: O0($?.afterHandle ?? [], Y?.afterHandle ?? []), onResponse: O0($?.onResponse ?? [], Y?.onResponse ?? []), trace: O0($?.trace ?? [], Y?.trace ?? []), error: O0($?.error ?? [], Y?.error ?? []) };
};
var X1 = ($, { models: Y = {}, additionalProperties: W = false, dynamic: X = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in Y))
    return;
  const Z = typeof $ === "string" ? Y[$] : $;
  if (Z.type === "object" && "additionalProperties" in Z === false)
    Z.additionalProperties = W;
  if (X)
    return { schema: Z, references: "", checkFunc: () => {
    }, code: "", Check: (Q) => U$.Value.Check(Z, Q), Errors: (Q) => U$.Value.Errors(Z, Q), Code: () => "" };
  return H6.TypeCompiler.Compile(Z);
};
var q6 = ($, { models: Y = {}, additionalProperties: W = false, dynamic: X = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in Y))
    return;
  const Z = typeof $ === "string" ? Y[$] : $, Q = (z) => {
    if (X)
      return { schema: z, references: "", checkFunc: () => {
      }, code: "", Check: (U) => U$.Value.Check(z, U), Errors: (U) => U$.Value.Errors(z, U), Code: () => "" };
    return H6.TypeCompiler.Compile(z);
  };
  if (i$.Kind in Z) {
    if ("additionalProperties" in Z === false)
      Z.additionalProperties = W;
    return { 200: Q(Z) };
  }
  const J = {};
  return Object.keys(Z).forEach((z) => {
    const U = Z[+z];
    if (typeof U === "string") {
      if (U in Y) {
        const D = Y[U];
        D.type === "object" && "additionalProperties" in D, J[+z] = i$.Kind in D ? Q(D) : D;
      }
      return;
    }
    if (U.type === "object" && "additionalProperties" in U === false)
      U.additionalProperties = W;
    J[+z] = i$.Kind in U ? Q(U) : U;
  }), J;
};
var M6 = ($) => {
  let Y = 9;
  for (let W = 0;W < $.length; )
    Y = Math.imul(Y ^ $.charCodeAt(W++), 387420489);
  return Y = Y ^ Y >>> 9;
};
var m$ = ($, Y, W) => {
  const X = (Z) => {
    if (W)
      Z.$elysiaChecksum = W;
    return Z;
  };
  return { start: O0($.start, ("start" in Y ? Y.start ?? [] : []).map(X)), request: O0($.request, ("request" in Y ? Y.request ?? [] : []).map(X)), parse: O0($.parse, "parse" in Y ? Y?.parse ?? [] : []).map(X), transform: O0($.transform, (Y?.transform ?? []).map(X)), beforeHandle: O0($.beforeHandle, (Y?.beforeHandle ?? []).map(X)), afterHandle: O0($.afterHandle, (Y?.afterHandle ?? []).map(X)), onResponse: O0($.onResponse, (Y?.onResponse ?? []).map(X)), trace: O0($.trace, ("trace" in Y ? Y.trace ?? [] : []).map(X)), error: O0($.error, (Y?.error ?? []).map(X)), stop: O0($.stop, ("stop" in Y ? Y.stop ?? [] : []).map(X)) };
};
var wW = ($, Y = true) => {
  if (!$)
    return $;
  if (typeof $ === "function") {
    if (Y)
      $.$elysiaHookType = "global";
    else
      $.$elysiaHookType = undefined;
    return $;
  }
  return $.map((W) => {
    if (Y)
      W.$elysiaHookType = "global";
    else
      W.$elysiaHookType = undefined;
    return W;
  });
};
var l1 = ($) => {
  if (!$)
    return $;
  if (typeof $ === "function")
    return $.$elysiaHookType === "global" ? $ : undefined;
  return $.filter((Y) => Y.$elysiaHookType === "global");
};
var N6 = ($) => {
  return { ...$, type: $?.type, detail: $?.detail, parse: l1($?.parse), transform: l1($?.transform), beforeHandle: l1($?.beforeHandle), afterHandle: l1($?.afterHandle), onResponse: l1($?.onResponse), error: l1($?.error) };
};
var F6 = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var KW = import.meta.require("crypto");
var I1 = function($, Y) {
  if (typeof $ != "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (Y == null)
    throw new TypeError("Secret key must be provided.");
  return $ + "." + KW.createHmac("sha256", Y).update($).digest("base64").replace(/\=+$/, "");
};
var u$ = function($, Y) {
  if (typeof $ != "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (Y == null)
    throw new TypeError("Secret key must be provided.");
  var W = $.slice(0, $.lastIndexOf(".")), X = I1(W, Y), Z = Buffer.from(X), Q = Buffer.from($);
  return Z.length === Q.length && KW.timingSafeEqual(Z, Q) ? W : false;
};

class s0 {
  $;
  Y;
  name;
  setter;
  constructor($, Y = {}) {
    this._value = $;
    this.property = Y;
  }
  get() {
    return this._value;
  }
  get value() {
    return this._value;
  }
  set value($) {
    if (typeof $ === "object") {
      if (JSON.stringify(this.value) === JSON.stringify($))
        return;
    } else if (this.value === $)
      return;
    this._value = $, this.sync();
  }
  add($) {
    const Y = Object.assign(this.property, typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $);
    if ("value" in Y)
      this._value = Y.value, delete Y.value;
    return this.property = Y, this.sync();
  }
  set($) {
    const Y = typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $;
    if ("value" in Y)
      this._value = Y.value, delete Y.value;
    return this.property = Y, this.sync();
  }
  remove() {
    if (this.value === undefined)
      return;
    this.set({ value: "", expires: new Date });
  }
  get domain() {
    return this.property.domain;
  }
  set domain($) {
    if (this.property.domain === $)
      return;
    this.property.domain = $, this.sync();
  }
  get expires() {
    return this.property.expires;
  }
  set expires($) {
    if (this.property.expires?.getTime() === $?.getTime())
      return;
    this.property.expires = $, this.sync();
  }
  get httpOnly() {
    return this.property.httpOnly;
  }
  set httpOnly($) {
    if (this.property.domain === $)
      return;
    this.property.httpOnly = $, this.sync();
  }
  get maxAge() {
    return this.property.maxAge;
  }
  set maxAge($) {
    if (this.property.maxAge === $)
      return;
    this.property.maxAge = $, this.sync();
  }
  get path() {
    return this.property.path;
  }
  set path($) {
    if (this.property.path === $)
      return;
    this.property.path = $, this.sync();
  }
  get priority() {
    return this.property.priority;
  }
  set priority($) {
    if (this.property.priority === $)
      return;
    this.property.priority = $, this.sync();
  }
  get sameSite() {
    return this.property.sameSite;
  }
  set sameSite($) {
    if (this.property.sameSite === $)
      return;
    this.property.sameSite = $, this.sync();
  }
  get secure() {
    return this.property.secure;
  }
  set secure($) {
    if (this.property.secure === $)
      return;
    this.property.secure = $, this.sync();
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
  sync() {
    if (!this.name || !this.setter)
      return this;
    if (!this.setter.cookie)
      this.setter.cookie = { [this.name]: Object.assign(this.property, { value: this.toString() }) };
    else
      this.setter.cookie[this.name] = Object.assign(this.property, { value: this.toString() });
    return this;
  }
}
var jW = ($, Y, W) => new Proxy($, { get(X, Z) {
  if (Z in X)
    return X[Z];
  const Q = new s0(undefined, W ? { ...W } : undefined);
  return Q.setter = Y, Q.name = Z, Q;
}, set(X, Z, Q) {
  if (!(Q instanceof s0))
    return false;
  if (!Y.cookie)
    Y.cookie = {};
  return Q.setter = Y, Q.name = Z, Q.sync(), X[Z] = Q, true;
} });
var h$ = ($, Y, { secret: W, sign: X, ...Z } = {}) => {
  if (!Y)
    return jW({}, $, Z);
  const Q = {}, J = typeof W === "string";
  if (X && X !== true && !Array.isArray(X))
    X = [X];
  const z = Object.keys(d$(Y));
  for (let U = 0;U < z.length; U++) {
    const D = z[U];
    let B = d$(Y)[D];
    if (X === true || X?.includes(D)) {
      if (!W)
        throw new Error("No secret is provided to cookie plugin");
      if (J) {
        if (B = u$(B, W), B === false)
          throw new M$(D);
      } else {
        let S = true;
        for (let N = 0;N < W.length; N++) {
          const O = u$(B, W[N]);
          if (O !== false) {
            B = O, S = false;
            break;
          }
        }
        if (S)
          throw new M$(D);
      }
    }
    const j = B.charCodeAt(0);
    if (j === 123 || j === 91)
      try {
        const S = new s0(JSON.parse(B));
        S.setter = $, S.name = D, Q[D] = S;
        continue;
      } catch {
      }
    if (!Number.isNaN(+B))
      B = +B;
    else if (B === "true")
      B = true;
    else if (B === "false")
      B = false;
    const b = new s0(B, Z);
    b.setter = $, b.name = D, Q[D] = b;
  }
  return jW(Q, $);
};
var PW = "toJSON" in new Headers;
var t0 = ($) => {
  for (let Y in $)
    return true;
  return false;
};
var OW = ($, Y) => {
  if (!$ || !Array.isArray(Y))
    return $;
  $.delete("Set-Cookie");
  for (let W = 0;W < Y.length; W++) {
    const X = Y[W].indexOf("=");
    $.append("Set-Cookie", `${Y[W].slice(0, X)}=${Y[W].slice(X + 1)}`);
  }
  return $;
};
var SW = ($) => {
  if (!$ || typeof $ !== "object" || !t0($))
    return;
  const Y = [];
  for (let [W, X] of Object.entries($)) {
    if (!W || !X)
      continue;
    if (Array.isArray(X.value))
      for (let Z = 0;Z < X.value.length; Z++) {
        let Q = X.value[Z];
        if (Q === undefined || Q === null)
          continue;
        if (typeof Q === "object")
          Q = JSON.stringify(Q);
        Y.push(y$(W, Q, X));
      }
    else {
      let Z = X.value;
      if (Z === undefined || Z === null)
        continue;
      if (typeof Z === "object")
        Z = JSON.stringify(Z);
      Y.push(y$(W, X.value, X));
    }
  }
  if (Y.length === 0)
    return;
  if (Y.length === 1)
    return Y[0];
  return Y;
};
var A1 = ($, Y) => {
  if (t0(Y.headers) || Y.status !== 200 || Y.redirect || Y.cookie) {
    if (typeof Y.status === "string")
      Y.status = F6[Y.status];
    if (Y.redirect) {
      if (Y.headers.Location = Y.redirect, !Y.status || Y.status < 300 || Y.status >= 400)
        Y.status = 302;
    }
    if (Y.cookie && t0(Y.cookie))
      Y.headers["Set-Cookie"] = SW(Y.cookie);
    if (Y.headers["Set-Cookie"] && Array.isArray(Y.headers["Set-Cookie"]))
      Y.headers = OW(new Headers(Y.headers), Y.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($, { status: Y.status, headers: Y.headers });
      case "Object":
      case "Array":
        return Response.json($, Y);
      case undefined:
        if (!$)
          return new Response("", Y);
        return Response.json($, Y);
      case "Response":
        const W = { ...Y.headers };
        if (PW)
          Y.headers = $.headers.toJSON();
        else
          for (let [Z, Q] of $.headers.entries())
            if (Z in Y.headers)
              Y.headers[Z] = Q;
        for (let Z in W)
          $.headers.append(Z, W[Z]);
        return $;
      case "Error":
        return A$($, Y);
      case "Promise":
        return $.then((Z) => A1(Z, Y));
      case "Function":
        return A1($(), Y);
      case "Number":
      case "Boolean":
        return new Response($.toString(), Y);
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const X = JSON.stringify($);
        if (X.charCodeAt(0) === 123) {
          if (!Y.headers["Content-Type"])
            Y.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), Y);
        }
        return new Response(X, Y);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Error":
        return A$($, Y);
      case "Promise":
        return $.then((X) => {
          const Z = K1(X);
          if (Z !== undefined)
            return Z;
          return new Response("");
        });
      case "Function":
        return K1($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const W = JSON.stringify($);
        if (W.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(W);
    }
};
var r0 = ($, Y) => {
  if ($ === undefined || $ === null)
    return;
  if (t0(Y.headers) || Y.status !== 200 || Y.redirect || Y.cookie) {
    if (typeof Y.status === "string")
      Y.status = F6[Y.status];
    if (Y.redirect) {
      if (Y.headers.Location = Y.redirect, !Y.status || Y.status < 300 || Y.status >= 400)
        Y.status = 302;
    }
    if (Y.cookie && t0(Y.cookie))
      Y.headers["Set-Cookie"] = SW(Y.cookie);
    if (Y.headers["Set-Cookie"] && Array.isArray(Y.headers["Set-Cookie"]))
      Y.headers = OW(new Headers(Y.headers), Y.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($, Y);
      case "Object":
      case "Array":
        return Response.json($, Y);
      case undefined:
        if (!$)
          return;
        return Response.json($, Y);
      case "Response":
        const W = Object.assign({}, Y.headers);
        if (PW)
          Y.headers = $.headers.toJSON();
        else
          for (let [Z, Q] of $.headers.entries())
            if (!(Z in Y.headers))
              Y.headers[Z] = Q;
        for (let Z in W)
          $.headers.append(Z, W[Z]);
        if ($.status !== Y.status)
          Y.status = $.status;
        return $;
      case "Promise":
        return $.then((Z) => {
          const Q = r0(Z, Y);
          if (Q !== undefined)
            return Q;
          return;
        });
      case "Error":
        return A$($, Y);
      case "Function":
        return r0($(), Y);
      case "Number":
      case "Boolean":
        return new Response($.toString(), Y);
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const X = JSON.stringify($);
        if (X.charCodeAt(0) === 123) {
          if (!Y.headers["Content-Type"])
            Y.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), Y);
        }
        return new Response(X, Y);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Promise":
        return $.then((X) => {
          const Z = r0(X, Y);
          if (Z !== undefined)
            return Z;
          return;
        });
      case "Error":
        return A$($, Y);
      case "Function":
        return K1($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const W = JSON.stringify($);
        if (W.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(W);
    }
};
var K1 = ($) => {
  switch ($?.constructor?.name) {
    case "String":
    case "Blob":
      return new Response($);
    case "Object":
    case "Array":
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case undefined:
      if (!$)
        return new Response("");
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "Response":
      return $;
    case "Error":
      return A$($);
    case "Promise":
      return $.then((W) => {
        const X = K1(W);
        if (X !== undefined)
          return X;
        return new Response("");
      });
    case "Function":
      return K1($());
    case "Number":
    case "Boolean":
      return new Response($.toString());
    default:
      const Y = JSON.stringify($);
      if (Y.charCodeAt(0) === 123)
        return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
      return new Response(Y);
  }
};
var A$ = ($, Y) => new Response(JSON.stringify({ name: $?.name, message: $?.message, cause: $?.cause }), { status: Y?.status !== 200 ? Y?.status ?? 500 : 500, headers: Y?.headers });
var pW = Q1(B6(), 1);
var A7 = new Headers().toJSON;
var iW = new RegExp(" (\\w+) = context", "g");
var mW = { value: 0 };
var uW = ({ hasTrace: $, hasTraceSet: Y = false, addFn: W, condition: X = {} }) => {
  if ($)
    return (Z, { name: Q, attribute: J = "", unit: z = 0 } = {}) => {
      const U = Z.indexOf("."), D = U === -1;
      if (Z !== "request" && Z !== "response" && !X[D ? Z : Z.slice(0, U)])
        return () => {
          if (Y && Z === "afterHandle")
            W("\nawait traceDone\n");
        };
      if (D)
        Q ||= Z;
      else
        Q ||= "anonymous";
      W("\n" + `reporter.emit('event', { 
					id,
					event: '${Z}',
					type: 'begin',
					name: '${Q}',
					time: performance.now(),
					${D ? `unit: ${z},` : ""}
					${J}
				})`.replace(/(\t| |\n)/g, "") + "\n");
      let B = false;
      return () => {
        if (B)
          return;
        if (B = true, W("\n" + `reporter.emit('event', {
							id,
							event: '${Z}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g, "") + "\n"), Y && Z === "afterHandle")
          W("\nawait traceDone\n");
      };
    };
  else
    return () => () => {
    };
};
var D$ = ($) => {
  const Y = $.indexOf(")");
  if ($.charCodeAt(Y + 2) === 61 && $.charCodeAt(Y + 5) !== 123)
    return true;
  return $.includes("return");
};
var B7 = ($, { injectResponse: Y = "" } = {}) => ({ composeValidation: (W, X = `c.${W}`) => $ ? `c.set.status = 400; throw new ValidationError(
'${W}',
${W},
${X}
)` : `c.set.status = 400; return new ValidationError(
	'${W}',
	${W},
	${X}
).toResponse(c.set.headers)`, composeResponseValidation: (W = "r") => {
  const X = $ ? `throw new ValidationError(
'response',
response[c.set.status],
${W}
)` : `return new ValidationError(
'response',
response[c.set.status],
${W}
).toResponse(c.set.headers)`;
  return `\n${Y}
		if(response[c.set.status]?.Check(${W}) === false) { 
	if(!(response instanceof Error))
		${X}
}\n`;
} });
var K0 = ($, Y) => {
  if (Y = Y.trimStart(), Y = Y.replaceAll(/^async /g, ""), /^(\w+)\(/g.test(Y))
    Y = Y.slice(Y.indexOf("("));
  const W = Y.charCodeAt(0) === 40 || Y.startsWith("function") ? Y.slice(Y.indexOf("(") + 1, Y.indexOf(")")) : Y.slice(0, Y.indexOf("=") - 1);
  if (W === "")
    return false;
  const X = W.charCodeAt(0) === 123 ? W.indexOf("...") : -1;
  if (W.charCodeAt(0) === 123) {
    if (W.includes($))
      return true;
    if (X === -1)
      return false;
  }
  if (Y.match(new RegExp(`${W}(.${$}|\\["${$}"\\])`)))
    return true;
  const Z = X !== -1 ? W.slice(X + 3, W.indexOf(" ", X + 3)) : undefined;
  if (Y.match(new RegExp(`${Z}(.${$}|\\["${$}"\\])`)))
    return true;
  const Q = [W];
  if (Z)
    Q.push(Z);
  for (let z of Y.matchAll(iW))
    Q.push(z[1]);
  const J = new RegExp(`{.*?} = (${Q.join("|")})`, "g");
  for (let [z] of Y.matchAll(J))
    if (z.includes(`{ ${$}`) || z.includes(`, ${$}`))
      return true;
  return false;
};
var w$ = ($) => {
  if ($ = $.trimStart(), $ = $.replaceAll(/^async /g, ""), /^(\w+)\(/g.test($))
    $ = $.slice($.indexOf("("));
  const Y = $.charCodeAt(0) === 40 || $.startsWith("function") ? $.slice($.indexOf("(") + 1, $.indexOf(")")) : $.slice(0, $.indexOf("=") - 1);
  if (Y === "")
    return false;
  const W = Y.charCodeAt(0) === 123 ? Y.indexOf("...") : -1, X = W !== -1 ? Y.slice(W + 3, Y.indexOf(" ", W + 3)) : undefined, Z = [Y];
  if (X)
    Z.push(X);
  for (let J of $.matchAll(iW))
    Z.push(J[1]);
  for (let J of Z)
    if (new RegExp(`\\b\\w+\\([^)]*\\b${J}\\b[^)]*\\)`).test($))
      return true;
  const Q = new RegExp(`{.*?} = (${Z.join("|")})`, "g");
  for (let [J] of $.matchAll(Q))
    if (new RegExp(`\\b\\w+\\([^)]*\\b${J}\\b[^)]*\\)`).test($))
      return true;
  return false;
};
var t1 = Symbol.for("TypeBox.Kind");
var o$ = ($, Y) => {
  if (!Y)
    return;
  if (t1 in Y && Y[t1] === $)
    return true;
  if (Y.type === "object") {
    const W = Y.properties;
    for (let X of Object.keys(W)) {
      const Z = W[X];
      if (Z.type === "object") {
        if (o$($, Z))
          return true;
      } else if (Z.anyOf) {
        for (let Q = 0;Q < Z.anyOf.length; Q++)
          if (o$($, Z.anyOf[Q]))
            return true;
      }
      if (t1 in Z && Z[t1] === $)
        return true;
    }
    return false;
  }
  return Y.properties && t1 in Y.properties && Y.properties[t1] === $;
};
var D6 = Symbol.for("TypeBox.Transform");
var b1 = ($) => {
  if (!$)
    return;
  if ($.type === "object") {
    const Y = $.properties;
    for (let W of Object.keys(Y)) {
      const X = Y[W];
      if (X.type === "object") {
        if (b1(X))
          return true;
      } else if (X.anyOf) {
        for (let Q = 0;Q < X.anyOf.length; Q++)
          if (b1(X.anyOf[Q]))
            return true;
      }
      if (D6 in X)
        return true;
    }
    return false;
  }
  return D6 in $ || $.properties && D6 in $.properties;
};
var D7 = ($) => {
  if (!$)
    return;
  const Y = $?.schema;
  if (Y && "anyOf" in Y) {
    let W = false;
    const X = Y.anyOf[0].type;
    for (let Z of Y.anyOf)
      if (Z.type !== X) {
        W = true;
        break;
      }
    if (!W)
      return X;
  }
  return $.schema?.type;
};
var w7 = /(?:return|=>) \S*\(/g;
var N0 = ($) => {
  if ($.constructor.name === "AsyncFunction")
    return true;
  return $.toString().match(w7);
};
var hW = ({ path: $, method: Y, hooks: W, validator: X, handler: Z, handleError: Q, definitions: J, schema: z, onRequest: U, config: D, reporter: B }) => {
  const j = D.forceErrorEncapsulation || W.error.length > 0 || typeof Bun === "undefined" || W.onResponse.length > 0 || !!W.trace.length, b = W.onResponse.length ? `\n;(async () => {${W.onResponse.map((R, f) => `await res${f}(c)`).join(";")}})();\n` : "", S = W.trace.map((R) => R.toString());
  let N = false;
  if (w$(Z.toString()))
    N = true;
  if (!N)
    for (let [R, f] of Object.entries(W)) {
      if (!Array.isArray(f) || !f.length || !["parse", "transform", "beforeHandle", "afterHandle", "onResponse"].includes(R))
        continue;
      for (let i of f) {
        if (typeof i !== "function")
          continue;
        if (w$(i.toString())) {
          N = true;
          break;
        }
      }
      if (N)
        break;
    }
  const O = { parse: S.some((R) => K0("parse", R)), transform: S.some((R) => K0("transform", R)), handle: S.some((R) => K0("handle", R)), beforeHandle: S.some((R) => K0("beforeHandle", R)), afterHandle: S.some((R) => K0("afterHandle", R)), error: j || S.some((R) => K0("error", R)) }, P = W.trace.length > 0;
  let F = "";
  if (P)
    F += "\nconst id = c.$$requestId\n";
  F += j ? "try {\n" : "";
  const w = X || Y !== "GET" && Y !== "HEAD" ? [Z, ...W.transform, ...W.beforeHandle, ...W.afterHandle].map((R) => R.toString()) : [], I = N || Y !== "GET" && Y !== "HEAD" && W.type !== "none" && (!!X.body || !!W.type || w.some((R) => K0("body", R))), G = N || X.headers || w.some((R) => K0("headers", R)), k = N || X.cookie || w.some((R) => K0("cookie", R)), _ = X?.cookie?.schema;
  let e = "";
  if (_?.sign) {
    if (!_.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${Y}) ${$}.`);
    const R = !_.secrets ? undefined : typeof _.secrets === "string" ? _.secrets : _.secrets[0];
    if (e += `const _setCookie = c.set.cookie
		if(_setCookie) {`, _.sign === true)
      e += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = signCookie(cookie.value, '${R}')
			}`;
    else
      for (let f of _.sign)
        e += `if(_setCookie['${f}']?.value) { c.set.cookie['${f}'].value = signCookie(_setCookie['${f}'].value, '${R}') }\n`;
    e += "}\n";
  }
  const { composeValidation: o, composeResponseValidation: r } = B7(j);
  if (G)
    F += A7 ? "c.headers = c.request.headers.toJSON()\n" : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
  if (k) {
    const R = (i, n) => {
      const q0 = _?.[i] ?? n;
      if (!q0)
        return typeof n === "string" ? `${i}: "${n}",` : `${i}: ${n},`;
      if (typeof q0 === "string")
        return `${i}: '${q0}',`;
      if (q0 instanceof Date)
        return `${i}: new Date(${q0.getTime()}),`;
      return `${i}: ${q0},`;
    }, f = _ ? `{
			secret: ${_.secrets !== undefined ? typeof _.secrets === "string" ? `'${_.secrets}'` : "[" + _.secrets.reduce((i, n) => i + `'${n}',`, "") + "]" : "undefined"},
			sign: ${_.sign === true ? true : _.sign !== undefined ? "[" + _.sign.reduce((i, n) => i + `'${n}',`, "") + "]" : "undefined"},
			${R("domain")}
			${R("expires")}
			${R("httpOnly")}
			${R("maxAge")}
			${R("path", "/")}
			${R("priority")}
			${R("sameSite")}
			${R("secure")}
		}` : "undefined";
    if (G)
      F += `\nc.cookie = parseCookie(c.set, c.headers.cookie, ${f})\n`;
    else
      F += `\nc.cookie = parseCookie(c.set, c.request.headers.get('cookie'), ${f})\n`;
  }
  if (N || X.query || w.some((R) => K0("query", R)))
    F += `const url = c.request.url

		if(c.qi !== -1) {
			c.query ??= parseQuery(url.substring(c.qi + 1))
		} else {
			c.query ??= {}
		}
		`;
  const E0 = W.trace.map((R) => R.toString()).some((R) => K0("set", R) || w$(R));
  N || W.trace.some((R) => K0("set", R.toString()));
  const H0 = E0 || k || w.some((R) => K0("set", R)) || U.some((R) => K0("set", R.toString())), z0 = uW({ hasTrace: P, hasTraceSet: E0, condition: O, addFn: (R) => {
    F += R;
  } });
  if (P)
    F += "\nconst traceDone = new Promise(r => { reporter.once(`res${id}`, r) })\n";
  const u0 = I || E0 || N0(Z) || W.parse.length > 0 || W.afterHandle.some(N0) || W.beforeHandle.some(N0) || W.transform.some(N0), a0 = z0("parse", { unit: W.parse.length });
  if (I) {
    const R = D7(X?.body);
    if (W.type && !Array.isArray(W.type)) {
      if (W.type)
        switch (W.type) {
          case "json":
          case "application/json":
            F += "c.body = await c.request.json()\n";
            break;
          case "text":
          case "text/plain":
            F += "c.body = await c.request.text()\n";
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            F += "c.body = parseQuery(await c.request.text())\n";
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            F += "c.body = await c.request.arrayBuffer()\n";
            break;
          case "formdata":
          case "multipart/form-data":
            F += `c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}\n`;
            break;
        }
      if (W.parse.length)
        F += "}}";
    } else {
      const i = (() => {
        if (W.parse.length && R && !Array.isArray(W.type)) {
          const n = X?.body?.schema;
          switch (R) {
            case "object":
              if (o$("File", n) || o$("Files", n))
                return `c.body = {}
		
								const form = await c.request.formData()
								for (const key of form.keys()) {
									if (c.body[key])
										continue
			
									const value = form.getAll(key)
									if (value.length === 1)
										c.body[key] = value[0]
									else c.body[key] = value
								}`;
              break;
            default:
              break;
          }
        }
      })();
      if (i)
        F += i;
      else {
        if (F += "\n", F += G ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", F += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)\n`, W.parse.length) {
          F += "let used = false\n";
          const n = z0("parse", { unit: W.parse.length });
          for (let q0 = 0;q0 < W.parse.length; q0++) {
            const B0 = z0("parse.unit", { name: W.parse[q0].name }), D0 = `bo${q0}`;
            if (q0 !== 0)
              F += "if(!used) {\n";
            if (F += `let ${D0} = parse[${q0}](c, contentType)\n`, F += `if(${D0} instanceof Promise) ${D0} = await ${D0}\n`, F += `if(${D0} !== undefined) { c.body = ${D0}; used = true }\n`, B0(), q0 !== 0)
              F += "}";
          }
          n();
        }
        if (W.parse.length)
          F += "if (!used)";
        F += `
				switch (contentType) {
					case 'application/json':
						c.body = await c.request.json()
						break
				
					case 'text/plain':
						c.body = await c.request.text()
						break
				
					case 'application/x-www-form-urlencoded':
						c.body = parseQuery(await c.request.text())
						break
				
					case 'application/octet-stream':
						c.body = await c.request.arrayBuffer();
						break
				
					case 'multipart/form-data':
						c.body = {}
				
						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue
				
							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}
				
						break
					}\n`, F += "}\n";
      }
    }
    F += "\n";
  }
  if (a0(), W?.transform) {
    const R = z0("transform", { unit: W.transform.length });
    for (let f = 0;f < W.transform.length; f++) {
      const i = W.transform[f], n = z0("transform.unit", { name: i.name });
      if (i.$elysia === "derive")
        F += N0(W.transform[f]) ? `Object.assign(c, await transform[${f}](c));` : `Object.assign(c, transform[${f}](c));`;
      else
        F += N0(W.transform[f]) ? `await transform[${f}](c);` : `transform[${f}](c);`;
      n();
    }
    R();
  }
  if (X) {
    if (F += "\n", X.headers) {
      if (F += `if(headers.Check(c.headers) === false) {
				${o("headers")}
			}`, b1(X.headers.schema))
        F += "\nc.headers = headers.Decode(c.headers)\n";
    }
    if (X.params) {
      if (F += `if(params.Check(c.params) === false) {
				${o("params")}
			}`, b1(X.params.schema))
        F += "\nc.params = params.Decode(c.params)\n";
    }
    if (X.query) {
      if (F += `if(query.Check(c.query) === false) {
				${o("query")} 
			}`, b1(X.query.schema))
        F += "\nc.query = query.Decode(Object.assign({}, c.query))\n";
    }
    if (X.body) {
      if (F += `if(body.Check(c.body) === false) { 
				${o("body")}
			}`, b1(X.body.schema))
        F += "\nc.body = body.Decode(c.body)\n";
    }
    if (t0(X.cookie?.schema.properties ?? {})) {
      if (F += `const cookieValue = {}
			for(const [key, value] of Object.entries(c.cookie))
				cookieValue[key] = value.value

			if(cookie.Check(cookieValue) === false) {
				${o("cookie", "cookieValue")}
			}`, b1(X.cookie.schema))
        F += "\nc.cookie = params.Decode(c.cookie)\n";
    }
  }
  if (W?.beforeHandle) {
    const R = z0("beforeHandle", { unit: W.beforeHandle.length });
    for (let f = 0;f < W.beforeHandle.length; f++) {
      const i = z0("beforeHandle.unit", { name: W.beforeHandle[f].name }), n = `be${f}`;
      if (!D$(W.beforeHandle[f].toString()))
        F += N0(W.beforeHandle[f]) ? `await beforeHandle[${f}](c);\n` : `beforeHandle[${f}](c);\n`, i();
      else {
        F += N0(W.beforeHandle[f]) ? `let ${n} = await beforeHandle[${f}](c);\n` : `let ${n} = beforeHandle[${f}](c);\n`, i(), F += `if(${n} !== undefined) {\n`;
        const B0 = z0("afterHandle", { unit: W.transform.length });
        if (W.afterHandle) {
          const D0 = n;
          for (let w0 = 0;w0 < W.afterHandle.length; w0++) {
            const M0 = D$(W.afterHandle[w0].toString()), B1 = z0("afterHandle.unit", { name: W.afterHandle[w0].name });
            if (F += `c.response = ${D0}\n`, !M0)
              F += N0(W.afterHandle[w0]) ? `await afterHandle[${w0}](c, ${D0});\n` : `afterHandle[${w0}](c, ${D0});\n`;
            else {
              const K = `af${w0}`;
              F += N0(W.afterHandle[w0]) ? `const ${K} = await afterHandle[${w0}](c);\n` : `const ${K} = afterHandle[${w0}](c);\n`, F += `if(${K} !== undefined) { c.response = ${D0} = ${K} }\n`;
            }
            B1();
          }
        }
        if (B0(), X.response)
          F += r(n);
        F += e, F += `return mapEarlyResponse(${n}, c.set)}\n`;
      }
    }
    R();
  }
  if (W?.afterHandle.length) {
    const R = z0("handle", { name: Z.name });
    if (W.afterHandle.length)
      F += N0(Z) ? "let r = c.response = await handler(c);\n" : "let r = c.response = handler(c);\n";
    else
      F += N0(Z) ? "let r = await handler(c);\n" : "let r = handler(c);\n";
    R();
    const f = z0("afterHandle", { unit: W.afterHandle.length });
    for (let i = 0;i < W.afterHandle.length; i++) {
      const n = `af${i}`, q0 = D$(W.afterHandle[i].toString()), B0 = z0("afterHandle.unit", { name: W.afterHandle[i].name });
      if (!q0)
        F += N0(W.afterHandle[i]) ? `await afterHandle[${i}](c)\n` : `afterHandle[${i}](c)\n`, B0();
      else {
        if (X.response)
          F += N0(W.afterHandle[i]) ? `let ${n} = await afterHandle[${i}](c)\n` : `let ${n} = afterHandle[${i}](c)\n`;
        else
          F += N0(W.afterHandle[i]) ? `let ${n} = mapEarlyResponse(await afterHandle[${i}](c), c.set)\n` : `let ${n} = mapEarlyResponse(afterHandle[${i}](c), c.set)\n`;
        if (B0(), X.response)
          F += `if(${n} !== undefined) {`, F += r(n), F += `${n} = mapEarlyResponse(${n}, c.set)\n`, F += `if(${n}) {`, f(), F += `return ${n} } }`;
        else
          F += `if(${n}) {`, f(), F += `return ${n}}\n`;
      }
    }
    if (f(), F += "r = c.response\n", X.response)
      F += r();
    if (F += e, H0)
      F += "return mapResponse(r, c.set)\n";
    else
      F += "return mapCompactResponse(r)\n";
  } else {
    const R = z0("handle", { name: Z.name });
    if (X.response)
      if (F += N0(Z) ? "const r = await handler(c);\n" : "const r = handler(c);\n", R(), F += r(), z0("afterHandle")(), F += e, H0)
        F += "return mapResponse(r, c.set)\n";
      else
        F += "return mapCompactResponse(r)\n";
    else if (O.handle || k)
      if (F += N0(Z) ? "let r = await handler(c);\n" : "let r = handler(c);\n", R(), z0("afterHandle")(), F += e, H0)
        F += "return mapResponse(r, c.set)\n";
      else
        F += "return mapCompactResponse(r)\n";
    else {
      R();
      const f = N0(Z) ? "await handler(c) " : "handler(c)";
      if (z0("afterHandle")(), H0)
        F += `return mapResponse(${f}, c.set)\n`;
      else
        F += `return mapCompactResponse(${f})\n`;
    }
  }
  if (j || b) {
    if (F += `
} catch(error) {`, !u0)
      F += "return (async () => {";
    F += `const set = c.set

		if (!set.status || set.status < 300) set.status = 500
	`;
    const R = z0("error", { unit: W.error.length });
    if (W.error.length)
      for (let f = 0;f < W.error.length; f++) {
        const i = `er${f}`, n = z0("error.unit", { name: W.error[f].name });
        if (F += `\nlet ${i} = handleErrors[${f}](
					Object.assign(c, {
						error: error,
						code: error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
					})
				)\n`, N0(W.error[f]))
          F += `if (${i} instanceof Promise) ${i} = await ${i}\n`;
        n(), F += `${i} = mapEarlyResponse(${i}, set)\n`, F += `if (${i}) {`, F += `return ${i} }\n`;
      }
    if (R(), F += "return handleError(c, error)\n\n", !u0)
      F += "})()";
    if (F += "}", b || P) {
      F += " finally { ";
      const f = z0("response", { unit: W.onResponse.length });
      F += b, f(), F += "}";
    }
  }
  return F = `const { 
		handler,
		handleError,
		hooks: {
			transform,
			beforeHandle,
			afterHandle,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		schema,
		definitions,
		ERROR_CODE,
		reporter,
		requestId,
		parseCookie,
		signCookie
	} = hooks

	${W.onResponse.length ? `const ${W.onResponse.map((R, f) => `res${f} = onResponse[${f}]`).join(",")}` : ""}

	return ${u0 ? "async" : ""} function(c) {
		${z && J ? "c.schema = schema; c.defs = definitions;" : ""}
		${F}
	}`, Function("hooks", F)({ handler: Z, hooks: W, validator: X, handleError: Q, utils: { mapResponse: A1, mapCompactResponse: K1, mapEarlyResponse: r0, parseQuery: pW.parse }, error: { NotFoundError: S1, ValidationError: P0, InternalServerError: f$ }, schema: z, definitions: J, ERROR_CODE: n1, reporter: B, requestId: mW, parseCookie: h$, signCookie: I1 });
};
var w6 = ($) => {
  let Y = "", W = "";
  for (let j of Object.keys($.decorators))
    Y += `,${j}: app.decorators.${j}`;
  const { router: X, staticRouter: Z } = $, Q = $.event.trace.length > 0, J = `
	const route = find(request.method, path) ${X.root.ALL ? '?? find("ALL", path)' : ""}
	if (route === null)
		return ${$.event.error.length ? "app.handleError(ctx, notFound)" : `new Response(error404, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})`}

	ctx.params = route.params

	return route.store(ctx)`;
  let z = "";
  for (let [j, { code: b, all: S }] of Object.entries(Z.map))
    z += `case '${j}':\nswitch(request.method) {\n${b}\n${S ?? "default: break map"}}\n\n`;
  const U = $.event.request.some(N0);
  W += `const {
		app,
		app: { store, router, staticRouter },
		mapEarlyResponse,
		NotFoundError,
		requestId,
		reporter
	} = data

	const notFound = new NotFoundError()

	${$.event.request.length ? "const onRequest = app.event.request" : ""}

	${Z.variables}

	const find = router.find.bind(router)
	const handleError = app.handleError.bind(this)

	${$.event.error.length ? "" : "const error404 = notFound.message.toString()"}

	return ${U ? "async" : ""} function map(request) {
	`;
  const D = $.event.trace.map((j) => j.toString()), B = uW({ hasTrace: Q, hasTraceSet: $.event.trace.some((j) => {
    const b = j.toString();
    return K0("set", b) || w$(b);
  }), condition: { request: D.some((j) => K0("request", j) || w$(j)) }, addFn: (j) => {
    W += j;
  } });
  if ($.event.request.length) {
    W += `
			${Q ? "const id = +requestId.value++" : ""}

			const ctx = {
				request,
				store,
				set: {
					cookie: {},
					headers: {},
					status: 200
				}
				${Q ? ",$$requestId: +id" : ""}
				${Y}
			}
		`;
    const j = B("request", { attribute: "ctx", unit: $.event.request.length });
    W += "try {\n";
    for (let b = 0;b < $.event.request.length; b++) {
      const S = $.event.request[b], N = D$(S.toString()), O = N0(S), P = B("request.unit", { name: $.event.request[b].name }), F = `re${b}`;
      if (N)
        W += `const ${F} = mapEarlyResponse(
					${O ? "await" : ""} onRequest[${b}](ctx),
					ctx.set
				)\n`, P(), W += `if(${F}) return ${F}\n`;
      else
        W += `${O ? "await" : ""} onRequest[${b}](ctx)\n`, P();
    }
    W += `} catch (error) {
			return app.handleError(ctx, error)
		}`, j(), W += `
		const url = request.url,
		s = url.indexOf('/', 11),
		i = ctx.qi = url.indexOf('?', s + 1),
		path = ctx.path = i === -1 ? url.substring(s) : url.substring(s, i);`;
  } else
    W += `
		const url = request.url,
			s = url.indexOf('/', 11),
			qi = url.indexOf('?', s + 1),
			path = qi === -1
				? url.substring(s)
				: url.substring(s, qi)

		${Q ? "const id = +requestId.value++" : ""}

		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: {},
				status: 200
			}
			${Q ? ",$$requestId: id" : ""}
			${Y}
		}`, B("request", { unit: $.event.request.length, attribute: D.some((j) => K0("context", j)) || D.some((j) => K0("store", j)) || D.some((j) => K0("set", j)) ? "ctx" : "" })();
  return W += `
		map: switch(path) {
			${z}

			default:
				break
		}

		${J}
	}`, $.handleError = K6($), Function("data", W)({ app: $, mapEarlyResponse: r0, NotFoundError: S1, reporter: $.reporter, requestId: mW });
};
var K6 = ($) => {
  let Y = `const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE
	} = inject

	return ${$.event.error.find(N0) ? "async" : ""} function(context, error) {
		const { set } = context
		`;
  for (let W = 0;W < $.event.error.length; W++) {
    const X = $.event.error[W], Z = `${N0(X) ? "await " : ""}onError[${W}](
			Object.assign(context, {
				code: error.code ?? error[ERROR_CODE] ?? 'UNKNOWN',
				error
			})
		)`;
    if (D$(X.toString()))
      Y += `const r${W} = ${Z}; if(r${W} !== undefined) return mapResponse(r${W}, set)\n`;
    else
      Y += Z + "\n";
  }
  return Y += `if(error.constructor.name === "ValidationError") {
		set.status = error.status ?? 400
		return new Response(
			error.message, 
			{ headers: set.headers, status: set.status }
		)
	} else {
		return new Response(error.message, { headers: set.headers, status: error.status ?? 500 })
	}
}`, Function("inject", Y)({ app: $, mapResponse: A1, ERROR_CODE: n1 });
};
var n$ = Q1(B6(), 1);
var j6 = ($) => async (Y) => {
  const W = { cookie: {}, status: 200, headers: {} };
  let X;
  if ($.decorators)
    X = $.decorators, X.request = Y, X.set = W, X.store = $.store;
  else
    X = { set: W, store: $.store, request: Y };
  const Z = Y.url, Q = Z.indexOf("/", 11), J = Z.indexOf("?", Q + 1), z = J === -1 ? Z.substring(Q) : Z.substring(Q, J);
  try {
    for (let P = 0;P < $.event.request.length; P++) {
      const F = $.event.request[P];
      let w = F(X);
      if (w instanceof Promise)
        w = await w;
      if (w = r0(w, W), w)
        return w;
    }
    const U = $.dynamicRouter.find(Y.method, z) ?? $.dynamicRouter.find("ALL", z);
    if (!U)
      throw new S1;
    const { handle: D, hooks: B, validator: j, content: b } = U.store;
    let S;
    if (Y.method !== "GET" && Y.method !== "HEAD")
      if (b)
        switch (b) {
          case "application/json":
            S = await Y.json();
            break;
          case "text/plain":
            S = await Y.text();
            break;
          case "application/x-www-form-urlencoded":
            S = n$.parse(await Y.text());
            break;
          case "application/octet-stream":
            S = await Y.arrayBuffer();
            break;
          case "multipart/form-data":
            S = {};
            const P = await Y.formData();
            for (let F of P.keys()) {
              if (S[F])
                continue;
              const w = P.getAll(F);
              if (w.length === 1)
                S[F] = w[0];
              else
                S[F] = w;
            }
            break;
        }
      else {
        let P = Y.headers.get("content-type");
        if (P) {
          const F = P.indexOf(";");
          if (F !== -1)
            P = P.slice(0, F);
          for (let w = 0;w < $.event.parse.length; w++) {
            let I = $.event.parse[w](X, P);
            if (I instanceof Promise)
              I = await I;
            if (I) {
              S = I;
              break;
            }
          }
          if (S === undefined)
            switch (P) {
              case "application/json":
                S = await Y.json();
                break;
              case "text/plain":
                S = await Y.text();
                break;
              case "application/x-www-form-urlencoded":
                S = n$.parse(await Y.text());
                break;
              case "application/octet-stream":
                S = await Y.arrayBuffer();
                break;
              case "multipart/form-data":
                S = {};
                const w = await Y.formData();
                for (let I of w.keys()) {
                  if (S[I])
                    continue;
                  const G = w.getAll(I);
                  if (G.length === 1)
                    S[I] = G[0];
                  else
                    S[I] = G;
                }
                break;
            }
        }
      }
    X.body = S, X.params = U?.params || undefined, X.query = J === -1 ? {} : n$.parse(Z.substring(J + 1)), X.headers = {};
    for (let [P, F] of Y.headers.entries())
      X.headers[P] = F;
    const N = j?.cookie?.schema;
    X.cookie = h$(X.set, X.headers.cookie, N ? { secret: N.secrets !== undefined ? typeof N.secrets === "string" ? N.secrets : N.secrets.join(",") : undefined, sign: N.sign === true ? true : N.sign !== undefined ? typeof N.sign === "string" ? N.sign : N.sign.join(",") : undefined } : undefined);
    for (let P = 0;P < B.transform.length; P++) {
      const F = B.transform[P](X);
      if (B.transform[P].$elysia === "derive")
        if (F instanceof Promise)
          Object.assign(X, await F);
        else
          Object.assign(X, F);
      else if (F instanceof Promise)
        await F;
    }
    if (j) {
      if (j.headers) {
        const P = {};
        for (let F in Y.headers)
          P[F] = Y.headers.get(F);
        if (j.headers.Check(P) === false)
          throw new P0("header", j.headers, P);
      }
      if (j.params?.Check(X.params) === false)
        throw new P0("params", j.params, X.params);
      if (j.query?.Check(X.query) === false)
        throw new P0("query", j.query, X.query);
      if (j.cookie) {
        const P = {};
        for (let [F, w] of Object.entries(X.cookie))
          P[F] = w.value;
        if (j.cookie?.Check(P) === false)
          throw new P0("cookie", j.cookie, P);
      }
      if (j.body?.Check(S) === false)
        throw new P0("body", j.body, S);
    }
    for (let P = 0;P < B.beforeHandle.length; P++) {
      let F = B.beforeHandle[P](X);
      if (F instanceof Promise)
        F = await F;
      if (F !== undefined) {
        X.response = F;
        for (let I = 0;I < B.afterHandle.length; I++) {
          let G = B.afterHandle[I](X);
          if (G instanceof Promise)
            G = await G;
          if (G)
            F = G;
        }
        const w = r0(F, X.set);
        if (w)
          return w;
      }
    }
    let O = D(X);
    if (O instanceof Promise)
      O = await O;
    if (!B.afterHandle.length) {
      const P = j?.response?.[O.status];
      if (P?.Check(O) === false)
        throw new P0("response", P, O);
    } else {
      X.response = O;
      for (let P = 0;P < B.afterHandle.length; P++) {
        let F = B.afterHandle[P](X);
        if (F instanceof Promise)
          F = await F;
        const w = r0(F, X.set);
        if (w !== undefined) {
          const I = j?.response?.[O.status];
          if (I?.Check(w) === false)
            throw new P0("response", I, w);
          return w;
        }
      }
    }
    if (X.set.cookie && N?.sign) {
      const P = !N.secrets ? undefined : typeof N.secrets === "string" ? N.secrets : N.secrets[0];
      if (N.sign === true)
        for (let [F, w] of Object.entries(X.set.cookie))
          X.set.cookie[F].value = I1(w.value, "${secret}");
      else
        for (let F of N.sign) {
          if (!(F in N.properties))
            continue;
          if (X.set.cookie[F]?.value)
            X.set.cookie[F].value = I1(X.set.cookie[F].value, P);
        }
    }
    return A1(O, X.set);
  } catch (U) {
    if (U.status)
      W.status = U.status;
    return $.handleError(X, U);
  } finally {
    for (let U of $.event.onResponse)
      await U(X);
  }
};
var oW = ($) => async (Y, W) => {
  const X = Object.assign(Y, W);
  X.set = Y.set;
  for (let Z = 0;Z < $.event.error.length; Z++) {
    let Q = $.event.error[Z](X);
    if (Q instanceof Promise)
      Q = await Q;
    if (Q !== undefined && Q !== null)
      return A1(Q, Y.set);
  }
  return new Response(typeof W.cause === "string" ? W.cause : W.message, { headers: Y.set.headers, status: W.status ?? 500 });
};
var G1 = Q1(E$(), 1);
var Y0 = Q1(f0(), 1);
try {
  G1.TypeSystem.Format("email", ($) => /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test($)), G1.TypeSystem.Format("uuid", ($) => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test($)), G1.TypeSystem.Format("date", ($) => !Number.isNaN(new Date($).getTime())), G1.TypeSystem.Format("date-time", ($) => !Number.isNaN(new Date($).getTime()));
} catch ($) {
}
var nW = ($) => {
  if (typeof $ === "string")
    switch ($.slice(-1)) {
      case "k":
        return +$.slice(0, $.length - 1) * 1024;
      case "m":
        return +$.slice(0, $.length - 1) * 1048576;
      default:
        return +$;
    }
  return $;
};
var P6 = ($, Y) => {
  if (!(Y instanceof Blob))
    return false;
  if ($.minSize && Y.size < nW($.minSize))
    return false;
  if ($.maxSize && Y.size > nW($.maxSize))
    return false;
  if ($.extension)
    if (typeof $.extension === "string") {
      if (!Y.type.startsWith($.extension))
        return false;
    } else {
      for (let W = 0;W < $.extension.length; W++)
        if (Y.type.startsWith($.extension[W]))
          return true;
      return false;
    }
  return true;
};
var K7 = G1.TypeSystem.Type("Files", ($, Y) => {
  if (!Array.isArray(Y))
    return P6($, Y);
  if ($.minItems && Y.length < $.minItems)
    return false;
  if ($.maxItems && Y.length > $.maxItems)
    return false;
  for (let W = 0;W < Y.length; W++)
    if (!P6($, Y[W]))
      return false;
  return true;
});
Y0.FormatRegistry.Set("numeric", ($) => !isNaN(+$));
Y0.FormatRegistry.Set("ObjectString", ($) => {
  let Y = $.charCodeAt(0);
  if (Y === 9 || Y === 10 || Y === 32)
    Y = $.trimStart().charCodeAt(0);
  if (Y !== 123 && Y !== 91)
    return false;
  try {
    return JSON.parse($), true;
  } catch {
    return false;
  }
});
var R1 = { Numeric: ($) => Y0.Type.Transform(Y0.Type.Union([Y0.Type.String({ format: "numeric", default: 0 }), Y0.Type.Number($)])).Decode((Y) => {
  const W = +Y;
  if (isNaN(W))
    return Y;
  return W;
}).Encode((Y) => Y), ObjectString: ($, Y) => Y0.Type.Transform(Y0.Type.Union([Y0.Type.String({ format: "ObjectString", default: "" }), Y0.Type.Object($, Y)])).Decode((W) => {
  if (typeof W === "string")
    try {
      return JSON.parse(W);
    } catch {
      return W;
    }
  return W;
}).Encode((W) => JSON.stringify(W)), File: G1.TypeSystem.Type("File", P6), Files: ($ = {}) => Y0.Type.Transform(Y0.Type.Union([K7($)])).Decode((Y) => {
  if (Array.isArray(Y))
    return Y;
  return [Y];
}).Encode((Y) => Y), Nullable: ($) => Y0.Type.Union([Y0.Type.Null(), $]), MaybeEmpty: ($) => Y0.Type.Union([Y0.Type.Null(), Y0.Type.Undefined(), $]), Cookie: ($, Y) => Y0.Type.Object($, Y) };
Y0.Type.ObjectString = R1.ObjectString;
Y0.Type.Numeric = R1.Numeric;
Y0.Type.File = ($ = {}) => R1.File({ default: "File", ...$, extension: $?.type, type: "string", format: "binary" });
Y0.Type.Files = ($ = {}) => R1.Files({ ...$, elysiaMeta: "Files", default: "Files", extension: $?.type, type: "array", items: { ...$, default: "Files", type: "string", format: "binary" } });
Y0.Type.Nullable = ($) => R1.Nullable($);
Y0.Type.MaybeEmpty = R1.MaybeEmpty;
Y0.Type.Cookie = R1.Cookie;

class c$ {
  config;
  dependencies = {};
  store = {};
  decorators = {};
  definitions = { type: {}, error: {} };
  schema = {};
  event = { start: [], request: [], parse: [], transform: [], beforeHandle: [], afterHandle: [], onResponse: [], trace: [], error: [], stop: [] };
  reporter = new R6;
  server = null;
  getServer() {
    return this.server;
  }
  validator = null;
  router = new E1;
  routes = [];
  staticRouter = { handlers: [], variables: "", map: {}, all: "" };
  dynamicRouter = new E1;
  lazyLoadModules = [];
  path = "";
  constructor($) {
    this.config = { forceErrorEncapsulation: false, prefix: "", aot: true, strictPath: false, scoped: false, cookie: {}, ...$, seed: $?.seed === undefined ? "" : $?.seed };
  }
  add($, Y, W, X, { allowMeta: Z = false, skipPrefix: Q = false } = { allowMeta: false, skipPrefix: false }) {
    if (typeof Y === "string")
      Y = [Y];
    for (let J of Y) {
      if (J = J === "" ? J : J.charCodeAt(0) === 47 ? J : `/${J}`, this.config.prefix && !Q)
        J = this.config.prefix + J;
      if (X?.type)
        switch (X.type) {
          case "text":
            X.type = "text/plain";
            break;
          case "json":
            X.type = "application/json";
            break;
          case "formdata":
            X.type = "multipart/form-data";
            break;
          case "urlencoded":
            X.type = "application/x-www-form-urlencoded";
            break;
          case "arrayBuffer":
            X.type = "application/octet-stream";
            break;
          default:
            break;
        }
      const z = this.definitions.type;
      let U = X1(X?.cookie ?? this.validator?.cookie, { dynamic: !this.config.aot, models: z, additionalProperties: true });
      if (t0(this.config.cookie ?? {}))
        if (U)
          U.schema = DW(U.schema, this.config.cookie ?? {});
        else
          U = X1(Y0.Type.Cookie({}, this.config.cookie), { dynamic: !this.config.aot, models: z, additionalProperties: true });
      const D = { body: X1(X?.body ?? this.validator?.body, { dynamic: !this.config.aot, models: z }), headers: X1(X?.headers ?? this.validator?.headers, { dynamic: !this.config.aot, models: z, additionalProperties: true }), params: X1(X?.params ?? this.validator?.params, { dynamic: !this.config.aot, models: z }), query: X1(X?.query ?? this.validator?.query, { dynamic: !this.config.aot, models: z }), cookie: U, response: q6(X?.response ?? this.validator?.response, { dynamic: !this.config.aot, models: z }) }, B = C1(this.event, X), j = J.endsWith("/") ? J.slice(0, J.length - 1) : J + "/";
      if (this.config.aot === false) {
        if (this.dynamicRouter.add($, J, { validator: D, hooks: B, content: X?.type, handle: W }), this.config.strictPath === false)
          this.dynamicRouter.add($, j, { validator: D, hooks: B, content: X?.type, handle: W });
        this.routes.push({ method: $, path: J, composed: null, handler: W, hooks: B });
        return;
      }
      const b = hW({ path: J, method: $, hooks: B, validator: D, handler: W, handleError: this.handleError, onRequest: this.event.request, config: this.config, definitions: Z ? this.definitions.type : undefined, schema: Z ? this.schema : undefined, reporter: this.reporter }), S = this.routes.findIndex((N) => N.path === J && N.method === $);
      if (S !== -1)
        this.routes.splice(S, 1);
      if (this.routes.push({ method: $, path: J, composed: b, handler: W, hooks: B }), J.indexOf(":") === -1 && J.indexOf("*") === -1) {
        const N = this.staticRouter.handlers.length;
        if (this.staticRouter.handlers.push(b), this.staticRouter.variables += `const st${N} = staticRouter.handlers[${N}]\n`, !this.staticRouter.map[J])
          this.staticRouter.map[J] = { code: "" };
        if ($ === "ALL")
          this.staticRouter.map[J].all = `default: return st${N}(ctx)\n`;
        else
          this.staticRouter.map[J].code = `case '${$}': return st${N}(ctx)\n${this.staticRouter.map[J].code}`;
        if (!this.config.strictPath) {
          if (!this.staticRouter.map[j])
            this.staticRouter.map[j] = { code: "" };
          if ($ === "ALL")
            this.staticRouter.map[j].all = `default: return st${N}(ctx)\n`;
          else
            this.staticRouter.map[j].code = `case '${$}': return st${N}(ctx)\n${this.staticRouter.map[j].code}`;
        }
      } else if (this.router.add($, J, b), !this.config.strictPath)
        this.router.add($, J.endsWith("/") ? J.slice(0, J.length - 1) : J + "/", b);
    }
  }
  onStart($) {
    return this.on("start", $), this;
  }
  onRequest($) {
    return this.on("request", $), this;
  }
  onParse($) {
    return this.on("parse", $), this;
  }
  onTransform($) {
    return this.on("transform", $), this;
  }
  onBeforeHandle($) {
    return this.on("beforeHandle", $), this;
  }
  onAfterHandle($) {
    return this.on("afterHandle", $), this;
  }
  onResponse($) {
    return this.on("response", $), this;
  }
  trace($) {
    return this.reporter.on("event", _6(this.reporter, $)), this.on("trace", $), this;
  }
  addError($, Y) {
    return this.error($, Y);
  }
  error($, Y) {
    switch (typeof $) {
      case "string":
        return Y.prototype[n1] = $, this.definitions.error[$] = Y, this;
      case "function":
        return this.definitions.error = $(this.definitions.error), this;
    }
    for (let [W, X] of Object.entries($))
      X.prototype[n1] = W, this.definitions.error[W] = X;
    return this;
  }
  onError($) {
    return this.on("error", $), this;
  }
  onStop($) {
    return this.on("stop", $), this;
  }
  on($, Y) {
    for (let W of Array.isArray(Y) ? Y : [Y])
      switch (W = wW(W), $) {
        case "start":
          this.event.start.push(W);
          break;
        case "request":
          this.event.request.push(W);
          break;
        case "response":
          this.event.onResponse.push(W);
          break;
        case "parse":
          this.event.parse.splice(this.event.parse.length - 1, 0, W);
          break;
        case "transform":
          this.event.transform.push(W);
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(W);
          break;
        case "afterHandle":
          this.event.afterHandle.push(W);
          break;
        case "trace":
          this.event.trace.push(W);
          break;
        case "error":
          this.event.error.push(W);
          break;
        case "stop":
          this.event.stop.push(W);
          break;
      }
    return this;
  }
  group($, Y, W) {
    const X = new c$({ ...this.config, prefix: "" });
    X.store = this.store;
    const Z = typeof Y === "object", Q = (Z ? W : Y)(X);
    if (this.decorators = U1(this.decorators, X.decorators), Q.event.request.length)
      this.event.request = [...this.event.request, ...Q.event.request];
    if (Q.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...Q.event.onResponse];
    return this.model(Q.definitions.type), Object.values(X.routes).forEach(({ method: J, path: z, handler: U, hooks: D }) => {
      if (z = (Z ? "" : this.config.prefix) + $ + z, Z) {
        const B = Y, j = D;
        this.add(J, z, U, C1(B, { ...j, error: !j.error ? Q.event.error : Array.isArray(j.error) ? [...j.error, ...Q.event.error] : [j.error, ...Q.event.error] }));
      } else
        this.add(J, z, U, C1(D, { error: Q.event.error }), { skipPrefix: true });
    }), this;
  }
  guard($, Y) {
    if (!Y)
      return this.event = m$(this.event, $), this.validator = { body: $.body, headers: $.headers, params: $.params, query: $.query, response: $.response }, this;
    const W = new c$;
    W.store = this.store;
    const X = Y(W);
    if (this.decorators = U1(this.decorators, W.decorators), X.event.request.length)
      this.event.request = [...this.event.request, ...X.event.request];
    if (X.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...X.event.onResponse];
    return this.model(X.definitions.type), Object.values(W.routes).forEach(({ method: Z, path: Q, handler: J, hooks: z }) => {
      this.add(Z, Q, J, C1($, { ...z, error: !z.error ? X.event.error : Array.isArray(z.error) ? [...z.error, ...X.event.error] : [z.error, ...X.event.error] }));
    }), this;
  }
  use($) {
    if ($ instanceof Promise)
      return this.lazyLoadModules.push($.then((Y) => {
        if (typeof Y === "function")
          return Y(this);
        if (typeof Y.default === "function")
          return Y.default(this);
        return this._use(Y);
      }).then((Y) => Y.compile())), this;
    else
      return this._use($);
    return this;
  }
  _use($) {
    if (typeof $ === "function") {
      const Z = $(this);
      if (Z instanceof Promise)
        return this.lazyLoadModules.push(Z.then((Q) => {
          if (typeof Q === "function")
            return Q(this);
          if (typeof Q.default === "function")
            return Q.default(this);
          return this._use(Q);
        }).then((Q) => Q.compile())), this;
      return Z;
    }
    const { name: Y, seed: W } = $.config;
    $.getServer = () => this.getServer();
    const X = $.config.scoped;
    if (X) {
      if (Y) {
        if (!(Y in this.dependencies))
          this.dependencies[Y] = [];
        const Q = W !== undefined ? M6(Y + JSON.stringify(W)) : 0;
        if (this.dependencies[Y].some((J) => Q === J))
          return this;
        this.dependencies[Y].push(Q);
      }
      if ($.model(this.definitions.type), $.error(this.definitions.error), $.onRequest((Q) => {
        Object.assign(Q, this.decorators), Object.assign(Q.store, this.store);
      }), $.event.trace = [...this.event.trace, ...$.event.trace], $.config.aot)
        $.compile();
      const Z = this.mount($.fetch);
      return this.routes = this.routes.concat(Z.routes), this;
    }
    this.decorate($.decorators), this.state($.store), this.model($.definitions.type), this.error($.definitions.error);
    for (let { method: Z, path: Q, handler: J, hooks: z } of Object.values($.routes))
      this.add(Z, Q, J, C1(z, { error: $.event.error }));
    if (!X)
      if (Y) {
        if (!(Y in this.dependencies))
          this.dependencies[Y] = [];
        const Z = W !== undefined ? M6(Y + JSON.stringify(W)) : 0;
        if (this.dependencies[Y].some((Q) => Z === Q))
          return this;
        this.dependencies[Y].push(Z), this.event = m$(this.event, N6($.event), Z);
      } else
        this.event = m$(this.event, N6($.event));
    return this;
  }
  mount($, Y) {
    if (typeof $ === "function" || $.length === 0 || $ === "/") {
      const Z = typeof $ === "function" ? $ : Y, Q = async ({ request: J, path: z }) => Z(new Request("http://a.cc" + z || "/", J));
      return this.all("/", Q, { type: "none" }), this.all("/*", Q, { type: "none" }), this;
    }
    const W = $.length, X = async ({ request: Z, path: Q }) => Y(new Request("http://a.cc" + Q.slice(W) || "/", Z));
    return this.all($, X, { type: "none" }), this.all($ + ($.endsWith("/") ? "*" : "/*"), X, { type: "none" }), this;
  }
  get($, Y, W) {
    return this.add("GET", $, Y, W), this;
  }
  post($, Y, W) {
    return this.add("POST", $, Y, W), this;
  }
  put($, Y, W) {
    return this.add("PUT", $, Y, W), this;
  }
  patch($, Y, W) {
    return this.add("PATCH", $, Y, W), this;
  }
  delete($, Y, W) {
    return this.add("DELETE", $, Y, W), this;
  }
  options($, Y, W) {
    return this.add("OPTIONS", $, Y, W), this;
  }
  all($, Y, W) {
    return this.add("ALL", $, Y, W), this;
  }
  head($, Y, W) {
    return this.add("HEAD", $, Y, W), this;
  }
  connect($, Y, W) {
    return this.add("CONNECT", $, Y, W), this;
  }
  ws($, Y) {
    const W = Y.transformMessage ? Array.isArray(Y.transformMessage) ? Y.transformMessage : [Y.transformMessage] : undefined;
    let X = null;
    const Z = X1(Y?.body, { models: this.definitions.type }), Q = X1(Y?.response, { models: this.definitions.type }), J = (z) => {
      const U = z.charCodeAt(0);
      if (U === 47 || U === 123)
        try {
          z = JSON.parse(z);
        } catch {
        }
      else if (!Number.isNaN(+z))
        z = +z;
      if (W?.length)
        for (let D = 0;D < W.length; D++) {
          const B = W[D](z);
          if (B !== undefined)
            z = B;
        }
      return z;
    };
    return this.get($, (z) => {
      const { set: U, path: D, qi: B, headers: j, query: b, params: S } = z;
      if (X === null)
        X = this.getServer();
      if (X?.upgrade(z.request, { headers: typeof Y.upgrade === "function" ? Y.upgrade(z) : Y.upgrade, data: { validator: Q, open(N) {
        Y.open?.(new c1(N, z));
      }, message: (N, O) => {
        const P = J(O);
        if (Z?.Check(P) === false)
          return void N.send(new P0("message", Z, P).message);
        Y.message?.(new c1(N, z), P);
      }, drain(N) {
        Y.drain?.(new c1(N, z));
      }, close(N, O, P) {
        Y.close?.(new c1(N, z), O, P);
      } } }))
        return;
      return U.status = 400, "Expected a websocket connection";
    }, { beforeHandle: Y.beforeHandle, transform: Y.transform, headers: Y.headers, params: Y.params, query: Y.query }), this;
  }
  route($, Y, W, { config: X, ...Z } = { config: { allowMeta: false } }) {
    return this.add($, Y, W, Z, X), this;
  }
  state($, Y) {
    switch (typeof $) {
      case "object":
        return this.store = U1(this.store, $), this;
      case "function":
        return this.store = $(this.store), this;
    }
    if (!($ in this.store))
      this.store[$] = Y;
    return this;
  }
  decorate($, Y) {
    switch (typeof $) {
      case "object":
        return this.decorators = U1(this.decorators, $), this;
      case "function":
        return this.decorators = $(this.decorators), this;
    }
    if (!($ in this.decorators))
      this.decorators[$] = Y;
    return this;
  }
  derive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  model($, Y) {
    switch (typeof $) {
      case "object":
        return Object.entries($).forEach(([W, X]) => {
          if (!(W in this.definitions.type))
            this.definitions.type[W] = X;
        }), this;
      case "function":
        return this.definitions.type = $(this.definitions.type), this;
    }
    return this.definitions.type[$] = Y, this;
  }
  mapDerive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  affix($, Y, W) {
    if (W === "")
      return this;
    const X = ["_", "-", " "], Z = (U) => U[0].toUpperCase() + U.slice(1), Q = $ === "prefix" ? (U, D) => X.includes(U.at(-1) ?? "") ? U + D : U + Z(D) : X.includes(W.at(-1) ?? "") ? (U, D) => D + U : (U, D) => D + Z(U), J = (U) => {
      const D = {};
      switch (U) {
        case "decorator":
          for (let B in this.decorators)
            D[Q(W, B)] = this.decorators[B];
          this.decorators = D;
          break;
        case "state":
          for (let B in this.store)
            D[Q(W, B)] = this.store[B];
          this.store = D;
          break;
        case "model":
          for (let B in this.definitions.type)
            D[Q(W, B)] = this.definitions.type[B];
          this.definitions.type = D;
          break;
        case "error":
          for (let B in this.definitions.error)
            D[Q(W, B)] = this.definitions.error[B];
          this.definitions.error = D;
          break;
      }
    }, z = Array.isArray(Y) ? Y : [Y];
    for (let U of z.some((D) => D === "all") ? ["decorator", "state", "model", "error"] : z)
      J(U);
    return this;
  }
  prefix($, Y) {
    return this.affix("prefix", $, Y);
  }
  suffix($, Y) {
    return this.affix("suffix", $, Y);
  }
  compile() {
    if (this.fetch = this.config.aot ? w6(this) : j6(this), typeof this.server?.reload === "function")
      this.server.reload({ ...this.server, fetch: this.fetch });
    return this;
  }
  handle = async ($) => this.fetch($);
  fetch = ($) => (this.fetch = this.config.aot ? w6(this) : j6(this))($);
  handleError = async ($, Y) => (this.handleError = this.config.aot ? K6(this) : oW(this))($, Y);
  outerErrorHandler = ($) => new Response($.message || $.name || "Error", { status: $?.status ?? 500 });
  listen = ($, Y) => {
    if (!Bun)
      throw new Error("Bun to run");
    if (this.compile(), typeof $ === "string") {
      if ($ = +$.trim(), Number.isNaN($))
        throw new Error("Port must be a numeric value");
    }
    const W = this.fetch, X = typeof $ === "object" ? { development: !q$, ...this.config.serve, ...$, websocket: { ...this.config.websocket, ...W6 }, fetch: W, error: this.outerErrorHandler } : { development: !q$, ...this.config.serve, websocket: { ...this.config.websocket, ...W6 }, port: $, fetch: W, error: this.outerErrorHandler };
    if (typeof Bun === "undefined")
      throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    if (this.server = Bun?.serve(X), this.event.start.length)
      (async () => {
        const Z = Object.assign(this.decorators, { store: this.store, app: this });
        for (let Q = 0;Q < this.event.transform.length; Q++) {
          const J = this.event.transform[Q](Z);
          if (this.event.transform[Q].$elysia === "derive")
            if (J instanceof Promise)
              Object.assign(Z, await J);
            else
              Object.assign(Z, J);
        }
        for (let Q = 0;Q < this.event.start.length; Q++)
          this.event.start[Q](Z);
      })();
    if (Y)
      Y(this.server);
    return Promise.all(this.lazyLoadModules).then(() => {
      Bun?.gc(false);
    }), this;
  };
  stop = async () => {
    if (!this.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    if (this.server.stop(), this.event.stop.length)
      (async () => {
        const $ = Object.assign(this.decorators, { store: this.store, app: this });
        for (let Y = 0;Y < this.event.transform.length; Y++) {
          const W = this.event.transform[Y]($);
          if (this.event.transform[Y].$elysia === "derive")
            if (W instanceof Promise)
              Object.assign($, await W);
            else
              Object.assign($, W);
        }
        for (let Y = 0;Y < this.event.stop.length; Y++)
          this.event.stop[Y]($);
      })();
  };
  get modules() {
    return Promise.all(this.lazyLoadModules);
  }
}
var export_t = Y0.Type;

// ../../node_modules/@elysiajs/cors/dist/index.js
var cors = (config = {
  origin: true,
  methods: "*",
  allowedHeaders: "*",
  exposedHeaders: "*",
  credentials: false,
  maxAge: 5,
  preflight: true
}) => {
  const { origin = true, methods = "*", allowedHeaders = "*", exposedHeaders = "*", credentials = false, maxAge = 5, preflight = true } = config;
  const app = new c$({
    name: "@elysiajs/cors",
    seed: config
  });
  const origins = typeof origin === "boolean" ? undefined : Array.isArray(origin) ? origin : [origin];
  const processOrigin = (origin2, request, from) => {
    switch (typeof origin2) {
      case "string":
        const protocolStart = from.indexOf("://");
        if (protocolStart === -1)
          return false;
        return origin2 === from.slice(protocolStart + 3);
      case "function":
        return origin2(request);
      case "object":
        return origin2.test(from);
    }
  };
  const handleOrigin = (set, request) => {
    if (origin === true) {
      set.headers["Vary"] = "*";
      set.headers["Access-Control-Allow-Origin"] = "*";
      return;
    }
    if (!origins?.length)
      return;
    const headers = [];
    if (origins.length) {
      const from = request.headers.get("Origin") ?? "";
      for (let i = 0;i < origins.length; i++) {
        const value = processOrigin(origins[i], request, from);
        if (value === true) {
          set.headers["Vary"] = origin ? "Origin" : "*";
          set.headers["Access-Control-Allow-Origin"] = request.headers.get("Origin") ?? "*";
          return;
        }
        if (value)
          headers.push(value);
      }
    }
    set.headers["Vary"] = "Origin";
    set.headers["Access-Control-Allow-Origin"] = headers.join(", ");
  };
  const handleMethod = (set) => {
    if (!methods?.length)
      return;
    if (methods === "*")
      return set.headers["Access-Control-Allow-Methods"] = "*";
    if (!Array.isArray(methods))
      return set.headers["Access-Control-Allow-Methods"] = methods;
    set.headers["Access-Control-Allow-Methods"] = methods.join(", ");
  };
  if (preflight)
    app.options("/", ({ set, request }) => {
      handleOrigin(set, request);
      handleMethod(set);
      if (exposedHeaders.length)
        set.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
      if (maxAge)
        set.headers["Access-Control-Max-Age"] = maxAge.toString();
      return new Response("", {
        status: 204
      });
    }).options("/*", ({ set, request }) => {
      handleOrigin(set, request);
      handleMethod(set);
      if (exposedHeaders.length)
        set.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
      if (maxAge)
        set.headers["Access-Control-Max-Age"] = maxAge.toString();
      return new Response("", {
        status: 204
      });
    });
  return app.onRequest(({ set, request }) => {
    handleOrigin(set, request);
    handleMethod(set);
    if (allowedHeaders.length)
      set.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
    if (exposedHeaders.length)
      set.headers["Access-Control-Exposed-Headers"] = typeof exposedHeaders === "string" ? exposedHeaders : exposedHeaders.join(", ");
    if (credentials)
      set.headers["Access-Control-Allow-Credentials"] = "true";
  });
};

// ../../node_modules/graphql/version.mjs
var versionInfo = Object.freeze({
  major: 16,
  minor: 9,
  patch: 0,
  preReleaseTag: null
});
// ../../node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}

// ../../node_modules/graphql/jsutils/isPromise.mjs
function isPromise(value) {
  return typeof (value === null || value === undefined ? undefined : value.then) === "function";
}

// ../../node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value) {
  return typeof value == "object" && value !== null;
}

// ../../node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}

// ../../node_modules/graphql/language/location.mjs
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}
var LineRegExp = /\r\n|[\n\r]/g;

// ../../node_modules/graphql/language/printLocation.mjs
function printLocation(location2) {
  return printSourceLocation(location2.source, getLocation(location2.source, location2.start));
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}\n`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i = 0;i < locationLine.length; i += 80) {
      subLines.push(locationLine.slice(i, i + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
var printPrefixedLines = function(lines) {
  const existingLines = lines.filter(([_, line]) => line !== undefined);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
};

// ../../node_modules/graphql/error/GraphQLError.mjs
var toNormalizedOptions = function(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
};
var undefinedIfEmpty = function(array) {
  return array === undefined || array.length === 0 ? undefined : array;
};
class GraphQLError extends Error {
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path !== null && path !== undefined ? path : undefined;
    this.originalError = originalError !== null && originalError !== undefined ? originalError : undefined;
    this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : undefined);
    const nodeLocations = undefinedIfEmpty((_this$nodes = this.nodes) === null || _this$nodes === undefined ? undefined : _this$nodes.map((node) => node.loc).filter((loc) => loc != null));
    this.source = source !== null && source !== undefined ? source : nodeLocations === null || nodeLocations === undefined ? undefined : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === undefined ? undefined : _nodeLocations$.source;
    this.positions = positions !== null && positions !== undefined ? positions : nodeLocations === null || nodeLocations === undefined ? undefined : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === undefined ? undefined : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(originalError === null || originalError === undefined ? undefined : originalError.extensions) ? originalError === null || originalError === undefined ? undefined : originalError.extensions : undefined;
    this.extensions = (_ref = extensions !== null && extensions !== undefined ? extensions : originalExtensions) !== null && _ref !== undefined ? _ref : Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== undefined && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output = this.message;
    if (this.nodes) {
      for (const node of this.nodes) {
        if (node.loc) {
          output += "\n\n" + printLocation(node.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location3 of this.locations) {
        output += "\n\n" + printSourceLocation(this.source, location3);
      }
    }
    return output;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
}

// ../../node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position]
  });
}

// ../../node_modules/graphql/language/ast.mjs
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === undefined ? undefined : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}

class Location {
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}

class Token {
  constructor(kind, start, end, line, column, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var kindValues = new Set(Object.keys(QueryDocumentKeys));
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));

// ../../node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));

// ../../node_modules/graphql/language/kinds.mjs
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));

// ../../node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}

// ../../node_modules/graphql/language/blockString.mjs
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i = 0;i < lines.length; ++i) {
    var _firstNonEmptyLine;
    const line = lines[i];
    const indent = leadingWhitespace(line);
    if (indent === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== undefined ? _firstNonEmptyLine : i;
    lastNonEmptyLine = i;
    if (i !== 0 && indent < commonIndent) {
      commonIndent = indent;
    }
  }
  return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice((_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== undefined ? _firstNonEmptyLine2 : 0, lastNonEmptyLine + 1);
}
var leadingWhitespace = function(str) {
  let i = 0;
  while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {
    ++i;
  }
  return i;
};
function isPrintableAsBlockString(value) {
  if (value === "") {
    return true;
  }
  let isEmptyLine = true;
  let hasIndent = false;
  let hasCommonIndent = true;
  let seenNonEmptyLine = false;
  for (let i = 0;i < value.length; ++i) {
    switch (value.codePointAt(i)) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 11:
      case 12:
      case 14:
      case 15:
        return false;
      case 13:
        return false;
      case 10:
        if (isEmptyLine && !seenNonEmptyLine) {
          return false;
        }
        seenNonEmptyLine = true;
        isEmptyLine = true;
        hasIndent = false;
        break;
      case 9:
      case 32:
        hasIndent || (hasIndent = isEmptyLine);
        break;
      default:
        hasCommonIndent && (hasCommonIndent = hasIndent);
        isEmptyLine = false;
    }
  }
  if (isEmptyLine) {
    return false;
  }
  if (hasCommonIndent && seenNonEmptyLine) {
    return false;
  }
  return true;
}
function printBlockString(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== undefined && options.minimize) && (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}

// ../../node_modules/graphql/language/tokenKind.mjs
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));

// ../../node_modules/graphql/language/lexer.mjs
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
var isUnicodeScalarValue = function(code) {
  return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
};
var isSupplementaryCodePoint = function(body, location3) {
  return isLeadingSurrogate(body.charCodeAt(location3)) && isTrailingSurrogate(body.charCodeAt(location3 + 1));
};
var isLeadingSurrogate = function(code) {
  return code >= 55296 && code <= 56319;
};
var isTrailingSurrogate = function(code) {
  return code >= 56320 && code <= 57343;
};
var printCodePointAt = function(lexer, location3) {
  const code = lexer.source.body.codePointAt(location3);
  if (code === undefined) {
    return TokenKind.EOF;
  } else if (code >= 32 && code <= 126) {
    const char = String.fromCodePoint(code);
    return char === '"' ? "'\"'" : `"${char}"`;
  }
  return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
};
var createToken = function(lexer, kind, start, end, value) {
  const line = lexer.line;
  const col = 1 + start - lexer.lineStart;
  return new Token(kind, start, end, line, col, value);
};
var readNextToken = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position;
        continue;
      case 10:
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 13:
        if (body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 35:
        return readComment(lexer, position);
      case 33:
        return createToken(lexer, TokenKind.BANG, position, position + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position, position + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
      case 46:
        if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position, position + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position, position + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position, position + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position, position + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position, position + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
      case 34:
        if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          return readBlockString(lexer, position);
        }
        return readString(lexer, position);
    }
    if (isDigit(code) || code === 45) {
      return readNumber(lexer, position, code);
    }
    if (isNameStart(code)) {
      return readName(lexer, position);
    }
    throw syntaxError(lexer.source, position, code === 39 ? 'Unexpected single quote character (\'), did you mean to use a double quote (")?' : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`);
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
};
var readComment = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      break;
    }
  }
  return createToken(lexer, TokenKind.COMMENT, start, position, body.slice(start + 1, position));
};
var readNumber = function(lexer, start, firstCode) {
  const body = lexer.source.body;
  let position = start;
  let code = firstCode;
  let isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (isDigit(code)) {
      throw syntaxError(lexer.source, position, `Invalid number, unexpected digit after 0: ${printCodePointAt(lexer, position)}.`);
    }
  } else {
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(lexer.source, position, `Invalid number, expected digit but got: ${printCodePointAt(lexer, position)}.`);
  }
  return createToken(lexer, isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, body.slice(start, position));
};
var readDigits = function(lexer, start, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(lexer.source, start, `Invalid number, expected digit but got: ${printCodePointAt(lexer, start)}.`);
  }
  const body = lexer.source.body;
  let position = start + 1;
  while (isDigit(body.charCodeAt(position))) {
    ++position;
  }
  return position;
};
var readString = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  let chunkStart = position;
  let value = "";
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return createToken(lexer, TokenKind.STRING, start, position + 1, value);
    }
    if (code === 92) {
      value += body.slice(chunkStart, position);
      const escape2 = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
      value += escape2.value;
      position += escape2.size;
      chunkStart = position;
      continue;
    }
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
};
var readEscapedUnicodeVariableWidth = function(lexer, position) {
  const body = lexer.source.body;
  let point = 0;
  let size = 3;
  while (size < 12) {
    const code = body.charCodeAt(position + size++);
    if (code === 125) {
      if (size < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size
      };
    }
    point = point << 4 | readHexDigit(code);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + size)}".`);
};
var readEscapedUnicodeFixedWidth = function(lexer, position) {
  const body = lexer.source.body;
  const code = read16BitHexCode(body, position + 2);
  if (isUnicodeScalarValue(code)) {
    return {
      value: String.fromCodePoint(code),
      size: 6
    };
  }
  if (isLeadingSurrogate(code)) {
    if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`);
};
var read16BitHexCode = function(body, position) {
  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
};
var readHexDigit = function(code) {
  return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
};
var readEscapedCharacter = function(lexer, position) {
  const body = lexer.source.body;
  const code = body.charCodeAt(position + 1);
  switch (code) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: `
`,
        size: 2
      };
    case 114:
      return {
        value: `\r`,
        size: 2
      };
    case 116:
      return {
        value: "\t",
        size: 2
      };
  }
  throw syntaxError(lexer.source, position, `Invalid character escape sequence: "${body.slice(position, position + 2)}".`);
};
var readBlockString = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position = start + 3;
  let chunkStart = position;
  let currentLine = "";
  const blockLines = [];
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      const token = createToken(lexer, TokenKind.BLOCK_STRING, start, position + 3, dedentBlockStringLines(blockLines).join("\n"));
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token;
    }
    if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      currentLine += body.slice(chunkStart, position);
      chunkStart = position + 1;
      position += 4;
      continue;
    }
    if (code === 10 || code === 13) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      if (code === 13 && body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      currentLine = "";
      chunkStart = position;
      lineStart = position;
      continue;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
};
var readName = function(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (isNameContinue(code)) {
      ++position;
    } else {
      break;
    }
  }
  return createToken(lexer, TokenKind.NAME, start, position, body.slice(start, position));
};

class Lexer {
  constructor(source) {
    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  advance() {
    this.lastToken = this.token;
    const token = this.token = this.lookahead();
    return token;
  }
  lookahead() {
    let token = this.token;
    if (token.kind !== TokenKind.EOF) {
      do {
        if (token.next) {
          token = token.next;
        } else {
          const nextToken = readNextToken(this, token.end);
          token.next = nextToken;
          nextToken.prev = token;
          token = nextToken;
        }
      } while (token.kind === TokenKind.COMMENT);
    }
    return token;
  }
}

// ../../node_modules/graphql/jsutils/inspect.mjs
function inspect(value) {
  return formatValue(value, []);
}
var formatValue = function(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
};
var formatObjectValue = function(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
};
var isJSONable = function(value) {
  return typeof value.toJSON === "function";
};
var formatObject = function(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
  return "{ " + properties.join(", ") + " }";
};
var formatArray = function(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i = 0;i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
};
var getObjectTag = function(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
};
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;

// ../../node_modules/graphql/jsutils/instanceOf.mjs
var isProduction = globalThis.process && true;
var instanceOf = isProduction ? function instanceOf2(value, constructor) {
  return value instanceof constructor;
} : function instanceOf3(value, constructor) {
  if (value instanceof constructor) {
    return true;
  }
  if (typeof value === "object" && value !== null) {
    var _value$constructor;
    const className = constructor.prototype[Symbol.toStringTag];
    const valueClassName = Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === undefined ? undefined : _value$constructor.name;
    if (className === valueClassName) {
      const stringifiedValue = inspect(value);
      throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
    }
  }
  return false;
};

// ../../node_modules/graphql/language/source.mjs
function isSource(source) {
  return instanceOf(source, Source);
}

class Source {
  constructor(body, name = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
    this.body = body;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(false, "line in locationOffset is 1-indexed and must be positive.");
    this.locationOffset.column > 0 || devAssert(false, "column in locationOffset is 1-indexed and must be positive.");
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}

// ../../node_modules/graphql/language/parser.mjs
function parse(source2, options) {
  const parser = new Parser(source2, options);
  return parser.parseDocument();
}
var getTokenDesc = function(token) {
  const value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
};
var getTokenKindDesc = function(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
};

class Parser {
  constructor(source2, options = {}) {
    const sourceObj = isSource(source2) ? source2 : new Source(source2);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
    this._tokenCounter = 0;
  }
  parseName() {
    const token = this.expectToken(TokenKind.NAME);
    return this.node(token, {
      kind: Kind.NAME,
      value: token.value
    });
  }
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Kind.DOCUMENT,
      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF)
    });
  }
  parseDefinition() {
    if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    }
    const hasDescription = this.peekDescription();
    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (hasDescription) {
        throw syntaxError(this._lexer.source, this._lexer.token.start, "Unexpected description, descriptions are supported only on type definitions.");
      }
      switch (keywordToken.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  parseOperationDefinition() {
    const start = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return this.node(start, {
        kind: Kind.OPERATION_DEFINITION,
        operation: OperationTypeNode.QUERY,
        name: undefined,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    }
    const operation = this.parseOperationType();
    let name;
    if (this.peek(TokenKind.NAME)) {
      name = this.parseName();
    }
    return this.node(start, {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseOperationType() {
    const operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return OperationTypeNode.QUERY;
      case "mutation":
        return OperationTypeNode.MUTATION;
      case "subscription":
        return OperationTypeNode.SUBSCRIPTION;
    }
    throw this.unexpected(operationToken);
  }
  parseVariableDefinitions() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);
  }
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : undefined,
      directives: this.parseConstDirectives()
    });
  }
  parseVariable() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return this.node(start, {
      kind: Kind.VARIABLE,
      name: this.parseName()
    });
  }
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Kind.SELECTION_SET,
      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R)
    });
  }
  parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  parseField() {
    const start = this._lexer.token;
    const nameOrAlias = this.parseName();
    let alias;
    let name;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }
    return this.node(start, {
      kind: Kind.FIELD,
      alias,
      name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined
    });
  }
  parseArguments(isConst) {
    const item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  }
  parseArgument(isConst = false) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.ARGUMENT,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseConstArgument() {
    return this.parseArgument(true);
  }
  parseFragment() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    const hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return this.node(start, {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false)
      });
    }
    return this.node(start, {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseFragmentDefinition() {
    const start = this._lexer.token;
    this.expectKeyword("fragment");
    if (this._options.allowLegacyFragmentVariables === true) {
      return this.node(start, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    return this.node(start, {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  }
  parseValueLiteral(isConst) {
    const token = this._lexer.token;
    switch (token.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.INT,
          value: token.value
        });
      case TokenKind.FLOAT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.FLOAT,
          value: token.value
        });
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this.advanceLexer();
        switch (token.value) {
          case "true":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: true
            });
          case "false":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: false
            });
          case "null":
            return this.node(token, {
              kind: Kind.NULL
            });
          default:
            return this.node(token, {
              kind: Kind.ENUM,
              value: token.value
            });
        }
      case TokenKind.DOLLAR:
        if (isConst) {
          this.expectToken(TokenKind.DOLLAR);
          if (this._lexer.token.kind === TokenKind.NAME) {
            const varName = this._lexer.token.value;
            throw syntaxError(this._lexer.source, token.start, `Unexpected variable "\$${varName}" in constant value.`);
          } else {
            throw this.unexpected(token);
          }
        }
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(true);
  }
  parseStringLiteral() {
    const token = this._lexer.token;
    this.advanceLexer();
    return this.node(token, {
      kind: Kind.STRING,
      value: token.value,
      block: token.kind === TokenKind.BLOCK_STRING
    });
  }
  parseList(isConst) {
    const item = () => this.parseValueLiteral(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
    });
  }
  parseObject(isConst) {
    const item = () => this.parseObjectField(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
    });
  }
  parseObjectField(isConst) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.OBJECT_FIELD,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseDirectives(isConst) {
    const directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  }
  parseConstDirectives() {
    return this.parseDirectives(true);
  }
  parseDirective(isConst) {
    const start = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return this.node(start, {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst)
    });
  }
  parseTypeReference() {
    const start = this._lexer.token;
    let type;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      const innerType = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type = this.node(start, {
        kind: Kind.LIST_TYPE,
        type: innerType
      });
    } else {
      type = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return this.node(start, {
        kind: Kind.NON_NULL_TYPE,
        type
      });
    }
    return type;
  }
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: Kind.NAMED_TYPE,
      name: this.parseName()
    });
  }
  peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  }
  parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  parseSchemaDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    return this.node(start, {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives,
      operationTypes
    });
  }
  parseOperationTypeDefinition() {
    const start = this._lexer.token;
    const operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    const type = this.parseNamedType();
    return this.node(start, {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type
    });
  }
  parseScalarTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name,
      directives
    });
  }
  parseObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
  }
  parseFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);
  }
  parseFieldDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.FIELD_DEFINITION,
      description,
      name,
      arguments: args,
      type,
      directives
    });
  }
  parseArgumentDefs() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);
  }
  parseInputValueDef() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    let defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseConstValueLiteral();
    }
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name,
      type,
      defaultValue,
      directives
    });
  }
  parseInterfaceTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseUnionTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    return this.node(start, {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name,
      directives,
      types
    });
  }
  parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  }
  parseEnumTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    return this.node(start, {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name,
      directives,
      values
    });
  }
  parseEnumValuesDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);
  }
  parseEnumValueDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseEnumValueName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name,
      directives
    });
  }
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
      throw syntaxError(this._lexer.source, this._lexer.token.start, `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`);
    }
    return this.parseName();
  }
  parseInputObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name,
      directives,
      fields
    });
  }
  parseInputFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);
  }
  parseTypeSystemExtension() {
    const keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  parseSchemaExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCHEMA_EXTENSION,
      directives,
      operationTypes
    });
  }
  parseScalarTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    if (directives.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name,
      directives
    });
  }
  parseObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseInterfaceTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  parseUnionTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    if (directives.length === 0 && types.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.UNION_TYPE_EXTENSION,
      name,
      directives,
      types
    });
  }
  parseEnumTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name,
      directives,
      values
    });
  }
  parseInputObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name,
      directives,
      fields
    });
  }
  parseDirectiveDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    const repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const locations = this.parseDirectiveLocations();
    return this.node(start, {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name,
      arguments: args,
      repeatable,
      locations
    });
  }
  parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  }
  parseDirectiveLocation() {
    const start = this._lexer.token;
    const name = this.parseName();
    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
      return name;
    }
    throw this.unexpected(start);
  }
  node(startToken, node) {
    if (this._options.noLocation !== true) {
      node.loc = new Location(startToken, this._lexer.lastToken, this._lexer.source);
    }
    return node;
  }
  peek(kind) {
    return this._lexer.token.kind === kind;
  }
  expectToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return token;
    }
    throw syntaxError(this._lexer.source, token.start, `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`);
  }
  expectOptionalToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  expectKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
    } else {
      throw syntaxError(this._lexer.source, token.start, `Expected "${value}", found ${getTokenDesc(token)}.`);
    }
  }
  expectOptionalKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  unexpected(atToken) {
    const token = atToken !== null && atToken !== undefined ? atToken : this._lexer.token;
    return syntaxError(this._lexer.source, token.start, `Unexpected ${getTokenDesc(token)}.`);
  }
  any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  }
  optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  }
  many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  }
  delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  }
  advanceLexer() {
    const { maxTokens } = this._options;
    const token = this._lexer.advance();
    if (maxTokens !== undefined && token.kind !== TokenKind.EOF) {
      ++this._tokenCounter;
      if (this._tokenCounter > maxTokens) {
        throw syntaxError(this._lexer.source, token.start, `Document contains more that ${maxTokens} tokens. Parsing aborted.`);
      }
    }
  }
}

// ../../node_modules/graphql/jsutils/didYouMean.mjs
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [undefined, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x) => `"${x}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}
var MAX_SUGGESTIONS = 5;

// ../../node_modules/graphql/jsutils/identityFunc.mjs
function identityFunc(x) {
  return x;
}

// ../../node_modules/graphql/jsutils/keyMap.mjs
function keyMap(list, keyFn) {
  const result = Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = item;
  }
  return result;
}

// ../../node_modules/graphql/jsutils/keyValMap.mjs
function keyValMap(list, keyFn, valFn) {
  const result = Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = valFn(item);
  }
  return result;
}

// ../../node_modules/graphql/jsutils/mapValue.mjs
function mapValue(map, fn) {
  const result = Object.create(null);
  for (const key of Object.keys(map)) {
    result[key] = fn(map[key], key);
  }
  return result;
}

// ../../node_modules/graphql/jsutils/naturalCompare.mjs
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit2(aChar) && isDigit2(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit2(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit2(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
var isDigit2 = function(code) {
  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
};
var DIGIT_0 = 48;
var DIGIT_9 = 57;

// ../../node_modules/graphql/jsutils/suggestionList.mjs
function suggestionList(input, options) {
  const optionsByDistance = Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance.measure(option, threshold);
    if (distance !== undefined) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a, b) => {
    const distanceDiff = optionsByDistance[a] - optionsByDistance[b];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b);
  });
}
var stringToArray = function(str) {
  const strLength = str.length;
  const array = new Array(strLength);
  for (let i = 0;i < strLength; ++i) {
    array[i] = str.charCodeAt(i);
  }
  return array;
};

class LexicalDistance {
  constructor(input) {
    this._input = input;
    this._inputLowerCase = input.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0)
    ];
  }
  measure(option, threshold) {
    if (this._input === option) {
      return 0;
    }
    const optionLowerCase = option.toLowerCase();
    if (this._inputLowerCase === optionLowerCase) {
      return 1;
    }
    let a = stringToArray(optionLowerCase);
    let b = this._inputArray;
    if (a.length < b.length) {
      const tmp = a;
      a = b;
      b = tmp;
    }
    const aLength = a.length;
    const bLength = b.length;
    if (aLength - bLength > threshold) {
      return;
    }
    const rows = this._rows;
    for (let j = 0;j <= bLength; j++) {
      rows[0][j] = j;
    }
    for (let i = 1;i <= aLength; i++) {
      const upRow = rows[(i - 1) % 3];
      const currentRow = rows[i % 3];
      let smallestCell = currentRow[0] = i;
      for (let j = 1;j <= bLength; j++) {
        const cost = a[i - 1] === b[j - 1] ? 0 : 1;
        let currentCell = Math.min(upRow[j] + 1, currentRow[j - 1] + 1, upRow[j - 1] + cost);
        if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
          const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
        }
        if (currentCell < smallestCell) {
          smallestCell = currentCell;
        }
        currentRow[j] = currentCell;
      }
      if (smallestCell > threshold) {
        return;
      }
    }
    const distance = rows[aLength % 3][bLength];
    return distance <= threshold ? distance : undefined;
  }
}

// ../../node_modules/graphql/jsutils/toObjMap.mjs
function toObjMap(obj) {
  if (obj == null) {
    return Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map = Object.create(null);
  for (const [key, value] of Object.entries(obj)) {
    map[key] = value;
  }
  return map;
}

// ../../node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
var escapedReplacer = function(str) {
  return escapeSequences[str.charCodeAt(0)];
};
var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
var escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];

// ../../node_modules/graphql/language/visitor.mjs
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = new Map;
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = undefined;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index = -1;
  let edits = [];
  let node = root;
  let key = undefined;
  let parent = undefined;
  const path = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? undefined : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties({}, Object.getOwnPropertyDescriptors(node));
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys[index];
      node = parent[key];
      if (node === null || node === undefined) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === undefined ? undefined : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === undefined ? undefined : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === undefined ? undefined : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== undefined) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === undefined && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== undefined ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== undefined);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function visitInParallel(visitors) {
  const skipping = new Array(visitors.length).fill(null);
  const mergedVisitor = Object.create(null);
  for (const kind of Object.values(Kind)) {
    let hasVisitor = false;
    const enterList = new Array(visitors.length).fill(undefined);
    const leaveList = new Array(visitors.length).fill(undefined);
    for (let i = 0;i < visitors.length; ++i) {
      const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);
      hasVisitor || (hasVisitor = enter != null || leave != null);
      enterList[i] = enter;
      leaveList[i] = leave;
    }
    if (!hasVisitor) {
      continue;
    }
    const mergedEnterLeave = {
      enter(...args) {
        const node = args[0];
        for (let i = 0;i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _enterList$i;
            const result = (_enterList$i = enterList[i]) === null || _enterList$i === undefined ? undefined : _enterList$i.apply(visitors[i], args);
            if (result === false) {
              skipping[i] = node;
            } else if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== undefined) {
              return result;
            }
          }
        }
      },
      leave(...args) {
        const node = args[0];
        for (let i = 0;i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _leaveList$i;
            const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === undefined ? undefined : _leaveList$i.apply(visitors[i], args);
            if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== undefined && result !== false) {
              return result;
            }
          } else if (skipping[i] === node) {
            skipping[i] = null;
          }
        }
      }
    };
    mergedVisitor[kind] = mergedEnterLeave;
  }
  return mergedVisitor;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: undefined
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}
var BREAK = Object.freeze({});

// ../../node_modules/graphql/language/printer.mjs
function print(ast4) {
  return visit(ast4, printDocASTReducer);
}
var join = function(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === undefined ? undefined : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== undefined ? _maybeArray$filter$jo : "";
};
var block = function(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
};
var wrap = function(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
};
var indent = function(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
};
var hasMultilineItems = function(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === undefined ? undefined : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== undefined ? _maybeArray$some : false;
};
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  Document: {
    leave: (node) => join(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
      const prefix = join([
        node.operation,
        join([node.name, varDefs]),
        join(node.directives, " ")
      ], " ");
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name;
      let argsLine = prefix + wrap("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name, value }) => name + ": " + value
  },
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join([
      "...",
      wrap("on ", typeCondition),
      join(directives, " "),
      selectionSet
    ], " ")
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} ` + `on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
  },
  IntValue: {
    leave: ({ value }) => value
  },
  FloatValue: {
    leave: ({ value }) => value
  },
  StringValue: {
    leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
  },
  BooleanValue: {
    leave: ({ value }) => value ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value }) => value
  },
  ListValue: {
    leave: ({ values }) => "[" + join(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name, value }) => name + ": " + value
  },
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
  },
  NamedType: {
    leave: ({ name }) => name
  },
  ListType: {
    leave: ({ type }) => "[" + type + "]"
  },
  NonNullType: {
    leave: ({ type }) => type + "!"
  },
  SchemaDefinition: {
    leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type }) => operation + ": " + type
  },
  ScalarTypeDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join([
      "type",
      name,
      wrap("implements ", join(interfaces, " & ")),
      join(directives, " "),
      block(fields)
    ], " ")
  },
  FieldDefinition: {
    leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join([name + ": " + type, wrap("= ", defaultValue), join(directives, " ")], " ")
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join([
      "interface",
      name,
      wrap("implements ", join(interfaces, " & ")),
      join(directives, " "),
      block(fields)
    ], " ")
  },
  UnionTypeDefinition: {
    leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(["union", name, join(directives, " "), wrap("= ", join(types, " | "))], " ")
  },
  EnumTypeDefinition: {
    leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join(["extend schema", join(directives, " "), block(operationTypes)], " ")
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join([
      "extend type",
      name,
      wrap("implements ", join(interfaces, " & ")),
      join(directives, " "),
      block(fields)
    ], " ")
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join([
      "extend interface",
      name,
      wrap("implements ", join(interfaces, " & ")),
      join(directives, " "),
      block(fields)
    ], " ")
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types }) => join([
      "extend union",
      name,
      join(directives, " "),
      wrap("= ", join(types, " | "))
    ], " ")
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
  }
};

// ../../node_modules/graphql/utilities/valueFromASTUntyped.mjs
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map((node) => valueFromASTUntyped(node, variables));
    case Kind.OBJECT:
      return keyValMap(valueNode.fields, (field) => field.name.value, (field) => valueFromASTUntyped(field.value, variables));
    case Kind.VARIABLE:
      return variables === null || variables === undefined ? undefined : variables[valueNode.name.value];
  }
}

// ../../node_modules/graphql/type/assertName.mjs
function assertName(name) {
  name != null || devAssert(false, "Must provide name.");
  typeof name === "string" || devAssert(false, "Expected name to be a string.");
  if (name.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i = 1;i < name.length; ++i) {
    if (!isNameContinue(name.charCodeAt(i))) {
      throw new GraphQLError(`Names must only contain [_a-zA-Z0-9] but "${name}" does not.`);
    }
  }
  if (!isNameStart(name.charCodeAt(0))) {
    throw new GraphQLError(`Names must start with [_a-zA-Z] but "${name}" does not.`);
  }
  return name;
}
function assertEnumValueName(name) {
  if (name === "true" || name === "false" || name === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name}`);
  }
  return assertName(name);
}

// ../../node_modules/graphql/type/definition.mjs
function isType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
}
function isScalarType(type) {
  return instanceOf(type, GraphQLScalarType);
}
function isObjectType(type) {
  return instanceOf(type, GraphQLObjectType);
}
function isInterfaceType(type) {
  return instanceOf(type, GraphQLInterfaceType);
}
function isUnionType(type) {
  return instanceOf(type, GraphQLUnionType);
}
function isEnumType(type) {
  return instanceOf(type, GraphQLEnumType);
}
function isInputObjectType(type) {
  return instanceOf(type, GraphQLInputObjectType);
}
function isListType(type) {
  return instanceOf(type, GraphQLList);
}
function isNonNullType(type) {
  return instanceOf(type, GraphQLNonNull);
}
function isInputType(type) {
  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
}
function isOutputType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);
}
function isLeafType(type) {
  return isScalarType(type) || isEnumType(type);
}
function isCompositeType(type) {
  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
}
function isAbstractType(type) {
  return isInterfaceType(type) || isUnionType(type);
}
function isWrappingType(type) {
  return isListType(type) || isNonNullType(type);
}
function isNullableType(type) {
  return isType(type) && !isNonNullType(type);
}
function getNullableType(type) {
  if (type) {
    return isNonNullType(type) ? type.ofType : type;
  }
}
function isNamedType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);
}
function getNamedType(type) {
  if (type) {
    let unwrappedType = type;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
var defineInterfaces = function(config) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk((_config$interfaces = config.interfaces) !== null && _config$interfaces !== undefined ? _config$interfaces : []);
  Array.isArray(interfaces) || devAssert(false, `${config.name} interfaces must be an Array or a function which returns an Array.`);
  return interfaces;
};
var defineFieldMap = function(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(false, `${config.name}.${fieldName} field config must be an object.`);
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(false, `${config.name}.${fieldName} field resolver must be a function if ` + `provided, but got: ${inspect(fieldConfig.resolve)}.`);
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== undefined ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(false, `${config.name}.${fieldName} args must be an object with argument names as keys.`);
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
};
function defineArguments(config) {
  return Object.entries(config).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
var isPlainObj = function(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
};
var fieldsToFieldsConfig = function(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
};
function argsToArgsConfig(args) {
  return keyValMap(args, (arg) => arg.name, (arg) => ({
    description: arg.description,
    type: arg.type,
    defaultValue: arg.defaultValue,
    deprecationReason: arg.deprecationReason,
    extensions: arg.extensions,
    astNode: arg.astNode
  }));
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === undefined;
}
var defineTypes = function(config) {
  const types = resolveReadonlyArrayThunk(config.types);
  Array.isArray(types) || devAssert(false, `Must provide Array of types or a function which returns such an array for Union ${config.name}.`);
  return types;
};
var didYouMeanEnumValue = function(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value) => value.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
};
var defineEnumValues = function(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(false, `${typeName} values must be an object with value names as keys.`);
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(false, `${typeName}.${valueName} must refer to an object with a "value" key ` + `representing an internal value but got: ${inspect(valueConfig)}.`);
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== undefined ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
};
var defineInputFieldMap = function(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(false, `${config.name} fields must be an object with field names as keys or a function which returns such an object.`);
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(false, `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`);
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
};
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === undefined;
}

class GraphQLList {
  constructor(ofType) {
    isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLNonNull {
  constructor(ofType) {
    isNullableType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL nullable type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLScalarType {
  constructor(config) {
    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
    const parseValue = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== undefined ? _config$parseValue : identityFunc;
    this.name = assertName(config.name);
    this.description = config.description;
    this.specifiedByURL = config.specifiedByURL;
    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== undefined ? _config$serialize : identityFunc;
    this.parseValue = parseValue;
    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== undefined ? _config$parseLiteral : (node, variables) => parseValue(valueFromASTUntyped(node, variables));
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== undefined ? _config$extensionASTN : [];
    config.specifiedByURL == null || typeof config.specifiedByURL === "string" || devAssert(false, `${this.name} must provide "specifiedByURL" as a string, ` + `but got: ${inspect(config.specifiedByURL)}.`);
    config.serialize == null || typeof config.serialize === "function" || devAssert(false, `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`);
    if (config.parseLiteral) {
      typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert(false, `${this.name} must provide both "parseValue" and "parseLiteral" functions.`);
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLObjectType {
  constructor(config) {
    var _config$extensionASTN2;
    this.name = assertName(config.name);
    this.description = config.description;
    this.isTypeOf = config.isTypeOf;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== undefined ? _config$extensionASTN2 : [];
    this._fields = () => defineFieldMap(config);
    this._interfaces = () => defineInterfaces(config);
    config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert(false, `${this.name} must provide "isTypeOf" as a function, ` + `but got: ${inspect(config.isTypeOf)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLInterfaceType {
  constructor(config) {
    var _config$extensionASTN3;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== undefined ? _config$extensionASTN3 : [];
    this._fields = defineFieldMap.bind(undefined, config);
    this._interfaces = defineInterfaces.bind(undefined, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(false, `${this.name} must provide "resolveType" as a function, ` + `but got: ${inspect(config.resolveType)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLUnionType {
  constructor(config) {
    var _config$extensionASTN4;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== undefined ? _config$extensionASTN4 : [];
    this._types = defineTypes.bind(undefined, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(false, `${this.name} must provide "resolveType" as a function, ` + `but got: ${inspect(config.resolveType)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    if (typeof this._types === "function") {
      this._types = this._types();
    }
    return this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLEnumType {
  constructor(config) {
    var _config$extensionASTN5;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== undefined ? _config$extensionASTN5 : [];
    this._values = typeof config.values === "function" ? config.values : defineEnumValues(this.name, config.values);
    this._valueLookup = null;
    this._nameLookup = null;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    if (typeof this._values === "function") {
      this._values = defineEnumValues(this.name, this._values());
    }
    return this._values;
  }
  getValue(name) {
    if (this._nameLookup === null) {
      this._nameLookup = keyMap(this.getValues(), (value) => value.name);
    }
    return this._nameLookup[name];
  }
  serialize(outputValue) {
    if (this._valueLookup === null) {
      this._valueLookup = new Map(this.getValues().map((enumValue2) => [enumValue2.value, enumValue2]));
    }
    const enumValue = this._valueLookup.get(outputValue);
    if (enumValue === undefined) {
      throw new GraphQLError(`Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`);
    }
    return enumValue.name;
  }
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      const valueStr = inspect(inputValue);
      throw new GraphQLError(`Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr));
    }
    const enumValue = this.getValue(inputValue);
    if (enumValue == null) {
      throw new GraphQLError(`Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue));
    }
    return enumValue.value;
  }
  parseLiteral(valueNode, _variables) {
    if (valueNode.kind !== Kind.ENUM) {
      const valueStr = print(valueNode);
      throw new GraphQLError(`Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr), {
        nodes: valueNode
      });
    }
    const enumValue = this.getValue(valueNode.value);
    if (enumValue == null) {
      const valueStr = print(valueNode);
      throw new GraphQLError(`Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr), {
        nodes: valueNode
      });
    }
    return enumValue.value;
  }
  toConfig() {
    const values = keyValMap(this.getValues(), (value) => value.name, (value) => ({
      description: value.description,
      value: value.value,
      deprecationReason: value.deprecationReason,
      extensions: value.extensions,
      astNode: value.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      values,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

class GraphQLInputObjectType {
  constructor(config) {
    var _config$extensionASTN6, _config$isOneOf;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== undefined ? _config$extensionASTN6 : [];
    this.isOneOf = (_config$isOneOf = config.isOneOf) !== null && _config$isOneOf !== undefined ? _config$isOneOf : false;
    this._fields = defineInputFieldMap.bind(undefined, config);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  toConfig() {
    const fields = mapValue(this.getFields(), (field) => ({
      description: field.description,
      type: field.type,
      defaultValue: field.defaultValue,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      isOneOf: this.isOneOf
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}

// ../../node_modules/graphql/utilities/typeComparators.mjs
function isEqualType(typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isNonNullType(typeA) && isNonNullType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  if (isListType(typeA) && isListType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  return false;
}
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type) => schema.isSubType(typeB, type));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}

// ../../node_modules/graphql/type/scalars.mjs
function isSpecifiedScalarType(type) {
  return specifiedScalarTypes.some(({ name }) => type.name === name);
}
var serializeObject = function(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
};
var GRAPHQL_MAX_INT = 2147483647;
var GRAPHQL_MIN_INT = -2147483648;
var GraphQLInt = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isInteger(num)) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${inspect(coercedValue)}`);
    }
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError("Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue));
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${inspect(inputValue)}`);
    }
    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
      throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${inputValue}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.INT) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${print(valueNode)}`, {
        nodes: valueNode
      });
    }
    const num = parseInt(valueNode.value, 10);
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${valueNode.value}`, {
        nodes: valueNode
      });
    }
    return num;
  }
});
var GraphQLFloat = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isFinite(num)) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${inspect(coercedValue)}`);
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${inspect(inputValue)}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${print(valueNode)}`, valueNode);
    }
    return parseFloat(valueNode.value);
  }
});
var GraphQLString = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (typeof coercedValue === "boolean") {
      return coercedValue ? "true" : "false";
    }
    if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
      return coercedValue.toString();
    }
    throw new GraphQLError(`String cannot represent value: ${inspect(outputValue)}`);
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      throw new GraphQLError(`String cannot represent a non string value: ${inspect(inputValue)}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING) {
      throw new GraphQLError(`String cannot represent a non string value: ${print(valueNode)}`, {
        nodes: valueNode
      });
    }
    return valueNode.value;
  }
});
var GraphQLBoolean = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue;
    }
    if (Number.isFinite(coercedValue)) {
      return coercedValue !== 0;
    }
    throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`);
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "boolean") {
      throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect(inputValue)}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.BOOLEAN) {
      throw new GraphQLError(`Boolean cannot represent a non boolean value: ${print(valueNode)}`, {
        nodes: valueNode
      });
    }
    return valueNode.value;
  }
});
var GraphQLID = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (Number.isInteger(coercedValue)) {
      return String(coercedValue);
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(outputValue)}`);
  },
  parseValue(inputValue) {
    if (typeof inputValue === "string") {
      return inputValue;
    }
    if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
      return inputValue.toString();
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
      throw new GraphQLError("ID cannot represent a non-string and non-integer value: " + print(valueNode), {
        nodes: valueNode
      });
    }
    return valueNode.value;
  }
});
var specifiedScalarTypes = Object.freeze([
  GraphQLString,
  GraphQLInt,
  GraphQLFloat,
  GraphQLBoolean,
  GraphQLID
]);

// ../../node_modules/graphql/type/directives.mjs
function isDirective(directive) {
  return instanceOf(directive, GraphQLDirective);
}
function isSpecifiedDirective(directive) {
  return specifiedDirectives.some(({ name }) => name === directive.name);
}

class GraphQLDirective {
  constructor(config) {
    var _config$isRepeatable, _config$args;
    this.name = assertName(config.name);
    this.description = config.description;
    this.locations = config.locations;
    this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== undefined ? _config$isRepeatable : false;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    Array.isArray(config.locations) || devAssert(false, `@${config.name} locations must be an Array.`);
    const args = (_config$args = config.args) !== null && _config$args !== undefined ? _config$args : {};
    isObjectLike(args) && !Array.isArray(args) || devAssert(false, `@${config.name} args must be an object with argument names as keys.`);
    this.args = defineArguments(args);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLDirective";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  }
  toString() {
    return "@" + this.name;
  }
  toJSON() {
    return this.toString();
  }
}
var GraphQLIncludeDirective = new GraphQLDirective({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Included when true."
    }
  }
});
var GraphQLSkipDirective = new GraphQLDirective({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Skipped when true."
    }
  }
});
var DEFAULT_DEPRECATION_REASON = "No longer supported";
var GraphQLDeprecatedDirective = new GraphQLDirective({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [
    DirectiveLocation.FIELD_DEFINITION,
    DirectiveLocation.ARGUMENT_DEFINITION,
    DirectiveLocation.INPUT_FIELD_DEFINITION,
    DirectiveLocation.ENUM_VALUE
  ],
  args: {
    reason: {
      type: GraphQLString,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
var GraphQLSpecifiedByDirective = new GraphQLDirective({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behavior of this scalar.",
  locations: [DirectiveLocation.SCALAR],
  args: {
    url: {
      type: new GraphQLNonNull(GraphQLString),
      description: "The URL that specifies the behavior of this scalar."
    }
  }
});
var GraphQLOneOfDirective = new GraphQLDirective({
  name: "oneOf",
  description: "Indicates exactly one field must be supplied and this field must not be `null`.",
  locations: [DirectiveLocation.INPUT_OBJECT],
  args: {}
});
var specifiedDirectives = Object.freeze([
  GraphQLIncludeDirective,
  GraphQLSkipDirective,
  GraphQLDeprecatedDirective,
  GraphQLSpecifiedByDirective,
  GraphQLOneOfDirective
]);

// ../../node_modules/graphql/jsutils/isIterableObject.mjs
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === undefined ? undefined : maybeIterable[Symbol.iterator]) === "function";
}

// ../../node_modules/graphql/utilities/astFromValue.mjs
function astFromValue(value, type) {
  if (isNonNullType(type)) {
    const astValue = astFromValue(value, type.ofType);
    if ((astValue === null || astValue === undefined ? undefined : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value === undefined) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value, itemType);
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(value)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type.getFields())) {
      const fieldValue = astFromValue(value[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type)) {
    const serialized = type.serialize(value);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;

// ../../node_modules/graphql/type/introspection.mjs
function isIntrospectionType(type) {
  return introspectionTypes.some(({ name }) => type.name === name);
}
var __Schema = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: GraphQLString,
      resolve: (schema) => schema.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
      resolve(schema) {
        return Object.values(schema.getTypeMap());
      }
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new GraphQLNonNull(__Type),
      resolve: (schema) => schema.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Directive))),
      resolve: (schema) => schema.getDirectives()
    }
  })
});
var __Directive = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (directive) => directive.name
    },
    description: {
      type: GraphQLString,
      resolve: (directive) => directive.description
    },
    isRepeatable: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (directive) => directive.isRepeatable
    },
    locations: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__DirectiveLocation))),
      resolve: (directive) => directive.locations
    },
    args: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    }
  })
});
var __DirectiveLocation = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: DirectiveLocation.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: DirectiveLocation.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: DirectiveLocation.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: DirectiveLocation.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: DirectiveLocation.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: DirectiveLocation.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: DirectiveLocation.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: DirectiveLocation.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: DirectiveLocation.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: DirectiveLocation.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: DirectiveLocation.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: DirectiveLocation.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: DirectiveLocation.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: DirectiveLocation.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: DirectiveLocation.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: DirectiveLocation.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: DirectiveLocation.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: DirectiveLocation.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: DirectiveLocation.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});
var __Type = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new GraphQLNonNull(__TypeKind),
      resolve(type) {
        if (isScalarType(type)) {
          return TypeKind.SCALAR;
        }
        if (isObjectType(type)) {
          return TypeKind.OBJECT;
        }
        if (isInterfaceType(type)) {
          return TypeKind.INTERFACE;
        }
        if (isUnionType(type)) {
          return TypeKind.UNION;
        }
        if (isEnumType(type)) {
          return TypeKind.ENUM;
        }
        if (isInputObjectType(type)) {
          return TypeKind.INPUT_OBJECT;
        }
        if (isListType(type)) {
          return TypeKind.LIST;
        }
        if (isNonNullType(type)) {
          return TypeKind.NON_NULL;
        }
        invariant(false, `Unexpected type: "${inspect(type)}".`);
      }
    },
    name: {
      type: GraphQLString,
      resolve: (type) => ("name" in type) ? type.name : undefined
    },
    description: {
      type: GraphQLString,
      resolve: (type) => ("description" in type) ? type.description : undefined
    },
    specifiedByURL: {
      type: GraphQLString,
      resolve: (obj) => ("specifiedByURL" in obj) ? obj.specifiedByURL : undefined
    },
    fields: {
      type: new GraphQLList(new GraphQLNonNull(__Field)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isObjectType(type) || isInterfaceType(type)) {
          const fields = Object.values(type.getFields());
          return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
        }
      }
    },
    interfaces: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type) {
        if (isObjectType(type) || isInterfaceType(type)) {
          return type.getInterfaces();
        }
      }
    },
    possibleTypes: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type, _args, _context, { schema }) {
        if (isAbstractType(type)) {
          return schema.getPossibleTypes(type);
        }
      }
    },
    enumValues: {
      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isEnumType(type)) {
          const values = type.getValues();
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    inputFields: {
      type: new GraphQLList(new GraphQLNonNull(__InputValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isInputObjectType(type)) {
          const values = Object.values(type.getFields());
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    ofType: {
      type: __Type,
      resolve: (type) => ("ofType" in type) ? type.ofType : undefined
    },
    isOneOf: {
      type: GraphQLBoolean,
      resolve: (type) => {
        if (isInputObjectType(type)) {
          return type.isOneOf;
        }
      }
    }
  })
});
var __Field = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (field) => field.name
    },
    description: {
      type: GraphQLString,
      resolve: (field) => field.description
    },
    args: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (field) => field.type
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (field) => field.deprecationReason
    }
  })
});
var __InputValue = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (inputValue) => inputValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (inputValue) => inputValue.description
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (inputValue) => inputValue.type
    },
    defaultValue: {
      type: GraphQLString,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(inputValue) {
        const { type, defaultValue } = inputValue;
        const valueAST = astFromValue(defaultValue, type);
        return valueAST ? print(valueAST) : null;
      }
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (obj) => obj.deprecationReason
    }
  })
});
var __EnumValue = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (enumValue) => enumValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.description
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (enumValue) => enumValue.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.deprecationReason
    }
  })
});
var TypeKind;
(function(TypeKind2) {
  TypeKind2["SCALAR"] = "SCALAR";
  TypeKind2["OBJECT"] = "OBJECT";
  TypeKind2["INTERFACE"] = "INTERFACE";
  TypeKind2["UNION"] = "UNION";
  TypeKind2["ENUM"] = "ENUM";
  TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
  TypeKind2["LIST"] = "LIST";
  TypeKind2["NON_NULL"] = "NON_NULL";
})(TypeKind || (TypeKind = {}));
var __TypeKind = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: TypeKind.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: TypeKind.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});
var SchemaMetaFieldDef = {
  name: "__schema",
  type: new GraphQLNonNull(__Schema),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (_source, _args, _context, { schema }) => schema,
  deprecationReason: undefined,
  extensions: Object.create(null),
  astNode: undefined
};
var TypeMetaFieldDef = {
  name: "__type",
  type: __Type,
  description: "Request the type information of a single type.",
  args: [
    {
      name: "name",
      description: undefined,
      type: new GraphQLNonNull(GraphQLString),
      defaultValue: undefined,
      deprecationReason: undefined,
      extensions: Object.create(null),
      astNode: undefined
    }
  ],
  resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
  deprecationReason: undefined,
  extensions: Object.create(null),
  astNode: undefined
};
var TypeNameMetaFieldDef = {
  name: "__typename",
  type: new GraphQLNonNull(GraphQLString),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (_source, _args, _context, { parentType }) => parentType.name,
  deprecationReason: undefined,
  extensions: Object.create(null),
  astNode: undefined
};
var introspectionTypes = Object.freeze([
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  __TypeKind
]);

// ../../node_modules/graphql/type/schema.mjs
function isSchema(schema) {
  return instanceOf(schema, GraphQLSchema);
}
function assertSchema(schema) {
  if (!isSchema(schema)) {
    throw new Error(`Expected ${inspect(schema)} to be a GraphQL schema.`);
  }
  return schema;
}
var collectReferencedTypes = function(type, typeSet) {
  const namedType = getNamedType(type);
  if (!typeSet.has(namedType)) {
    typeSet.add(namedType);
    if (isUnionType(namedType)) {
      for (const memberType of namedType.getTypes()) {
        collectReferencedTypes(memberType, typeSet);
      }
    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {
      for (const interfaceType of namedType.getInterfaces()) {
        collectReferencedTypes(interfaceType, typeSet);
      }
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
        for (const arg of field.args) {
          collectReferencedTypes(arg.type, typeSet);
        }
      }
    } else if (isInputObjectType(namedType)) {
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
      }
    }
  }
  return typeSet;
};

class GraphQLSchema {
  constructor(config) {
    var _config$extensionASTN, _config$directives;
    this.__validationErrors = config.assumeValid === true ? [] : undefined;
    isObjectLike(config) || devAssert(false, "Must provide configuration object.");
    !config.types || Array.isArray(config.types) || devAssert(false, `"types" must be Array if provided but got: ${inspect(config.types)}.`);
    !config.directives || Array.isArray(config.directives) || devAssert(false, '"directives" must be Array if provided but got: ' + `${inspect(config.directives)}.`);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== undefined ? _config$extensionASTN : [];
    this._queryType = config.query;
    this._mutationType = config.mutation;
    this._subscriptionType = config.subscription;
    this._directives = (_config$directives = config.directives) !== null && _config$directives !== undefined ? _config$directives : specifiedDirectives;
    const allReferencedTypes = new Set(config.types);
    if (config.types != null) {
      for (const type of config.types) {
        allReferencedTypes.delete(type);
        collectReferencedTypes(type, allReferencedTypes);
      }
    }
    if (this._queryType != null) {
      collectReferencedTypes(this._queryType, allReferencedTypes);
    }
    if (this._mutationType != null) {
      collectReferencedTypes(this._mutationType, allReferencedTypes);
    }
    if (this._subscriptionType != null) {
      collectReferencedTypes(this._subscriptionType, allReferencedTypes);
    }
    for (const directive of this._directives) {
      if (isDirective(directive)) {
        for (const arg of directive.args) {
          collectReferencedTypes(arg.type, allReferencedTypes);
        }
      }
    }
    collectReferencedTypes(__Schema, allReferencedTypes);
    this._typeMap = Object.create(null);
    this._subTypeMap = Object.create(null);
    this._implementationsMap = Object.create(null);
    for (const namedType of allReferencedTypes) {
      if (namedType == null) {
        continue;
      }
      const typeName = namedType.name;
      typeName || devAssert(false, "One of the provided types for building the Schema is missing a name.");
      if (this._typeMap[typeName] !== undefined) {
        throw new Error(`Schema must contain uniquely named types but contains multiple types named "${typeName}".`);
      }
      this._typeMap[typeName] = namedType;
      if (isInterfaceType(namedType)) {
        for (const iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name];
            if (implementations === undefined) {
              implementations = this._implementationsMap[iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            implementations.interfaces.push(namedType);
          }
        }
      } else if (isObjectType(namedType)) {
        for (const iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name];
            if (implementations === undefined) {
              implementations = this._implementationsMap[iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            implementations.objects.push(namedType);
          }
        }
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLSchema";
  }
  getQueryType() {
    return this._queryType;
  }
  getMutationType() {
    return this._mutationType;
  }
  getSubscriptionType() {
    return this._subscriptionType;
  }
  getRootType(operation) {
    switch (operation) {
      case OperationTypeNode.QUERY:
        return this.getQueryType();
      case OperationTypeNode.MUTATION:
        return this.getMutationType();
      case OperationTypeNode.SUBSCRIPTION:
        return this.getSubscriptionType();
    }
  }
  getTypeMap() {
    return this._typeMap;
  }
  getType(name) {
    return this.getTypeMap()[name];
  }
  getPossibleTypes(abstractType) {
    return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
  }
  getImplementations(interfaceType) {
    const implementations = this._implementationsMap[interfaceType.name];
    return implementations !== null && implementations !== undefined ? implementations : {
      objects: [],
      interfaces: []
    };
  }
  isSubType(abstractType, maybeSubType) {
    let map = this._subTypeMap[abstractType.name];
    if (map === undefined) {
      map = Object.create(null);
      if (isUnionType(abstractType)) {
        for (const type of abstractType.getTypes()) {
          map[type.name] = true;
        }
      } else {
        const implementations = this.getImplementations(abstractType);
        for (const type of implementations.objects) {
          map[type.name] = true;
        }
        for (const type of implementations.interfaces) {
          map[type.name] = true;
        }
      }
      this._subTypeMap[abstractType.name] = map;
    }
    return map[maybeSubType.name] !== undefined;
  }
  getDirectives() {
    return this._directives;
  }
  getDirective(name) {
    return this.getDirectives().find((directive) => directive.name === name);
  }
  toConfig() {
    return {
      description: this.description,
      query: this.getQueryType(),
      mutation: this.getMutationType(),
      subscription: this.getSubscriptionType(),
      types: Object.values(this.getTypeMap()),
      directives: this.getDirectives(),
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      assumeValid: this.__validationErrors !== undefined
    };
  }
}

// ../../node_modules/graphql/type/validate.mjs
function validateSchema(schema2) {
  assertSchema(schema2);
  if (schema2.__validationErrors) {
    return schema2.__validationErrors;
  }
  const context = new SchemaValidationContext(schema2);
  validateRootTypes(context);
  validateDirectives(context);
  validateTypes(context);
  const errors = context.getErrors();
  schema2.__validationErrors = errors;
  return errors;
}
function assertValidSchema(schema2) {
  const errors = validateSchema(schema2);
  if (errors.length !== 0) {
    throw new Error(errors.map((error) => error.message).join("\n\n"));
  }
}
var validateRootTypes = function(context) {
  const schema2 = context.schema;
  const queryType = schema2.getQueryType();
  if (!queryType) {
    context.reportError("Query root type must be provided.", schema2.astNode);
  } else if (!isObjectType(queryType)) {
    var _getOperationTypeNode;
    context.reportError(`Query root type must be Object type, it cannot be ${inspect(queryType)}.`, (_getOperationTypeNode = getOperationTypeNode(schema2, OperationTypeNode.QUERY)) !== null && _getOperationTypeNode !== undefined ? _getOperationTypeNode : queryType.astNode);
  }
  const mutationType = schema2.getMutationType();
  if (mutationType && !isObjectType(mutationType)) {
    var _getOperationTypeNode2;
    context.reportError("Mutation root type must be Object type if provided, it cannot be " + `${inspect(mutationType)}.`, (_getOperationTypeNode2 = getOperationTypeNode(schema2, OperationTypeNode.MUTATION)) !== null && _getOperationTypeNode2 !== undefined ? _getOperationTypeNode2 : mutationType.astNode);
  }
  const subscriptionType = schema2.getSubscriptionType();
  if (subscriptionType && !isObjectType(subscriptionType)) {
    var _getOperationTypeNode3;
    context.reportError("Subscription root type must be Object type if provided, it cannot be " + `${inspect(subscriptionType)}.`, (_getOperationTypeNode3 = getOperationTypeNode(schema2, OperationTypeNode.SUBSCRIPTION)) !== null && _getOperationTypeNode3 !== undefined ? _getOperationTypeNode3 : subscriptionType.astNode);
  }
};
var getOperationTypeNode = function(schema2, operation) {
  var _flatMap$find;
  return (_flatMap$find = [schema2.astNode, ...schema2.extensionASTNodes].flatMap((schemaNode) => {
    var _schemaNode$operation;
    return (_schemaNode$operation = schemaNode === null || schemaNode === undefined ? undefined : schemaNode.operationTypes) !== null && _schemaNode$operation !== undefined ? _schemaNode$operation : [];
  }).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === undefined ? undefined : _flatMap$find.type;
};
var validateDirectives = function(context) {
  for (const directive of context.schema.getDirectives()) {
    if (!isDirective(directive)) {
      context.reportError(`Expected directive but got: ${inspect(directive)}.`, directive === null || directive === undefined ? undefined : directive.astNode);
      continue;
    }
    validateName(context, directive);
    for (const arg of directive.args) {
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        context.reportError(`The type of @${directive.name}(${arg.name}:) must be Input Type ` + `but got: ${inspect(arg.type)}.`, arg.astNode);
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode;
        context.reportError(`Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`, [
          getDeprecatedDirectiveNode(arg.astNode),
          (_arg$astNode = arg.astNode) === null || _arg$astNode === undefined ? undefined : _arg$astNode.type
        ]);
      }
    }
  }
};
var validateName = function(context, node) {
  if (node.name.startsWith("__")) {
    context.reportError(`Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`, node.astNode);
  }
};
var validateTypes = function(context) {
  const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
  const typeMap = context.schema.getTypeMap();
  for (const type of Object.values(typeMap)) {
    if (!isNamedType(type)) {
      context.reportError(`Expected GraphQL named type but got: ${inspect(type)}.`, type.astNode);
      continue;
    }
    if (!isIntrospectionType(type)) {
      validateName(context, type);
    }
    if (isObjectType(type)) {
      validateFields(context, type);
      validateInterfaces(context, type);
    } else if (isInterfaceType(type)) {
      validateFields(context, type);
      validateInterfaces(context, type);
    } else if (isUnionType(type)) {
      validateUnionMembers(context, type);
    } else if (isEnumType(type)) {
      validateEnumValues(context, type);
    } else if (isInputObjectType(type)) {
      validateInputFields(context, type);
      validateInputObjectCircularRefs(type);
    }
  }
};
var validateFields = function(context, type) {
  const fields = Object.values(type.getFields());
  if (fields.length === 0) {
    context.reportError(`Type ${type.name} must define one or more fields.`, [
      type.astNode,
      ...type.extensionASTNodes
    ]);
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isOutputType(field.type)) {
      var _field$astNode;
      context.reportError(`The type of ${type.name}.${field.name} must be Output Type ` + `but got: ${inspect(field.type)}.`, (_field$astNode = field.astNode) === null || _field$astNode === undefined ? undefined : _field$astNode.type);
    }
    for (const arg of field.args) {
      const argName = arg.name;
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        var _arg$astNode2;
        context.reportError(`The type of ${type.name}.${field.name}(${argName}:) must be Input ` + `Type but got: ${inspect(arg.type)}.`, (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === undefined ? undefined : _arg$astNode2.type);
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode3;
        context.reportError(`Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`, [
          getDeprecatedDirectiveNode(arg.astNode),
          (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === undefined ? undefined : _arg$astNode3.type
        ]);
      }
    }
  }
};
var validateInterfaces = function(context, type) {
  const ifaceTypeNames = Object.create(null);
  for (const iface of type.getInterfaces()) {
    if (!isInterfaceType(iface)) {
      context.reportError(`Type ${inspect(type)} must only implement Interface types, ` + `it cannot implement ${inspect(iface)}.`, getAllImplementsInterfaceNodes(type, iface));
      continue;
    }
    if (type === iface) {
      context.reportError(`Type ${type.name} cannot implement itself because it would create a circular reference.`, getAllImplementsInterfaceNodes(type, iface));
      continue;
    }
    if (ifaceTypeNames[iface.name]) {
      context.reportError(`Type ${type.name} can only implement ${iface.name} once.`, getAllImplementsInterfaceNodes(type, iface));
      continue;
    }
    ifaceTypeNames[iface.name] = true;
    validateTypeImplementsAncestors(context, type, iface);
    validateTypeImplementsInterface(context, type, iface);
  }
};
var validateTypeImplementsInterface = function(context, type, iface) {
  const typeFieldMap = type.getFields();
  for (const ifaceField of Object.values(iface.getFields())) {
    const fieldName = ifaceField.name;
    const typeField = typeFieldMap[fieldName];
    if (!typeField) {
      context.reportError(`Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`, [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]);
      continue;
    }
    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {
      var _ifaceField$astNode, _typeField$astNode;
      context.reportError(`Interface field ${iface.name}.${fieldName} expects type ` + `${inspect(ifaceField.type)} but ${type.name}.${fieldName} ` + `is type ${inspect(typeField.type)}.`, [
        (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === undefined ? undefined : _ifaceField$astNode.type,
        (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === undefined ? undefined : _typeField$astNode.type
      ]);
    }
    for (const ifaceArg of ifaceField.args) {
      const argName = ifaceArg.name;
      const typeArg = typeField.args.find((arg) => arg.name === argName);
      if (!typeArg) {
        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`, [ifaceArg.astNode, typeField.astNode]);
        continue;
      }
      if (!isEqualType(ifaceArg.type, typeArg.type)) {
        var _ifaceArg$astNode, _typeArg$astNode;
        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) ` + `expects type ${inspect(ifaceArg.type)} but ` + `${type.name}.${fieldName}(${argName}:) is type ` + `${inspect(typeArg.type)}.`, [
          (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === undefined ? undefined : _ifaceArg$astNode.type,
          (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === undefined ? undefined : _typeArg$astNode.type
        ]);
      }
    }
    for (const typeArg of typeField.args) {
      const argName = typeArg.name;
      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
      if (!ifaceArg && isRequiredArgument(typeArg)) {
        context.reportError(`Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`, [typeArg.astNode, ifaceField.astNode]);
      }
    }
  }
};
var validateTypeImplementsAncestors = function(context, type, iface) {
  const ifaceInterfaces = type.getInterfaces();
  for (const transitive of iface.getInterfaces()) {
    if (!ifaceInterfaces.includes(transitive)) {
      context.reportError(transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`, [
        ...getAllImplementsInterfaceNodes(iface, transitive),
        ...getAllImplementsInterfaceNodes(type, iface)
      ]);
    }
  }
};
var validateUnionMembers = function(context, union) {
  const memberTypes = union.getTypes();
  if (memberTypes.length === 0) {
    context.reportError(`Union type ${union.name} must define one or more member types.`, [union.astNode, ...union.extensionASTNodes]);
  }
  const includedTypeNames = Object.create(null);
  for (const memberType of memberTypes) {
    if (includedTypeNames[memberType.name]) {
      context.reportError(`Union type ${union.name} can only include type ${memberType.name} once.`, getUnionMemberTypeNodes(union, memberType.name));
      continue;
    }
    includedTypeNames[memberType.name] = true;
    if (!isObjectType(memberType)) {
      context.reportError(`Union type ${union.name} can only include Object types, ` + `it cannot include ${inspect(memberType)}.`, getUnionMemberTypeNodes(union, String(memberType)));
    }
  }
};
var validateEnumValues = function(context, enumType) {
  const enumValues = enumType.getValues();
  if (enumValues.length === 0) {
    context.reportError(`Enum type ${enumType.name} must define one or more values.`, [enumType.astNode, ...enumType.extensionASTNodes]);
  }
  for (const enumValue of enumValues) {
    validateName(context, enumValue);
  }
};
var validateInputFields = function(context, inputObj) {
  const fields = Object.values(inputObj.getFields());
  if (fields.length === 0) {
    context.reportError(`Input Object type ${inputObj.name} must define one or more fields.`, [inputObj.astNode, ...inputObj.extensionASTNodes]);
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isInputType(field.type)) {
      var _field$astNode2;
      context.reportError(`The type of ${inputObj.name}.${field.name} must be Input Type ` + `but got: ${inspect(field.type)}.`, (_field$astNode2 = field.astNode) === null || _field$astNode2 === undefined ? undefined : _field$astNode2.type);
    }
    if (isRequiredInputField(field) && field.deprecationReason != null) {
      var _field$astNode3;
      context.reportError(`Required input field ${inputObj.name}.${field.name} cannot be deprecated.`, [
        getDeprecatedDirectiveNode(field.astNode),
        (_field$astNode3 = field.astNode) === null || _field$astNode3 === undefined ? undefined : _field$astNode3.type
      ]);
    }
    if (inputObj.isOneOf) {
      validateOneOfInputObjectField(inputObj, field, context);
    }
  }
};
var validateOneOfInputObjectField = function(type, field, context) {
  if (isNonNullType(field.type)) {
    var _field$astNode4;
    context.reportError(`OneOf input field ${type.name}.${field.name} must be nullable.`, (_field$astNode4 = field.astNode) === null || _field$astNode4 === undefined ? undefined : _field$astNode4.type);
  }
  if (field.defaultValue !== undefined) {
    context.reportError(`OneOf input field ${type.name}.${field.name} cannot have a default value.`, field.astNode);
  }
};
var createInputObjectCircularRefsValidator = function(context) {
  const visitedTypes = Object.create(null);
  const fieldPath = [];
  const fieldPathIndexByTypeName = Object.create(null);
  return detectCycleRecursive;
  function detectCycleRecursive(inputObj) {
    if (visitedTypes[inputObj.name]) {
      return;
    }
    visitedTypes[inputObj.name] = true;
    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
    const fields = Object.values(inputObj.getFields());
    for (const field of fields) {
      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {
        const fieldType = field.type.ofType;
        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
        fieldPath.push(field);
        if (cycleIndex === undefined) {
          detectCycleRecursive(fieldType);
        } else {
          const cyclePath = fieldPath.slice(cycleIndex);
          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
          context.reportError(`Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`, cyclePath.map((fieldObj) => fieldObj.astNode));
        }
        fieldPath.pop();
      }
    }
    fieldPathIndexByTypeName[inputObj.name] = undefined;
  }
};
var getAllImplementsInterfaceNodes = function(type, iface) {
  const { astNode, extensionASTNodes } = type;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((typeNode) => {
    var _typeNode$interfaces;
    return (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== undefined ? _typeNode$interfaces : [];
  }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
};
var getUnionMemberTypeNodes = function(union, typeName) {
  const { astNode, extensionASTNodes } = union;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((unionNode) => {
    var _unionNode$types;
    return (_unionNode$types = unionNode.types) !== null && _unionNode$types !== undefined ? _unionNode$types : [];
  }).filter((typeNode) => typeNode.name.value === typeName);
};
var getDeprecatedDirectiveNode = function(definitionNode) {
  var _definitionNode$direc;
  return definitionNode === null || definitionNode === undefined ? undefined : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === undefined ? undefined : _definitionNode$direc.find((node) => node.name.value === GraphQLDeprecatedDirective.name);
};

class SchemaValidationContext {
  constructor(schema2) {
    this._errors = [];
    this.schema = schema2;
  }
  reportError(message, nodes) {
    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
    this._errors.push(new GraphQLError(message, {
      nodes: _nodes
    }));
  }
  getErrors() {
    return this._errors;
  }
}

// ../../node_modules/graphql/utilities/typeFromAST.mjs
function typeFromAST(schema2, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      const innerType = typeFromAST(schema2, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema2, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind.NAMED_TYPE:
      return schema2.getType(typeNode.name.value);
  }
}

// ../../node_modules/graphql/utilities/TypeInfo.mjs
var getFieldDef = function(schema2, parentType, fieldNode) {
  const name = fieldNode.name.value;
  if (name === SchemaMetaFieldDef.name && schema2.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  }
  if (name === TypeMetaFieldDef.name && schema2.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  }
  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {
    return TypeNameMetaFieldDef;
  }
  if (isObjectType(parentType) || isInterfaceType(parentType)) {
    return parentType.getFields()[name];
  }
};
function visitWithTypeInfo(typeInfo, visitor3) {
  return {
    enter(...args) {
      const node = args[0];
      typeInfo.enter(node);
      const fn = getEnterLeaveForKind(visitor3, node.kind).enter;
      if (fn) {
        const result = fn.apply(visitor3, args);
        if (result !== undefined) {
          typeInfo.leave(node);
          if (isNode(result)) {
            typeInfo.enter(result);
          }
        }
        return result;
      }
    },
    leave(...args) {
      const node = args[0];
      const fn = getEnterLeaveForKind(visitor3, node.kind).leave;
      let result;
      if (fn) {
        result = fn.apply(visitor3, args);
      }
      typeInfo.leave(node);
      return result;
    }
  };
}

class TypeInfo {
  constructor(schema2, initialType, getFieldDefFn) {
    this._schema = schema2;
    this._typeStack = [];
    this._parentTypeStack = [];
    this._inputTypeStack = [];
    this._fieldDefStack = [];
    this._defaultValueStack = [];
    this._directive = null;
    this._argument = null;
    this._enumValue = null;
    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== undefined ? getFieldDefFn : getFieldDef;
    if (initialType) {
      if (isInputType(initialType)) {
        this._inputTypeStack.push(initialType);
      }
      if (isCompositeType(initialType)) {
        this._parentTypeStack.push(initialType);
      }
      if (isOutputType(initialType)) {
        this._typeStack.push(initialType);
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "TypeInfo";
  }
  getType() {
    if (this._typeStack.length > 0) {
      return this._typeStack[this._typeStack.length - 1];
    }
  }
  getParentType() {
    if (this._parentTypeStack.length > 0) {
      return this._parentTypeStack[this._parentTypeStack.length - 1];
    }
  }
  getInputType() {
    if (this._inputTypeStack.length > 0) {
      return this._inputTypeStack[this._inputTypeStack.length - 1];
    }
  }
  getParentInputType() {
    if (this._inputTypeStack.length > 1) {
      return this._inputTypeStack[this._inputTypeStack.length - 2];
    }
  }
  getFieldDef() {
    if (this._fieldDefStack.length > 0) {
      return this._fieldDefStack[this._fieldDefStack.length - 1];
    }
  }
  getDefaultValue() {
    if (this._defaultValueStack.length > 0) {
      return this._defaultValueStack[this._defaultValueStack.length - 1];
    }
  }
  getDirective() {
    return this._directive;
  }
  getArgument() {
    return this._argument;
  }
  getEnumValue() {
    return this._enumValue;
  }
  enter(node) {
    const schema2 = this._schema;
    switch (node.kind) {
      case Kind.SELECTION_SET: {
        const namedType = getNamedType(this.getType());
        this._parentTypeStack.push(isCompositeType(namedType) ? namedType : undefined);
        break;
      }
      case Kind.FIELD: {
        const parentType = this.getParentType();
        let fieldDef;
        let fieldType;
        if (parentType) {
          fieldDef = this._getFieldDef(schema2, parentType, node);
          if (fieldDef) {
            fieldType = fieldDef.type;
          }
        }
        this._fieldDefStack.push(fieldDef);
        this._typeStack.push(isOutputType(fieldType) ? fieldType : undefined);
        break;
      }
      case Kind.DIRECTIVE:
        this._directive = schema2.getDirective(node.name.value);
        break;
      case Kind.OPERATION_DEFINITION: {
        const rootType = schema2.getRootType(node.operation);
        this._typeStack.push(isObjectType(rootType) ? rootType : undefined);
        break;
      }
      case Kind.INLINE_FRAGMENT:
      case Kind.FRAGMENT_DEFINITION: {
        const typeConditionAST = node.typeCondition;
        const outputType = typeConditionAST ? typeFromAST(schema2, typeConditionAST) : getNamedType(this.getType());
        this._typeStack.push(isOutputType(outputType) ? outputType : undefined);
        break;
      }
      case Kind.VARIABLE_DEFINITION: {
        const inputType = typeFromAST(schema2, node.type);
        this._inputTypeStack.push(isInputType(inputType) ? inputType : undefined);
        break;
      }
      case Kind.ARGUMENT: {
        var _this$getDirective;
        let argDef;
        let argType;
        const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== undefined ? _this$getDirective : this.getFieldDef();
        if (fieldOrDirective) {
          argDef = fieldOrDirective.args.find((arg) => arg.name === node.name.value);
          if (argDef) {
            argType = argDef.type;
          }
        }
        this._argument = argDef;
        this._defaultValueStack.push(argDef ? argDef.defaultValue : undefined);
        this._inputTypeStack.push(isInputType(argType) ? argType : undefined);
        break;
      }
      case Kind.LIST: {
        const listType = getNullableType(this.getInputType());
        const itemType = isListType(listType) ? listType.ofType : listType;
        this._defaultValueStack.push(undefined);
        this._inputTypeStack.push(isInputType(itemType) ? itemType : undefined);
        break;
      }
      case Kind.OBJECT_FIELD: {
        const objectType = getNamedType(this.getInputType());
        let inputFieldType;
        let inputField;
        if (isInputObjectType(objectType)) {
          inputField = objectType.getFields()[node.name.value];
          if (inputField) {
            inputFieldType = inputField.type;
          }
        }
        this._defaultValueStack.push(inputField ? inputField.defaultValue : undefined);
        this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : undefined);
        break;
      }
      case Kind.ENUM: {
        const enumType = getNamedType(this.getInputType());
        let enumValue;
        if (isEnumType(enumType)) {
          enumValue = enumType.getValue(node.value);
        }
        this._enumValue = enumValue;
        break;
      }
      default:
    }
  }
  leave(node) {
    switch (node.kind) {
      case Kind.SELECTION_SET:
        this._parentTypeStack.pop();
        break;
      case Kind.FIELD:
        this._fieldDefStack.pop();
        this._typeStack.pop();
        break;
      case Kind.DIRECTIVE:
        this._directive = null;
        break;
      case Kind.OPERATION_DEFINITION:
      case Kind.INLINE_FRAGMENT:
      case Kind.FRAGMENT_DEFINITION:
        this._typeStack.pop();
        break;
      case Kind.VARIABLE_DEFINITION:
        this._inputTypeStack.pop();
        break;
      case Kind.ARGUMENT:
        this._argument = null;
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind.LIST:
      case Kind.OBJECT_FIELD:
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind.ENUM:
        this._enumValue = null;
        break;
      default:
    }
  }
}

// ../../node_modules/graphql/language/predicates.mjs
function isDefinitionNode(node) {
  return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
}
function isExecutableDefinitionNode(node) {
  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}

// ../../node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
function ExecutableDefinitionsRule(context) {
  return {
    Document(node) {
      for (const definition10 of node.definitions) {
        if (!isExecutableDefinitionNode(definition10)) {
          const defName = definition10.kind === Kind.SCHEMA_DEFINITION || definition10.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition10.name.value + '"';
          context.reportError(new GraphQLError(`The ${defName} definition is not executable.`, {
            nodes: definition10
          }));
        }
      }
      return false;
    }
  };
}

// ../../node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node) {
      const type = context.getParentType();
      if (type) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema2 = context.getSchema();
          const fieldName = node.name.value;
          let suggestion = didYouMean("to use an inline fragment on", getSuggestedTypeNames(schema2, type, fieldName));
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));
          }
          context.reportError(new GraphQLError(`Cannot query field "${fieldName}" on type "${type.name}".` + suggestion, {
            nodes: node
          }));
        }
      }
    }
  };
}
var getSuggestedTypeNames = function(schema2, type, fieldName) {
  if (!isAbstractType(type)) {
    return [];
  }
  const suggestedTypes = new Set;
  const usageCount = Object.create(null);
  for (const possibleType of schema2.getPossibleTypes(type)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== undefined ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema2.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema2.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x) => x.name);
};
var getSuggestedFieldNames = function(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type)) {
    const possibleFieldNames = Object.keys(type.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
};

// ../../node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node) {
      const typeCondition = node.typeCondition;
      if (typeCondition) {
        const type = typeFromAST(context.getSchema(), typeCondition);
        if (type && !isCompositeType(type)) {
          const typeStr = print(typeCondition);
          context.reportError(new GraphQLError(`Fragment cannot condition on non composite type "${typeStr}".`, {
            nodes: typeCondition
          }));
        }
      }
    },
    FragmentDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.typeCondition);
      if (type && !isCompositeType(type)) {
        const typeStr = print(node.typeCondition);
        context.reportError(new GraphQLError(`Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`, {
          nodes: node.typeCondition
        }));
      }
    }
  };
}

// ../../node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
function KnownArgumentNamesRule(context) {
  return {
    ...KnownArgumentNamesOnDirectivesRule(context),
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(new GraphQLError(`Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions), {
          nodes: argNode
        }));
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = schema2 ? schema2.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== undefined ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(new GraphQLError(`Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions), {
              nodes: argNode
            }));
          }
        }
      }
      return false;
    }
  };
}

// ../../node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
function KnownDirectivesRule(context) {
  const locationsMap = Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = schema2 ? schema2.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name) => name.value);
    }
  }
  return {
    Directive(node, _key, _parent, _path, ancestors) {
      const name = node.name.value;
      const locations = locationsMap[name];
      if (!locations) {
        context.reportError(new GraphQLError(`Unknown directive "@${name}".`, {
          nodes: node
        }));
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(new GraphQLError(`Directive "@${name}" may not be used on ${candidateLocation}.`, {
          nodes: node
        }));
      }
    }
  };
}
var getDirectiveLocationForASTPath = function(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  "kind" in appliedTo || invariant(false);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      "kind" in parentNode || invariant(false);
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    default:
      invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
  }
};
var getDirectiveLocationForOperation = function(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
};

// ../../node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node) {
      const fragmentName = node.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(new GraphQLError(`Unknown fragment "${fragmentName}".`, {
          nodes: node.name
        }));
      }
    }
  };
}

// ../../node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
function KnownTypeNamesRule(context) {
  const schema2 = context.getSchema();
  const existingTypesMap = schema2 ? schema2.getTypeMap() : Object.create(null);
  const definedTypes = Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node, _12, parent, _2, ancestors) {
      const typeName = node.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== undefined ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);
        context.reportError(new GraphQLError(`Unknown type "${typeName}".` + didYouMean(suggestedTypes), {
          nodes: node
        }));
      }
    }
  };
}
var isSDLNode = function(value) {
  return "kind" in value && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));
};
var standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map((type) => type.name);

// ../../node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node) {
      operationCount = node.definitions.filter((definition12) => definition12.kind === Kind.OPERATION_DEFINITION).length;
    },
    OperationDefinition(node) {
      if (!node.name && operationCount > 1) {
        context.reportError(new GraphQLError("This anonymous operation must be the only defined operation.", {
          nodes: node
        }));
      }
    }
  };
}

// ../../node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === undefined ? undefined : oldSchema.astNode) !== null && _oldSchema$astNode !== undefined ? _oldSchema$astNode : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getQueryType()) !== null && _ref2 !== undefined ? _ref2 : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getMutationType()) !== null && _ref !== undefined ? _ref : oldSchema === null || oldSchema === undefined ? undefined : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node) {
      if (alreadyDefined) {
        context.reportError(new GraphQLError("Cannot define a new schema within a schema extension.", {
          nodes: node
        }));
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(new GraphQLError("Must provide only one schema definition.", {
          nodes: node
        }));
      }
      ++schemaDefinitionsCount;
    }
  };
}

// ../../node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.mjs
function MaxIntrospectionDepthRule(context) {
  function checkDepth(node, visitedFragments = Object.create(null), depth = 0) {
    if (node.kind === Kind.FRAGMENT_SPREAD) {
      const fragmentName = node.name.value;
      if (visitedFragments[fragmentName] === true) {
        return false;
      }
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        return false;
      }
      try {
        visitedFragments[fragmentName] = true;
        return checkDepth(fragment, visitedFragments, depth);
      } finally {
        visitedFragments[fragmentName] = undefined;
      }
    }
    if (node.kind === Kind.FIELD && (node.name.value === "fields" || node.name.value === "interfaces" || node.name.value === "possibleTypes" || node.name.value === "inputFields")) {
      depth++;
      if (depth >= MAX_LISTS_DEPTH) {
        return true;
      }
    }
    if ("selectionSet" in node && node.selectionSet) {
      for (const child of node.selectionSet.selections) {
        if (checkDepth(child, visitedFragments, depth)) {
          return true;
        }
      }
    }
    return false;
  }
  return {
    Field(node) {
      if (node.name.value === "__schema" || node.name.value === "__type") {
        if (checkDepth(node)) {
          context.reportError(new GraphQLError("Maximum introspection depth exceeded", {
            nodes: [node]
          }));
          return false;
        }
      }
    }
  };
}
var MAX_LISTS_DEPTH = 3;

// ../../node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
function NoFragmentCyclesRule(context) {
  const visitedFrags = Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      detectCycleRecursive(node);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === undefined) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
        context.reportError(new GraphQLError(`Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."), {
          nodes: cyclePath
        }));
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = undefined;
  }
}

// ../../node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          const varName = node.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(new GraphQLError(operation.name ? `Variable "\$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "\$${varName}" is not defined.`, {
              nodes: [node, operation]
            }));
          }
        }
      }
    },
    VariableDefinition(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}

// ../../node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(operation)) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(new GraphQLError(`Fragment "${fragName}" is never used.`, {
              nodes: fragmentDef
            }));
          }
        }
      }
    }
  };
}

// ../../node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          variableNameUsed[node.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(new GraphQLError(operation.name ? `Variable "\$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "\$${variableName}" is never used.`, {
              nodes: variableDef
            }));
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}

// ../../node_modules/graphql/utilities/sortValueNode.mjs
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode;
  }
}
var sortFields = function(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort((fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value));
};

// ../../node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
var reasonMessage = function(reason) {
  if (Array.isArray(reason)) {
    return reason.map(([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)).join(" and ");
  }
  return reason;
};
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFragmentPairs = new PairSet;
  const cachedFieldsAndFragmentNames = new Map;
  return {
    SelectionSet(selectionSet) {
      const conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(new GraphQLError(`Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`, {
          nodes: fields1.concat(fields2)
        }));
      }
    }
  };
}
var findConflictsWithinSelectionSet = function(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet);
  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);
  if (fragmentNames.length !== 0) {
    for (let i = 0;i < fragmentNames.length; i++) {
      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]);
      for (let j = i + 1;j < fragmentNames.length; j++) {
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);
      }
    }
  }
  return conflicts;
};
var collectConflictsBetweenFieldsAndFragment = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment);
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2);
  for (const referencedFragmentName of referencedFragmentNames) {
    if (comparedFragmentPairs.has(referencedFragmentName, fragmentName, areMutuallyExclusive)) {
      continue;
    }
    comparedFragmentPairs.add(referencedFragmentName, fragmentName, areMutuallyExclusive);
    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, referencedFragmentName);
  }
};
var collectConflictsBetweenFragments = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1);
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2);
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, referencedFragmentName2);
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, referencedFragmentName1, fragmentName2);
  }
};
var findConflictsBetweenSubSelectionSets = function(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1);
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2);
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentName2);
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentName1);
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2);
    }
  }
  return conflicts;
};
var collectConflictsWithin = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i = 0;i < fields.length; i++) {
        for (let j = i + 1;j < fields.length; j++) {
          const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, responseName, fields[i], fields[j]);
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
};
var collectConflictsBetween = function(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2);
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
};
var findConflict = function(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node2, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node2.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node2]
      ];
    }
    if (!sameArguments(node1, node2)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node2]
      ];
    }
  }
  const type1 = def1 === null || def1 === undefined ? undefined : def1.type;
  const type2 = def2 === null || def2 === undefined ? undefined : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect(type1)}" and "${inspect(type2)}"`
      ],
      [node1],
      [node2]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
};
var sameArguments = function(node1, node2) {
  const args1 = node1.arguments;
  const args2 = node2.arguments;
  if (args1 === undefined || args1.length === 0) {
    return args2 === undefined || args2.length === 0;
  }
  if (args2 === undefined || args2.length === 0) {
    return false;
  }
  if (args1.length !== args2.length) {
    return false;
  }
  const values2 = new Map(args2.map(({ name, value }) => [name.value, value]));
  return args1.every((arg1) => {
    const value1 = arg1.value;
    const value2 = values2.get(arg1.name.value);
    if (value2 === undefined) {
      return false;
    }
    return stringifyValue(value1) === stringifyValue(value2);
  });
};
var stringifyValue = function(value) {
  return print(sortValueNode(value));
};
var doTypesConflict = function(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
};
var getFieldsAndFragmentNames = function(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = Object.create(null);
  const fragmentNames = Object.create(null);
  _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);
  const result = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet, result);
  return result;
};
var getReferencedFieldsAndFragmentNames = function(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
};
var _collectFieldsAndFragmentNames = function(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        const typeCondition = selection.typeCondition;
        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);
        break;
      }
    }
  }
};
var subfieldConflicts = function(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
};

class PairSet {
  constructor() {
    this._data = new Map;
  }
  has(a, b, areMutuallyExclusive) {
    var _this$_data$get;
    const [key1, key2] = a < b ? [a, b] : [b, a];
    const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === undefined ? undefined : _this$_data$get.get(key2);
    if (result === undefined) {
      return false;
    }
    return areMutuallyExclusive ? true : areMutuallyExclusive === result;
  }
  add(a, b, areMutuallyExclusive) {
    const [key1, key2] = a < b ? [a, b] : [b, a];
    const map = this._data.get(key1);
    if (map === undefined) {
      this._data.set(key1, new Map([[key2, areMutuallyExclusive]]));
    } else {
      map.set(key2, areMutuallyExclusive);
    }
  }
}

// ../../node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(new GraphQLError(`Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
          nodes: node
        }));
      }
    },
    FragmentSpread(node) {
      const fragName = node.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(new GraphQLError(`Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, {
          nodes: node
        }));
      }
    }
  };
}
var getFragmentType = function(context, name) {
  const frag = context.getFragment(name);
  if (frag) {
    const type = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type)) {
      return type;
    }
  }
};

// ../../node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
function PossibleTypeExtensionsRule(context) {
  const schema2 = context.getSchema();
  const definedTypes = Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node) {
    const typeName = node.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema2 === null || schema2 === undefined ? undefined : schema2.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node.kind) {
        const kindStr = extensionKindToTypeName(node.kind);
        context.reportError(new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
          nodes: defNode ? [defNode, node] : node
        }));
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema2 === null || schema2 === undefined ? undefined : schema2.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(new GraphQLError(`Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes), {
        nodes: node.name
      }));
    }
  }
}
var typeToExtKind = function(type) {
  if (isScalarType(type)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(false, "Unexpected type: " + inspect(type));
};
var extensionKindToTypeName = function(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      invariant(false, "Unexpected kind: " + inspect(kind));
  }
};
var defKindToExtKind = {
  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
};

// ../../node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
function ProvidedRequiredArgumentsRule(context) {
  return {
    ...ProvidedRequiredArgumentsOnDirectivesRule(context),
    Field: {
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set((_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === undefined ? undefined : _fieldNode$arguments.map((arg) => arg.name.value));
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect(argDef.type);
            context.reportError(new GraphQLError(`Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`, {
              nodes: fieldNode
            }));
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema2 === null || schema2 === undefined ? undefined : schema2.getDirectives()) !== null && _schema$getDirectives !== undefined ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(directive.args.filter(isRequiredArgument), (arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== undefined ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(argNodes.filter(isRequiredArgumentNode), (arg) => arg.name.value);
    }
  }
  return {
    Directive: {
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== undefined ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type);
              context.reportError(new GraphQLError(`Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`, {
                nodes: directiveNode
              }));
            }
          }
        }
      }
    }
  };
}
var isRequiredArgumentNode = function(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
};

// ../../node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
function ScalarLeafsRule(context) {
  return {
    Field(node) {
      const type = context.getType();
      const selectionSet = node.selectionSet;
      if (type) {
        if (isLeafType(getNamedType(type))) {
          if (selectionSet) {
            const fieldName = node.name.value;
            const typeStr = inspect(type);
            context.reportError(new GraphQLError(`Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`, {
              nodes: selectionSet
            }));
          }
        } else if (!selectionSet) {
          const fieldName = node.name.value;
          const typeStr = inspect(type);
          context.reportError(new GraphQLError(`Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`, {
            nodes: node
          }));
        }
      }
    }
  };
}

// ../../node_modules/graphql/jsutils/printPathArray.mjs
function printPathArray(path) {
  return path.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
}

// ../../node_modules/graphql/jsutils/Path.mjs
function addPath(prev, key, typename) {
  return {
    prev,
    key,
    typename
  };
}
function pathToArray(path) {
  const flattened = [];
  let curr = path;
  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }
  return flattened.reverse();
}

// ../../node_modules/graphql/utilities/coerceInputValue.mjs
function coerceInputValue(inputValue, type, onError = defaultOnError) {
  return coerceInputValueImpl(inputValue, type, onError, undefined);
}
var defaultOnError = function(path, invalidValue, error) {
  let errorPrefix = "Invalid value " + inspect(invalidValue);
  if (path.length > 0) {
    errorPrefix += ` at "value${printPathArray(path)}"`;
  }
  error.message = errorPrefix + ": " + error.message;
  throw error;
};
var coerceInputValueImpl = function(inputValue, type, onError, path) {
  if (isNonNullType(type)) {
    if (inputValue != null) {
      return coerceInputValueImpl(inputValue, type.ofType, onError, path);
    }
    onError(pathToArray(path), inputValue, new GraphQLError(`Expected non-nullable type "${inspect(type)}" not to be null.`));
    return;
  }
  if (inputValue == null) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(inputValue)) {
      return Array.from(inputValue, (itemValue, index) => {
        const itemPath = addPath(path, index, undefined);
        return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
      });
    }
    return [coerceInputValueImpl(inputValue, itemType, onError, path)];
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(inputValue)) {
      onError(pathToArray(path), inputValue, new GraphQLError(`Expected type "${type.name}" to be an object.`));
      return;
    }
    const coercedValue = {};
    const fieldDefs = type.getFields();
    for (const field of Object.values(fieldDefs)) {
      const fieldValue = inputValue[field.name];
      if (fieldValue === undefined) {
        if (field.defaultValue !== undefined) {
          coercedValue[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          const typeStr = inspect(field.type);
          onError(pathToArray(path), inputValue, new GraphQLError(`Field "${field.name}" of required type "${typeStr}" was not provided.`));
        }
        continue;
      }
      coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, addPath(path, field.name, type.name));
    }
    for (const fieldName of Object.keys(inputValue)) {
      if (!fieldDefs[fieldName]) {
        const suggestions = suggestionList(fieldName, Object.keys(type.getFields()));
        onError(pathToArray(path), inputValue, new GraphQLError(`Field "${fieldName}" is not defined by type "${type.name}".` + didYouMean(suggestions)));
      }
    }
    if (type.isOneOf) {
      const keys = Object.keys(coercedValue);
      if (keys.length !== 1) {
        onError(pathToArray(path), inputValue, new GraphQLError(`Exactly one key must be specified for OneOf type "${type.name}".`));
      }
      const key = keys[0];
      const value = coercedValue[key];
      if (value === null) {
        onError(pathToArray(path).concat(key), value, new GraphQLError(`Field "${key}" must be non-null.`));
      }
    }
    return coercedValue;
  }
  if (isLeafType(type)) {
    let parseResult;
    try {
      parseResult = type.parseValue(inputValue);
    } catch (error) {
      if (error instanceof GraphQLError) {
        onError(pathToArray(path), inputValue, error);
      } else {
        onError(pathToArray(path), inputValue, new GraphQLError(`Expected type "${type.name}". ` + error.message, {
          originalError: error
        }));
      }
      return;
    }
    if (parseResult === undefined) {
      onError(pathToArray(path), inputValue, new GraphQLError(`Expected type "${type.name}".`));
    }
    return parseResult;
  }
  invariant(false, "Unexpected input type: " + inspect(type));
};

// ../../node_modules/graphql/utilities/valueFromAST.mjs
function valueFromAST(valueNode, type, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === undefined) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (valueNode.kind === Kind.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === undefined) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === undefined) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    const coercedObj = Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
    for (const field of Object.values(type.getFields())) {
      const fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== undefined) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === undefined) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    if (type.isOneOf) {
      const keys = Object.keys(coercedObj);
      if (keys.length !== 1) {
        return;
      }
      if (coercedObj[keys[0]] === null) {
        return;
      }
    }
    return coercedObj;
  }
  if (isLeafType(type)) {
    let result;
    try {
      result = type.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === undefined) {
      return;
    }
    return result;
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
var isMissingVariable = function(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === undefined);
};

// ../../node_modules/graphql/execution/values.mjs
function getArgumentValues(def, node, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== undefined ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (argDef.defaultValue !== undefined) {
        coercedValues[name] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(`Argument "${name}" of required type "${inspect(argType)}" ` + "was not provided.", {
          nodes: node
        });
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== undefined) {
          coercedValues[name] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(`Argument "${name}" of required type "${inspect(argType)}" ` + `was provided the variable "\$${variableName}" which was not provided a runtime value.`, {
            nodes: valueNode
          });
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw new GraphQLError(`Argument "${name}" of non-null type "${inspect(argType)}" ` + "must not be null.", {
        nodes: valueNode
      });
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === undefined) {
      throw new GraphQLError(`Argument "${name}" has invalid value ${print(valueNode)}.`, {
        nodes: valueNode
      });
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node.directives) === null || _node$directives === undefined ? undefined : _node$directives.find((directive) => directive.name.value === directiveDef.name);
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
var hasOwnProperty = function(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};

// ../../node_modules/graphql/execution/collectFields.mjs
function collectFields(schema2, fragments, variableValues, runtimeType, selectionSet) {
  const fields = new Map;
  collectFieldsImpl(schema2, fragments, variableValues, runtimeType, selectionSet, fields, new Set);
  return fields;
}
function collectSubfields(schema2, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = new Map;
  const visitedFragmentNames = new Set;
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl(schema2, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);
    }
  }
  return subFieldNodes;
}
var collectFieldsImpl = function(schema2, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name = getFieldEntryKey(selection);
        const fieldList = fields.get(name);
        if (fieldList !== undefined) {
          fieldList.push(selection);
        } else {
          fields.set(name, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema2, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(schema2, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema2, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(schema2, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
        break;
      }
    }
  }
};
var shouldIncludeNode = function(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if ((skip === null || skip === undefined ? undefined : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);
  if ((include === null || include === undefined ? undefined : include.if) === false) {
    return false;
  }
  return true;
};
var doesFragmentConditionMatch = function(schema2, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema2, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema2.isSubType(conditionalType, type);
  }
  return false;
};
var getFieldEntryKey = function(node) {
  return node.alias ? node.alias.value : node.name.value;
};

// ../../node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node) {
      if (node.operation === "subscription") {
        const schema2 = context.getSchema();
        const subscriptionType = schema2.getSubscriptionType();
        if (subscriptionType) {
          const operationName = node.name ? node.name.value : null;
          const variableValues = Object.create(null);
          const document = context.getDocument();
          const fragments = Object.create(null);
          for (const definition21 of document.definitions) {
            if (definition21.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[definition21.name.value] = definition21;
            }
          }
          const fields = collectFields(schema2, fragments, variableValues, subscriptionType, node.selectionSet);
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(new GraphQLError(operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.", {
              nodes: extraFieldSelections
            }));
          }
          for (const fieldNodes of fields.values()) {
            const field = fieldNodes[0];
            const fieldName = field.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(new GraphQLError(operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.", {
                nodes: fieldNodes
              }));
            }
          }
        }
      }
    }
  };
}

// ../../node_modules/graphql/jsutils/groupBy.mjs
function groupBy(list, keyFn) {
  const result = new Map;
  for (const item of list) {
    const key = keyFn(item);
    const group = result.get(key);
    if (group === undefined) {
      result.set(key, [item]);
    } else {
      group.push(item);
    }
  }
  return result;
}

// ../../node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== undefined ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== undefined ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== undefined ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(new GraphQLError(`Argument "${parentName}(${argName}:)" can only be defined once.`, {
          nodes: argNodes.map((node) => node.name)
        }));
      }
    }
    return false;
  }
}

// ../../node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== undefined ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(new GraphQLError(`There can be only one argument named "${argName}".`, {
          nodes: argNodes.map((node) => node.name)
        }));
      }
    }
  }
}

// ../../node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = Object.create(null);
  const schema2 = context.getSchema();
  return {
    DirectiveDefinition(node) {
      const directiveName = node.name.value;
      if (schema2 !== null && schema2 !== undefined && schema2.getDirective(directiveName)) {
        context.reportError(new GraphQLError(`Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`, {
          nodes: node.name
        }));
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(new GraphQLError(`There can be only one directive named "@${directiveName}".`, {
          nodes: [knownDirectiveNames[directiveName], node.name]
        }));
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }
      return false;
    }
  };
}

// ../../node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = Object.create(null);
  const schema2 = context.getSchema();
  const definedDirectives = schema2 ? schema2.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = Object.create(null);
  const typeDirectivesMap = Object.create(null);
  return {
    enter(node) {
      if (!("directives" in node) || !node.directives) {
        return;
      }
      let seenDirectives;
      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
        const typeName = node.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === undefined) {
          typeDirectivesMap[typeName] = seenDirectives = Object.create(null);
        }
      } else {
        seenDirectives = Object.create(null);
      }
      for (const directive of node.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(new GraphQLError(`The directive "@${directiveName}" can only be used once at this location.`, {
              nodes: [seenDirectives[directiveName], directive]
            }));
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}

// ../../node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
function UniqueEnumValueNamesRule(context) {
  const schema2 = context.getSchema();
  const existingTypeMap = schema2 ? schema2.getTypeMap() : Object.create(null);
  const knownValueNames = Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node) {
    var _node$values;
    const typeName = node.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = Object.create(null);
    }
    const valueNodes = (_node$values = node.values) !== null && _node$values !== undefined ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(new GraphQLError(`Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`, {
          nodes: valueDef.name
        }));
      } else if (valueNames[valueName]) {
        context.reportError(new GraphQLError(`Enum value "${typeName}.${valueName}" can only be defined once.`, {
          nodes: [valueNames[valueName], valueDef.name]
        }));
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}

// ../../node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
function UniqueFieldDefinitionNamesRule(context) {
  const schema2 = context.getSchema();
  const existingTypeMap = schema2 ? schema2.getTypeMap() : Object.create(null);
  const knownFieldNames = Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node) {
    var _node$fields;
    const typeName = node.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = Object.create(null);
    }
    const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== undefined ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(new GraphQLError(`Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`, {
          nodes: fieldDef.name
        }));
      } else if (fieldNames[fieldName]) {
        context.reportError(new GraphQLError(`Field "${typeName}.${fieldName}" can only be defined once.`, {
          nodes: [fieldNames[fieldName], fieldDef.name]
        }));
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
var hasField = function(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {
    return type.getFields()[fieldName] != null;
  }
  return false;
};

// ../../node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      const fragmentName = node.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(new GraphQLError(`There can be only one fragment named "${fragmentName}".`, {
          nodes: [knownFragmentNames[fragmentName], node.name]
        }));
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }
      return false;
    }
  };
}

// ../../node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node) {
      const fieldName = node.name.value;
      if (knownNames[fieldName]) {
        context.reportError(new GraphQLError(`There can be only one input field named "${fieldName}".`, {
          nodes: [knownNames[fieldName], node.name]
        }));
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}

// ../../node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
function UniqueOperationNamesRule(context) {
  const knownOperationNames = Object.create(null);
  return {
    OperationDefinition(node) {
      const operationName = node.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(new GraphQLError(`There can be only one operation named "${operationName.value}".`, {
            nodes: [
              knownOperationNames[operationName.value],
              operationName
            ]
          }));
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}

// ../../node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
function UniqueOperationTypesRule(context) {
  const schema2 = context.getSchema();
  const definedOperationTypes = Object.create(null);
  const existingOperationTypes = schema2 ? {
    query: schema2.getQueryType(),
    mutation: schema2.getMutationType(),
    subscription: schema2.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== undefined ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(new GraphQLError(`Type for ${operation} already defined in the schema. It cannot be redefined.`, {
          nodes: operationType
        }));
      } else if (alreadyDefinedOperationType) {
        context.reportError(new GraphQLError(`There can be only one ${operation} type in schema.`, {
          nodes: [alreadyDefinedOperationType, operationType]
        }));
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}

// ../../node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
function UniqueTypeNamesRule(context) {
  const knownTypeNames = Object.create(null);
  const schema2 = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node) {
    const typeName = node.name.value;
    if (schema2 !== null && schema2 !== undefined && schema2.getType(typeName)) {
      context.reportError(new GraphQLError(`Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`, {
        nodes: node.name
      }));
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(new GraphQLError(`There can be only one type named "${typeName}".`, {
        nodes: [knownTypeNames[typeName], node.name]
      }));
    } else {
      knownTypeNames[typeName] = node.name;
    }
    return false;
  }
}

// ../../node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== undefined ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(variableDefinitions, (node) => node.variable.name.value);
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(new GraphQLError(`There can be only one variable named "\$${variableName}".`, {
            nodes: variableNodes.map((node) => node.variable.name)
          }));
        }
      }
    }
  };
}

// ../../node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
function ValuesOfCorrectTypeRule(context) {
  let variableDefinitions = {};
  return {
    OperationDefinition: {
      enter() {
        variableDefinitions = {};
      }
    },
    VariableDefinition(definition24) {
      variableDefinitions[definition24.variable.name.value] = definition24;
    },
    ListValue(node) {
      const type = getNullableType(context.getParentInputType());
      if (!isListType(type)) {
        isValidValueNode(context, node);
        return false;
      }
    },
    ObjectValue(node) {
      const type = getNamedType(context.getInputType());
      if (!isInputObjectType(type)) {
        isValidValueNode(context, node);
        return false;
      }
      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);
      for (const fieldDef of Object.values(type.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect(fieldDef.type);
          context.reportError(new GraphQLError(`Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`, {
            nodes: node
          }));
        }
      }
      if (type.isOneOf) {
        validateOneOfInputObject(context, node, type, fieldNodeMap, variableDefinitions);
      }
    },
    ObjectField(node) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(node.name.value, Object.keys(parentType.getFields()));
        context.reportError(new GraphQLError(`Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions), {
          nodes: node
        }));
      }
    },
    NullValue(node) {
      const type = context.getInputType();
      if (isNonNullType(type)) {
        context.reportError(new GraphQLError(`Expected value of type "${inspect(type)}", found ${print(node)}.`, {
          nodes: node
        }));
      }
    },
    EnumValue: (node) => isValidValueNode(context, node),
    IntValue: (node) => isValidValueNode(context, node),
    FloatValue: (node) => isValidValueNode(context, node),
    StringValue: (node) => isValidValueNode(context, node),
    BooleanValue: (node) => isValidValueNode(context, node)
  };
}
var isValidValueNode = function(context, node) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type = getNamedType(locationType);
  if (!isLeafType(type)) {
    const typeStr = inspect(locationType);
    context.reportError(new GraphQLError(`Expected value of type "${typeStr}", found ${print(node)}.`, {
      nodes: node
    }));
    return;
  }
  try {
    const parseResult = type.parseLiteral(node, undefined);
    if (parseResult === undefined) {
      const typeStr = inspect(locationType);
      context.reportError(new GraphQLError(`Expected value of type "${typeStr}", found ${print(node)}.`, {
        nodes: node
      }));
    }
  } catch (error) {
    const typeStr = inspect(locationType);
    if (error instanceof GraphQLError) {
      context.reportError(error);
    } else {
      context.reportError(new GraphQLError(`Expected value of type "${typeStr}", found ${print(node)}; ` + error.message, {
        nodes: node,
        originalError: error
      }));
    }
  }
};
var validateOneOfInputObject = function(context, node, type, fieldNodeMap, variableDefinitions) {
  var _fieldNodeMap$keys$;
  const keys = Object.keys(fieldNodeMap);
  const isNotExactlyOneField = keys.length !== 1;
  if (isNotExactlyOneField) {
    context.reportError(new GraphQLError(`OneOf Input Object "${type.name}" must specify exactly one key.`, {
      nodes: [node]
    }));
    return;
  }
  const value = (_fieldNodeMap$keys$ = fieldNodeMap[keys[0]]) === null || _fieldNodeMap$keys$ === undefined ? undefined : _fieldNodeMap$keys$.value;
  const isNullLiteral = !value || value.kind === Kind.NULL;
  const isVariable = (value === null || value === undefined ? undefined : value.kind) === Kind.VARIABLE;
  if (isNullLiteral) {
    context.reportError(new GraphQLError(`Field "${type.name}.${keys[0]}" must be non-null.`, {
      nodes: [node]
    }));
    return;
  }
  if (isVariable) {
    const variableName = value.name.value;
    const definition24 = variableDefinitions[variableName];
    const isNullableVariable = definition24.type.kind !== Kind.NON_NULL_TYPE;
    if (isNullableVariable) {
      context.reportError(new GraphQLError(`Variable "${variableName}" must be non-nullable to be used for OneOf Input Object "${type.name}".`, {
        nodes: [node]
      }));
    }
  }
};

// ../../node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.type);
      if (type !== undefined && !isInputType(type)) {
        const variableName = node.variable.name.value;
        const typeName = print(node.type);
        context.reportError(new GraphQLError(`Variable "\$${variableName}" cannot be non-input type "${typeName}".`, {
          nodes: node.type
        }));
      }
    }
  };
}

// ../../node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
function VariablesInAllowedPositionRule(context) {
  let varDefMap = Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node, type, defaultValue } of usages) {
          const varName = node.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type) {
            const schema2 = context.getSchema();
            const varType = typeFromAST(schema2, varDef.type);
            if (varType && !allowedVariableUsage(schema2, varType, varDef.defaultValue, type, defaultValue)) {
              const varTypeStr = inspect(varType);
              const typeStr = inspect(type);
              context.reportError(new GraphQLError(`Variable "\$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`, {
                nodes: [varDef, node]
              }));
            }
          }
        }
      }
    },
    VariableDefinition(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
var allowedVariableUsage = function(schema2, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== undefined;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema2, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema2, varType, locationType);
};

// ../../node_modules/graphql/validation/specifiedRules.mjs
var recommendedRules = Object.freeze([MaxIntrospectionDepthRule]);
var specifiedRules = Object.freeze([
  ExecutableDefinitionsRule,
  UniqueOperationNamesRule,
  LoneAnonymousOperationRule,
  SingleFieldSubscriptionsRule,
  KnownTypeNamesRule,
  FragmentsOnCompositeTypesRule,
  VariablesAreInputTypesRule,
  ScalarLeafsRule,
  FieldsOnCorrectTypeRule,
  UniqueFragmentNamesRule,
  KnownFragmentNamesRule,
  NoUnusedFragmentsRule,
  PossibleFragmentSpreadsRule,
  NoFragmentCyclesRule,
  UniqueVariableNamesRule,
  NoUndefinedVariablesRule,
  NoUnusedVariablesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  KnownArgumentNamesRule,
  UniqueArgumentNamesRule,
  ValuesOfCorrectTypeRule,
  ProvidedRequiredArgumentsRule,
  VariablesInAllowedPositionRule,
  OverlappingFieldsCanBeMergedRule,
  UniqueInputFieldNamesRule,
  ...recommendedRules
]);
var specifiedSDLRules = Object.freeze([
  LoneSchemaDefinitionRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueArgumentDefinitionNamesRule,
  UniqueDirectiveNamesRule,
  KnownTypeNamesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  PossibleTypeExtensionsRule,
  KnownArgumentNamesOnDirectivesRule,
  UniqueArgumentNamesRule,
  UniqueInputFieldNamesRule,
  ProvidedRequiredArgumentsOnDirectivesRule
]);

// ../../node_modules/graphql/validation/ValidationContext.mjs
class ASTValidationContext {
  constructor(ast8, onError) {
    this._ast = ast8;
    this._fragments = undefined;
    this._fragmentSpreads = new Map;
    this._recursivelyReferencedFragments = new Map;
    this._onError = onError;
  }
  get [Symbol.toStringTag]() {
    return "ASTValidationContext";
  }
  reportError(error) {
    this._onError(error);
  }
  getDocument() {
    return this._ast;
  }
  getFragment(name) {
    let fragments;
    if (this._fragments) {
      fragments = this._fragments;
    } else {
      fragments = Object.create(null);
      for (const defNode of this.getDocument().definitions) {
        if (defNode.kind === Kind.FRAGMENT_DEFINITION) {
          fragments[defNode.name.value] = defNode;
        }
      }
      this._fragments = fragments;
    }
    return fragments[name];
  }
  getFragmentSpreads(node) {
    let spreads = this._fragmentSpreads.get(node);
    if (!spreads) {
      spreads = [];
      const setsToVisit = [node];
      let set;
      while (set = setsToVisit.pop()) {
        for (const selection of set.selections) {
          if (selection.kind === Kind.FRAGMENT_SPREAD) {
            spreads.push(selection);
          } else if (selection.selectionSet) {
            setsToVisit.push(selection.selectionSet);
          }
        }
      }
      this._fragmentSpreads.set(node, spreads);
    }
    return spreads;
  }
  getRecursivelyReferencedFragments(operation) {
    let fragments = this._recursivelyReferencedFragments.get(operation);
    if (!fragments) {
      fragments = [];
      const collectedNames = Object.create(null);
      const nodesToVisit = [operation.selectionSet];
      let node;
      while (node = nodesToVisit.pop()) {
        for (const spread of this.getFragmentSpreads(node)) {
          const fragName = spread.name.value;
          if (collectedNames[fragName] !== true) {
            collectedNames[fragName] = true;
            const fragment = this.getFragment(fragName);
            if (fragment) {
              fragments.push(fragment);
              nodesToVisit.push(fragment.selectionSet);
            }
          }
        }
      }
      this._recursivelyReferencedFragments.set(operation, fragments);
    }
    return fragments;
  }
}

class SDLValidationContext extends ASTValidationContext {
  constructor(ast8, schema2, onError) {
    super(ast8, onError);
    this._schema = schema2;
  }
  get [Symbol.toStringTag]() {
    return "SDLValidationContext";
  }
  getSchema() {
    return this._schema;
  }
}

class ValidationContext extends ASTValidationContext {
  constructor(schema2, ast8, typeInfo, onError) {
    super(ast8, onError);
    this._schema = schema2;
    this._typeInfo = typeInfo;
    this._variableUsages = new Map;
    this._recursiveVariableUsages = new Map;
  }
  get [Symbol.toStringTag]() {
    return "ValidationContext";
  }
  getSchema() {
    return this._schema;
  }
  getVariableUsages(node) {
    let usages = this._variableUsages.get(node);
    if (!usages) {
      const newUsages = [];
      const typeInfo = new TypeInfo(this._schema);
      visit(node, visitWithTypeInfo(typeInfo, {
        VariableDefinition: () => false,
        Variable(variable) {
          newUsages.push({
            node: variable,
            type: typeInfo.getInputType(),
            defaultValue: typeInfo.getDefaultValue()
          });
        }
      }));
      usages = newUsages;
      this._variableUsages.set(node, usages);
    }
    return usages;
  }
  getRecursiveVariableUsages(operation) {
    let usages = this._recursiveVariableUsages.get(operation);
    if (!usages) {
      usages = this.getVariableUsages(operation);
      for (const frag of this.getRecursivelyReferencedFragments(operation)) {
        usages = usages.concat(this.getVariableUsages(frag));
      }
      this._recursiveVariableUsages.set(operation, usages);
    }
    return usages;
  }
  getType() {
    return this._typeInfo.getType();
  }
  getParentType() {
    return this._typeInfo.getParentType();
  }
  getInputType() {
    return this._typeInfo.getInputType();
  }
  getParentInputType() {
    return this._typeInfo.getParentInputType();
  }
  getFieldDef() {
    return this._typeInfo.getFieldDef();
  }
  getDirective() {
    return this._typeInfo.getDirective();
  }
  getArgument() {
    return this._typeInfo.getArgument();
  }
  getEnumValue() {
    return this._typeInfo.getEnumValue();
  }
}

// ../../node_modules/graphql/validation/validate.mjs
function validate2(schema2, documentAST, rules = specifiedRules, options, typeInfo = new TypeInfo(schema2)) {
  var _options$maxErrors;
  const maxErrors = (_options$maxErrors = options === null || options === undefined ? undefined : options.maxErrors) !== null && _options$maxErrors !== undefined ? _options$maxErrors : 100;
  documentAST || devAssert(false, "Must provide document.");
  assertValidSchema(schema2);
  const abortObj = Object.freeze({});
  const errors = [];
  const context = new ValidationContext(schema2, documentAST, typeInfo, (error) => {
    if (errors.length >= maxErrors) {
      errors.push(new GraphQLError("Too many validation errors, error limit reached. Validation aborted."));
      throw abortObj;
    }
    errors.push(error);
  });
  const visitor5 = visitInParallel(rules.map((rule) => rule(context)));
  try {
    visit(documentAST, visitWithTypeInfo(typeInfo, visitor5));
  } catch (e) {
    if (e !== abortObj) {
      throw e;
    }
  }
  return errors;
}
function validateSDL(documentAST, schemaToExtend, rules = specifiedSDLRules) {
  const errors = [];
  const context = new SDLValidationContext(documentAST, schemaToExtend, (error) => {
    errors.push(error);
  });
  const visitors = rules.map((rule) => rule(context));
  visit(documentAST, visitInParallel(visitors));
  return errors;
}
function assertValidSDL(documentAST) {
  const errors = validateSDL(documentAST);
  if (errors.length !== 0) {
    throw new Error(errors.map((error) => error.message).join("\n\n"));
  }
}
function assertValidSDLExtension(documentAST, schema2) {
  const errors = validateSDL(documentAST, schema2);
  if (errors.length !== 0) {
    throw new Error(errors.map((error) => error.message).join("\n\n"));
  }
}

// ../../node_modules/graphql/jsutils/memoize3.mjs
function memoize3(fn) {
  let cache0;
  return function memoized(a1, a2, a3) {
    if (cache0 === undefined) {
      cache0 = new WeakMap;
    }
    let cache1 = cache0.get(a1);
    if (cache1 === undefined) {
      cache1 = new WeakMap;
      cache0.set(a1, cache1);
    }
    let cache2 = cache1.get(a2);
    if (cache2 === undefined) {
      cache2 = new WeakMap;
      cache1.set(a2, cache2);
    }
    let fnResult = cache2.get(a3);
    if (fnResult === undefined) {
      fnResult = fn(a1, a2, a3);
      cache2.set(a3, fnResult);
    }
    return fnResult;
  };
}

// ../../node_modules/graphql/jsutils/toError.mjs
function toError(thrownValue) {
  return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
}

class NonErrorThrown extends Error {
  constructor(thrownValue) {
    super("Unexpected error value: " + inspect(thrownValue));
    this.name = "NonErrorThrown";
    this.thrownValue = thrownValue;
  }
}

// ../../node_modules/graphql/error/locatedError.mjs
function locatedError(rawOriginalError, nodes, path) {
  var _nodes;
  const originalError = toError(rawOriginalError);
  if (isLocatedGraphQLError(originalError)) {
    return originalError;
  }
  return new GraphQLError(originalError.message, {
    nodes: (_nodes = originalError.nodes) !== null && _nodes !== undefined ? _nodes : nodes,
    source: originalError.source,
    positions: originalError.positions,
    path,
    originalError
  });
}
var isLocatedGraphQLError = function(error) {
  return Array.isArray(error.path);
};

// ../../node_modules/graphql/execution/execute.mjs
var collectSubfields2 = memoize3((exeContext, returnType, fieldNodes) => collectSubfields(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));
var defaultTypeResolver = function(value, contextValue, info, abstractType) {
  if (isObjectLike(value) && typeof value.__typename === "string") {
    return value.__typename;
  }
  const possibleTypes = info.schema.getPossibleTypes(abstractType);
  const promisedIsTypeOfResults = [];
  for (let i = 0;i < possibleTypes.length; i++) {
    const type = possibleTypes[i];
    if (type.isTypeOf) {
      const isTypeOfResult = type.isTypeOf(value, contextValue, info);
      if (isPromise(isTypeOfResult)) {
        promisedIsTypeOfResults[i] = isTypeOfResult;
      } else if (isTypeOfResult) {
        return type.name;
      }
    }
  }
  if (promisedIsTypeOfResults.length) {
    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
      for (let i = 0;i < isTypeOfResults.length; i++) {
        if (isTypeOfResults[i]) {
          return possibleTypes[i].name;
        }
      }
    });
  }
};
var defaultFieldResolver = function(source2, args, contextValue, info) {
  if (isObjectLike(source2) || typeof source2 === "function") {
    const property = source2[info.fieldName];
    if (typeof property === "function") {
      return source2[info.fieldName](args, contextValue, info);
    }
    return property;
  }
};
// ../../node_modules/graphql/utilities/getOperationAST.mjs
function getOperationAST(documentAST, operationName) {
  let operation = null;
  for (const definition26 of documentAST.definitions) {
    if (definition26.kind === Kind.OPERATION_DEFINITION) {
      var _definition$name;
      if (operationName == null) {
        if (operation) {
          return null;
        }
        operation = definition26;
      } else if (((_definition$name = definition26.name) === null || _definition$name === undefined ? undefined : _definition$name.value) === operationName) {
        return definition26;
      }
    }
  }
  return operation;
}
// ../../node_modules/graphql/utilities/extendSchema.mjs
function extendSchema(schema3, documentAST, options) {
  assertSchema(schema3);
  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(false, "Must provide valid Document AST.");
  if ((options === null || options === undefined ? undefined : options.assumeValid) !== true && (options === null || options === undefined ? undefined : options.assumeValidSDL) !== true) {
    assertValidSDLExtension(documentAST, schema3);
  }
  const schemaConfig = schema3.toConfig();
  const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);
  return schemaConfig === extendedConfig ? schema3 : new GraphQLSchema(extendedConfig);
}
function extendSchemaImpl(schemaConfig, documentAST, options) {
  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
  const typeDefs = [];
  const typeExtensionsMap = Object.create(null);
  const directiveDefs = [];
  let schemaDef;
  const schemaExtensions = [];
  for (const def of documentAST.definitions) {
    if (def.kind === Kind.SCHEMA_DEFINITION) {
      schemaDef = def;
    } else if (def.kind === Kind.SCHEMA_EXTENSION) {
      schemaExtensions.push(def);
    } else if (isTypeDefinitionNode(def)) {
      typeDefs.push(def);
    } else if (isTypeExtensionNode(def)) {
      const extendedTypeName = def.name.value;
      const existingTypeExtensions = typeExtensionsMap[extendedTypeName];
      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      directiveDefs.push(def);
    }
  }
  if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
    return schemaConfig;
  }
  const typeMap = Object.create(null);
  for (const existingType of schemaConfig.types) {
    typeMap[existingType.name] = extendNamedType(existingType);
  }
  for (const typeNode of typeDefs) {
    var _stdTypeMap$name;
    const name = typeNode.name.value;
    typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== undefined ? _stdTypeMap$name : buildType(typeNode);
  }
  const operationTypes = {
    query: schemaConfig.query && replaceNamedType(schemaConfig.query),
    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),
    ...schemaDef && getOperationTypes([schemaDef]),
    ...getOperationTypes(schemaExtensions)
  };
  return {
    description: (_schemaDef = schemaDef) === null || _schemaDef === undefined ? undefined : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === undefined ? undefined : _schemaDef$descriptio.value,
    ...operationTypes,
    types: Object.values(typeMap),
    directives: [
      ...schemaConfig.directives.map(replaceDirective),
      ...directiveDefs.map(buildDirective)
    ],
    extensions: Object.create(null),
    astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== undefined ? _schemaDef2 : schemaConfig.astNode,
    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
    assumeValid: (_options$assumeValid = options === null || options === undefined ? undefined : options.assumeValid) !== null && _options$assumeValid !== undefined ? _options$assumeValid : false
  };
  function replaceType(type) {
    if (isListType(type)) {
      return new GraphQLList(replaceType(type.ofType));
    }
    if (isNonNullType(type)) {
      return new GraphQLNonNull(replaceType(type.ofType));
    }
    return replaceNamedType(type);
  }
  function replaceNamedType(type) {
    return typeMap[type.name];
  }
  function replaceDirective(directive) {
    const config = directive.toConfig();
    return new GraphQLDirective({
      ...config,
      args: mapValue(config.args, extendArg)
    });
  }
  function extendNamedType(type) {
    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {
      return type;
    }
    if (isScalarType(type)) {
      return extendScalarType(type);
    }
    if (isObjectType(type)) {
      return extendObjectType(type);
    }
    if (isInterfaceType(type)) {
      return extendInterfaceType(type);
    }
    if (isUnionType(type)) {
      return extendUnionType(type);
    }
    if (isEnumType(type)) {
      return extendEnumType(type);
    }
    if (isInputObjectType(type)) {
      return extendInputObjectType(type);
    }
    invariant(false, "Unexpected type: " + inspect(type));
  }
  function extendInputObjectType(type) {
    var _typeExtensionsMap$co;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== undefined ? _typeExtensionsMap$co : [];
    return new GraphQLInputObjectType({
      ...config,
      fields: () => ({
        ...mapValue(config.fields, (field) => ({
          ...field,
          type: replaceType(field.type)
        })),
        ...buildInputFieldMap(extensions)
      }),
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendEnumType(type) {
    var _typeExtensionsMap$ty;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== undefined ? _typeExtensionsMap$ty : [];
    return new GraphQLEnumType({
      ...config,
      values: { ...config.values, ...buildEnumValueMap(extensions) },
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendScalarType(type) {
    var _typeExtensionsMap$co2;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== undefined ? _typeExtensionsMap$co2 : [];
    let specifiedByURL = config.specifiedByURL;
    for (const extensionNode of extensions) {
      var _getSpecifiedByURL;
      specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== undefined ? _getSpecifiedByURL : specifiedByURL;
    }
    return new GraphQLScalarType({
      ...config,
      specifiedByURL,
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendObjectType(type) {
    var _typeExtensionsMap$co3;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== undefined ? _typeExtensionsMap$co3 : [];
    return new GraphQLObjectType({
      ...config,
      interfaces: () => [
        ...type.getInterfaces().map(replaceNamedType),
        ...buildInterfaces(extensions)
      ],
      fields: () => ({
        ...mapValue(config.fields, extendField),
        ...buildFieldMap(extensions)
      }),
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendInterfaceType(type) {
    var _typeExtensionsMap$co4;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== undefined ? _typeExtensionsMap$co4 : [];
    return new GraphQLInterfaceType({
      ...config,
      interfaces: () => [
        ...type.getInterfaces().map(replaceNamedType),
        ...buildInterfaces(extensions)
      ],
      fields: () => ({
        ...mapValue(config.fields, extendField),
        ...buildFieldMap(extensions)
      }),
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendUnionType(type) {
    var _typeExtensionsMap$co5;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== undefined ? _typeExtensionsMap$co5 : [];
    return new GraphQLUnionType({
      ...config,
      types: () => [
        ...type.getTypes().map(replaceNamedType),
        ...buildUnionTypes(extensions)
      ],
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendField(field) {
    return {
      ...field,
      type: replaceType(field.type),
      args: field.args && mapValue(field.args, extendArg)
    };
  }
  function extendArg(arg) {
    return { ...arg, type: replaceType(arg.type) };
  }
  function getOperationTypes(nodes) {
    const opTypes = {};
    for (const node of nodes) {
      var _node$operationTypes;
      const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== undefined ? _node$operationTypes : [];
      for (const operationType of operationTypesNodes) {
        opTypes[operationType.operation] = getNamedType2(operationType.type);
      }
    }
    return opTypes;
  }
  function getNamedType2(node) {
    var _stdTypeMap$name2;
    const name = node.name.value;
    const type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== undefined ? _stdTypeMap$name2 : typeMap[name];
    if (type === undefined) {
      throw new Error(`Unknown type: "${name}".`);
    }
    return type;
  }
  function getWrappedType(node) {
    if (node.kind === Kind.LIST_TYPE) {
      return new GraphQLList(getWrappedType(node.type));
    }
    if (node.kind === Kind.NON_NULL_TYPE) {
      return new GraphQLNonNull(getWrappedType(node.type));
    }
    return getNamedType2(node);
  }
  function buildDirective(node) {
    var _node$description;
    return new GraphQLDirective({
      name: node.name.value,
      description: (_node$description = node.description) === null || _node$description === undefined ? undefined : _node$description.value,
      locations: node.locations.map(({ value }) => value),
      isRepeatable: node.repeatable,
      args: buildArgumentMap(node.arguments),
      astNode: node
    });
  }
  function buildFieldMap(nodes) {
    const fieldConfigMap = Object.create(null);
    for (const node of nodes) {
      var _node$fields;
      const nodeFields = (_node$fields = node.fields) !== null && _node$fields !== undefined ? _node$fields : [];
      for (const field of nodeFields) {
        var _field$description;
        fieldConfigMap[field.name.value] = {
          type: getWrappedType(field.type),
          description: (_field$description = field.description) === null || _field$description === undefined ? undefined : _field$description.value,
          args: buildArgumentMap(field.arguments),
          deprecationReason: getDeprecationReason(field),
          astNode: field
        };
      }
    }
    return fieldConfigMap;
  }
  function buildArgumentMap(args) {
    const argsNodes = args !== null && args !== undefined ? args : [];
    const argConfigMap = Object.create(null);
    for (const arg of argsNodes) {
      var _arg$description;
      const type = getWrappedType(arg.type);
      argConfigMap[arg.name.value] = {
        type,
        description: (_arg$description = arg.description) === null || _arg$description === undefined ? undefined : _arg$description.value,
        defaultValue: valueFromAST(arg.defaultValue, type),
        deprecationReason: getDeprecationReason(arg),
        astNode: arg
      };
    }
    return argConfigMap;
  }
  function buildInputFieldMap(nodes) {
    const inputFieldMap = Object.create(null);
    for (const node of nodes) {
      var _node$fields2;
      const fieldsNodes = (_node$fields2 = node.fields) !== null && _node$fields2 !== undefined ? _node$fields2 : [];
      for (const field of fieldsNodes) {
        var _field$description2;
        const type = getWrappedType(field.type);
        inputFieldMap[field.name.value] = {
          type,
          description: (_field$description2 = field.description) === null || _field$description2 === undefined ? undefined : _field$description2.value,
          defaultValue: valueFromAST(field.defaultValue, type),
          deprecationReason: getDeprecationReason(field),
          astNode: field
        };
      }
    }
    return inputFieldMap;
  }
  function buildEnumValueMap(nodes) {
    const enumValueMap = Object.create(null);
    for (const node of nodes) {
      var _node$values;
      const valuesNodes = (_node$values = node.values) !== null && _node$values !== undefined ? _node$values : [];
      for (const value of valuesNodes) {
        var _value$description;
        enumValueMap[value.name.value] = {
          description: (_value$description = value.description) === null || _value$description === undefined ? undefined : _value$description.value,
          deprecationReason: getDeprecationReason(value),
          astNode: value
        };
      }
    }
    return enumValueMap;
  }
  function buildInterfaces(nodes) {
    return nodes.flatMap((node) => {
      var _node$interfaces$map, _node$interfaces;
      return (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === undefined ? undefined : _node$interfaces.map(getNamedType2)) !== null && _node$interfaces$map !== undefined ? _node$interfaces$map : [];
    });
  }
  function buildUnionTypes(nodes) {
    return nodes.flatMap((node) => {
      var _node$types$map, _node$types;
      return (_node$types$map = (_node$types = node.types) === null || _node$types === undefined ? undefined : _node$types.map(getNamedType2)) !== null && _node$types$map !== undefined ? _node$types$map : [];
    });
  }
  function buildType(astNode) {
    var _typeExtensionsMap$na;
    const name = astNode.name.value;
    const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== undefined ? _typeExtensionsMap$na : [];
    switch (astNode.kind) {
      case Kind.OBJECT_TYPE_DEFINITION: {
        var _astNode$description;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLObjectType({
          name,
          description: (_astNode$description = astNode.description) === null || _astNode$description === undefined ? undefined : _astNode$description.value,
          interfaces: () => buildInterfaces(allNodes),
          fields: () => buildFieldMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.INTERFACE_TYPE_DEFINITION: {
        var _astNode$description2;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLInterfaceType({
          name,
          description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === undefined ? undefined : _astNode$description2.value,
          interfaces: () => buildInterfaces(allNodes),
          fields: () => buildFieldMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.ENUM_TYPE_DEFINITION: {
        var _astNode$description3;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLEnumType({
          name,
          description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === undefined ? undefined : _astNode$description3.value,
          values: buildEnumValueMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.UNION_TYPE_DEFINITION: {
        var _astNode$description4;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLUnionType({
          name,
          description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === undefined ? undefined : _astNode$description4.value,
          types: () => buildUnionTypes(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.SCALAR_TYPE_DEFINITION: {
        var _astNode$description5;
        return new GraphQLScalarType({
          name,
          description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === undefined ? undefined : _astNode$description5.value,
          specifiedByURL: getSpecifiedByURL(astNode),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.INPUT_OBJECT_TYPE_DEFINITION: {
        var _astNode$description6;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLInputObjectType({
          name,
          description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === undefined ? undefined : _astNode$description6.value,
          fields: () => buildInputFieldMap(allNodes),
          astNode,
          extensionASTNodes,
          isOneOf: isOneOf(astNode)
        });
      }
    }
  }
}
var getDeprecationReason = function(node) {
  const deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);
  return deprecated === null || deprecated === undefined ? undefined : deprecated.reason;
};
var getSpecifiedByURL = function(node) {
  const specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node);
  return specifiedBy === null || specifiedBy === undefined ? undefined : specifiedBy.url;
};
var isOneOf = function(node) {
  return Boolean(getDirectiveValues(GraphQLOneOfDirective, node));
};
var stdTypeMap = keyMap([...specifiedScalarTypes, ...introspectionTypes], (type) => type.name);

// ../../node_modules/graphql/utilities/buildASTSchema.mjs
function buildASTSchema(documentAST, options) {
  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(false, "Must provide valid Document AST.");
  if ((options === null || options === undefined ? undefined : options.assumeValid) !== true && (options === null || options === undefined ? undefined : options.assumeValidSDL) !== true) {
    assertValidSDL(documentAST);
  }
  const emptySchemaConfig = {
    description: undefined,
    types: [],
    directives: [],
    extensions: Object.create(null),
    extensionASTNodes: [],
    assumeValid: false
  };
  const config = extendSchemaImpl(emptySchemaConfig, documentAST, options);
  if (config.astNode == null) {
    for (const type of config.types) {
      switch (type.name) {
        case "Query":
          config.query = type;
          break;
        case "Mutation":
          config.mutation = type;
          break;
        case "Subscription":
          config.subscription = type;
          break;
      }
    }
  }
  const directives10 = [
    ...config.directives,
    ...specifiedDirectives.filter((stdDirective) => config.directives.every((directive) => directive.name !== stdDirective.name))
  ];
  return new GraphQLSchema({ ...config, directives: directives10 });
}
function buildSchema(source2, options) {
  const document = parse(source2, {
    noLocation: options === null || options === undefined ? undefined : options.noLocation,
    allowLegacyFragmentVariables: options === null || options === undefined ? undefined : options.allowLegacyFragmentVariables
  });
  return buildASTSchema(document, {
    assumeValidSDL: options === null || options === undefined ? undefined : options.assumeValidSDL,
    assumeValid: options === null || options === undefined ? undefined : options.assumeValid
  });
}
// ../../node_modules/graphql/utilities/lexicographicSortSchema.mjs
function lexicographicSortSchema(schema5) {
  const schemaConfig = schema5.toConfig();
  const typeMap = keyValMap(sortByName(schemaConfig.types), (type) => type.name, sortNamedType);
  return new GraphQLSchema({
    ...schemaConfig,
    types: Object.values(typeMap),
    directives: sortByName(schemaConfig.directives).map(sortDirective),
    query: replaceMaybeType(schemaConfig.query),
    mutation: replaceMaybeType(schemaConfig.mutation),
    subscription: replaceMaybeType(schemaConfig.subscription)
  });
  function replaceType(type) {
    if (isListType(type)) {
      return new GraphQLList(replaceType(type.ofType));
    } else if (isNonNullType(type)) {
      return new GraphQLNonNull(replaceType(type.ofType));
    }
    return replaceNamedType(type);
  }
  function replaceNamedType(type) {
    return typeMap[type.name];
  }
  function replaceMaybeType(maybeType) {
    return maybeType && replaceNamedType(maybeType);
  }
  function sortDirective(directive) {
    const config = directive.toConfig();
    return new GraphQLDirective({
      ...config,
      locations: sortBy(config.locations, (x) => x),
      args: sortArgs(config.args)
    });
  }
  function sortArgs(args) {
    return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));
  }
  function sortFields2(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => ({
      ...field,
      type: replaceType(field.type),
      args: field.args && sortArgs(field.args)
    }));
  }
  function sortInputFields(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => ({
      ...field,
      type: replaceType(field.type)
    }));
  }
  function sortTypes(array) {
    return sortByName(array).map(replaceNamedType);
  }
  function sortNamedType(type) {
    if (isScalarType(type) || isIntrospectionType(type)) {
      return type;
    }
    if (isObjectType(type)) {
      const config = type.toConfig();
      return new GraphQLObjectType({
        ...config,
        interfaces: () => sortTypes(config.interfaces),
        fields: () => sortFields2(config.fields)
      });
    }
    if (isInterfaceType(type)) {
      const config = type.toConfig();
      return new GraphQLInterfaceType({
        ...config,
        interfaces: () => sortTypes(config.interfaces),
        fields: () => sortFields2(config.fields)
      });
    }
    if (isUnionType(type)) {
      const config = type.toConfig();
      return new GraphQLUnionType({
        ...config,
        types: () => sortTypes(config.types)
      });
    }
    if (isEnumType(type)) {
      const config = type.toConfig();
      return new GraphQLEnumType({
        ...config,
        values: sortObjMap(config.values, (value) => value)
      });
    }
    if (isInputObjectType(type)) {
      const config = type.toConfig();
      return new GraphQLInputObjectType({
        ...config,
        fields: () => sortInputFields(config.fields)
      });
    }
    invariant(false, "Unexpected type: " + inspect(type));
  }
}
var sortObjMap = function(map, sortValueFn) {
  const sortedMap = Object.create(null);
  for (const key of Object.keys(map).sort(naturalCompare)) {
    sortedMap[key] = sortValueFn(map[key]);
  }
  return sortedMap;
};
var sortByName = function(array) {
  return sortBy(array, (obj) => obj.name);
};
var sortBy = function(array, mapToKey) {
  return array.slice().sort((obj1, obj2) => {
    const key1 = mapToKey(obj1);
    const key2 = mapToKey(obj2);
    return naturalCompare(key1, key2);
  });
};
// ../../node_modules/graphql/utilities/printSchema.mjs
function printSchema(schema5) {
  return printFilteredSchema(schema5, (n) => !isSpecifiedDirective(n), isDefinedType);
}
function printIntrospectionSchema(schema5) {
  return printFilteredSchema(schema5, isSpecifiedDirective, isIntrospectionType);
}
var isDefinedType = function(type) {
  return !isSpecifiedScalarType(type) && !isIntrospectionType(type);
};
var printFilteredSchema = function(schema5, directiveFilter, typeFilter) {
  const directives12 = schema5.getDirectives().filter(directiveFilter);
  const types = Object.values(schema5.getTypeMap()).filter(typeFilter);
  return [
    printSchemaDefinition(schema5),
    ...directives12.map((directive) => printDirective(directive)),
    ...types.map((type) => printType(type))
  ].filter(Boolean).join("\n\n");
};
var printSchemaDefinition = function(schema5) {
  if (schema5.description == null && isSchemaOfCommonNames(schema5)) {
    return;
  }
  const operationTypes = [];
  const queryType = schema5.getQueryType();
  if (queryType) {
    operationTypes.push(`  query: ${queryType.name}`);
  }
  const mutationType = schema5.getMutationType();
  if (mutationType) {
    operationTypes.push(`  mutation: ${mutationType.name}`);
  }
  const subscriptionType = schema5.getSubscriptionType();
  if (subscriptionType) {
    operationTypes.push(`  subscription: ${subscriptionType.name}`);
  }
  return printDescription(schema5) + `schema {\n${operationTypes.join("\n")}\n}`;
};
var isSchemaOfCommonNames = function(schema5) {
  const queryType = schema5.getQueryType();
  if (queryType && queryType.name !== "Query") {
    return false;
  }
  const mutationType = schema5.getMutationType();
  if (mutationType && mutationType.name !== "Mutation") {
    return false;
  }
  const subscriptionType = schema5.getSubscriptionType();
  if (subscriptionType && subscriptionType.name !== "Subscription") {
    return false;
  }
  return true;
};
function printType(type) {
  if (isScalarType(type)) {
    return printScalar(type);
  }
  if (isObjectType(type)) {
    return printObject(type);
  }
  if (isInterfaceType(type)) {
    return printInterface(type);
  }
  if (isUnionType(type)) {
    return printUnion(type);
  }
  if (isEnumType(type)) {
    return printEnum(type);
  }
  if (isInputObjectType(type)) {
    return printInputObject(type);
  }
  invariant(false, "Unexpected type: " + inspect(type));
}
var printScalar = function(type) {
  return printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type);
};
var printImplementedInterfaces = function(type) {
  const interfaces = type.getInterfaces();
  return interfaces.length ? " implements " + interfaces.map((i) => i.name).join(" & ") : "";
};
var printObject = function(type) {
  return printDescription(type) + `type ${type.name}` + printImplementedInterfaces(type) + printFields(type);
};
var printInterface = function(type) {
  return printDescription(type) + `interface ${type.name}` + printImplementedInterfaces(type) + printFields(type);
};
var printUnion = function(type) {
  const types = type.getTypes();
  const possibleTypes = types.length ? " = " + types.join(" | ") : "";
  return printDescription(type) + "union " + type.name + possibleTypes;
};
var printEnum = function(type) {
  const values3 = type.getValues().map((value, i) => printDescription(value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason));
  return printDescription(type) + `enum ${type.name}` + printBlock(values3);
};
var printInputObject = function(type) {
  const fields = Object.values(type.getFields()).map((f, i) => printDescription(f, "  ", !i) + "  " + printInputValue(f));
  return printDescription(type) + `input ${type.name}` + (type.isOneOf ? " @oneOf" : "") + printBlock(fields);
};
var printFields = function(type) {
  const fields = Object.values(type.getFields()).map((f, i) => printDescription(f, "  ", !i) + "  " + f.name + printArgs(f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason));
  return printBlock(fields);
};
var printBlock = function(items) {
  return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
};
var printArgs = function(args, indentation = "") {
  if (args.length === 0) {
    return "";
  }
  if (args.every((arg) => !arg.description)) {
    return "(" + args.map(printInputValue).join(", ") + ")";
  }
  return "(\n" + args.map((arg, i) => printDescription(arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg)).join("\n") + "\n" + indentation + ")";
};
var printInputValue = function(arg) {
  const defaultAST = astFromValue(arg.defaultValue, arg.type);
  let argDecl = arg.name + ": " + String(arg.type);
  if (defaultAST) {
    argDecl += ` = ${print(defaultAST)}`;
  }
  return argDecl + printDeprecated(arg.deprecationReason);
};
var printDirective = function(directive) {
  return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
};
var printDeprecated = function(reason) {
  if (reason == null) {
    return "";
  }
  if (reason !== DEFAULT_DEPRECATION_REASON) {
    const astValue = print({
      kind: Kind.STRING,
      value: reason
    });
    return ` @deprecated(reason: ${astValue})`;
  }
  return " @deprecated";
};
var printSpecifiedByURL = function(scalar) {
  if (scalar.specifiedByURL == null) {
    return "";
  }
  const astValue = print({
    kind: Kind.STRING,
    value: scalar.specifiedByURL
  });
  return ` @specifiedBy(url: ${astValue})`;
};
var printDescription = function(def, indentation = "", firstInBlock = true) {
  const { description } = def;
  if (description == null) {
    return "";
  }
  const blockString4 = print({
    kind: Kind.STRING,
    value: description,
    block: isPrintableAsBlockString(description)
  });
  const prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
  return prefix + blockString4.replace(/\n/g, "\n" + indentation) + "\n";
};
// ../../node_modules/@graphql-tools/utils/esm/helpers.js
function compareStrings(a, b) {
  if (String(a) < String(b)) {
    return -1;
  }
  if (String(a) > String(b)) {
    return 1;
  }
  return 0;
}
function nodeToString(a) {
  let name;
  if ("alias" in a) {
    name = a.alias?.value;
  }
  if (name == null && "name" in a) {
    name = a.name?.value;
  }
  if (name == null) {
    name = a.kind;
  }
  return name;
}
function compareNodes(a, b, customFn) {
  const aStr = nodeToString(a);
  const bStr = nodeToString(b);
  if (typeof customFn === "function") {
    return customFn(aStr, bStr);
  }
  return compareStrings(aStr, bStr);
}
function isSome(input) {
  return input != null;
}
var asArray = (fns) => Array.isArray(fns) ? fns : fns ? [fns] : [];
// ../../node_modules/cross-inspect/esm/index.js
function inspect26(value) {
  return formatValue2(value, []);
}
var formatValue2 = function(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue2(value, seenValues);
    default:
      return String(value);
  }
};
var formatError2 = function(value) {
  if (value.name = "GraphQLError") {
    return value.toString();
  }
  return `${value.name}: ${value.message};\n ${value.stack}`;
};
var formatObjectValue2 = function(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (value instanceof Error) {
    if (value.name === "AggregateError") {
      return formatError2(value) + "\n" + formatArray2(value.errors, previouslySeenValues);
    }
    return formatError2(value);
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable2(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue2(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray2(value, seenValues);
  }
  return formatObject2(value, seenValues);
};
var isJSONable2 = function(value) {
  return typeof value.toJSON === "function";
};
var formatObject2 = function(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
    return "[" + getObjectTag2(object) + "]";
  }
  const properties = entries.map(([key, value]) => key + ": " + formatValue2(value, seenValues));
  return "{ " + properties.join(", ") + " }";
};
var formatArray2 = function(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
    return "[Array]";
  }
  const len = array.length;
  const items = [];
  for (let i = 0;i < len; ++i) {
    items.push(formatValue2(array[i], seenValues));
  }
  return "[" + items.join(", ") + "]";
};
var getObjectTag2 = function(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
};
var MAX_RECURSIVE_DEPTH2 = 3;

// ../../node_modules/@graphql-tools/utils/esm/errors.js
var isGraphQLErrorLike = function(error) {
  return error != null && typeof error === "object" && Object.keys(error).every((key) => possibleGraphQLErrorProperties.includes(key));
};
function createGraphQLError(message, options) {
  if (options?.originalError && !(options.originalError instanceof Error) && isGraphQLErrorLike(options.originalError)) {
    options.originalError = createGraphQLError(options.originalError.message, options.originalError);
  }
  if (versionInfo.major >= 17) {
    return new GraphQLError(message, options);
  }
  return new GraphQLError(message, options?.nodes, options?.source, options?.positions, options?.path, options?.originalError, options?.extensions);
}
var possibleGraphQLErrorProperties = [
  "message",
  "locations",
  "path",
  "nodes",
  "source",
  "positions",
  "originalError",
  "name",
  "stack",
  "extensions"
];

// ../../node_modules/@graphql-tools/utils/esm/jsutils.js
function isIterableObject4(value) {
  return value != null && typeof value === "object" && Symbol.iterator in value;
}
function isObjectLike10(value) {
  return typeof value === "object" && value !== null;
}
function isPromise3(value) {
  return value?.then != null;
}
function promiseReduce(values3, callbackFn, initialValue) {
  let accumulator = initialValue;
  for (const value of values3) {
    accumulator = isPromise3(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
  }
  return accumulator;
}
function hasOwnProperty2(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// ../../node_modules/@graphql-tools/utils/esm/getArgumentValues.js
function getArgumentValues2(def, node, variableValues = {}) {
  const coercedValues = {};
  const argumentNodes = node.arguments ?? [];
  const argNodeMap = argumentNodes.reduce((prev, arg) => ({
    ...prev,
    [arg.name.value]: arg
  }), {});
  for (const { name, type: argType, defaultValue } of def.args) {
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (defaultValue !== undefined) {
        coercedValues[name] = defaultValue;
      } else if (isNonNullType(argType)) {
        throw createGraphQLError(`Argument "${name}" of required type "${inspect26(argType)}" ` + "was not provided.", {
          nodes: [node]
        });
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty2(variableValues, variableName)) {
        if (defaultValue !== undefined) {
          coercedValues[name] = defaultValue;
        } else if (isNonNullType(argType)) {
          throw createGraphQLError(`Argument "${name}" of required type "${inspect26(argType)}" ` + `was provided the variable "\$${variableName}" which was not provided a runtime value.`, {
            nodes: [valueNode]
          });
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw createGraphQLError(`Argument "${name}" of non-null type "${inspect26(argType)}" ` + "must not be null.", {
        nodes: [valueNode]
      });
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === undefined) {
      throw createGraphQLError(`Argument "${name}" has invalid value ${print(valueNode)}.`, {
        nodes: [valueNode]
      });
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}

// ../../node_modules/@graphql-tools/utils/esm/memoize.js
function memoize1(fn) {
  const memoize1cache = new WeakMap;
  return function memoized(a1) {
    const cachedValue = memoize1cache.get(a1);
    if (cachedValue === undefined) {
      const newValue = fn(a1);
      memoize1cache.set(a1, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
function memoize33(fn) {
  const memoize3Cache = new WeakMap;
  return function memoized(a1, a2, a3) {
    let cache2 = memoize3Cache.get(a1);
    if (!cache2) {
      cache2 = new WeakMap;
      memoize3Cache.set(a1, cache2);
      const cache32 = new WeakMap;
      cache2.set(a2, cache32);
      const newValue = fn(a1, a2, a3);
      cache32.set(a3, newValue);
      return newValue;
    }
    let cache3 = cache2.get(a2);
    if (!cache3) {
      cache3 = new WeakMap;
      cache2.set(a2, cache3);
      const newValue = fn(a1, a2, a3);
      cache3.set(a3, newValue);
      return newValue;
    }
    const cachedValue = cache3.get(a3);
    if (cachedValue === undefined) {
      const newValue = fn(a1, a2, a3);
      cache3.set(a3, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
function memoize5(fn) {
  const memoize5Cache = new WeakMap;
  return function memoized(a1, a2, a3, a4, a5) {
    let cache2 = memoize5Cache.get(a1);
    if (!cache2) {
      cache2 = new WeakMap;
      memoize5Cache.set(a1, cache2);
      const cache32 = new WeakMap;
      cache2.set(a2, cache32);
      const cache42 = new WeakMap;
      cache32.set(a3, cache42);
      const cache52 = new WeakMap;
      cache42.set(a4, cache52);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache3 = cache2.get(a2);
    if (!cache3) {
      cache3 = new WeakMap;
      cache2.set(a2, cache3);
      const cache42 = new WeakMap;
      cache3.set(a3, cache42);
      const cache52 = new WeakMap;
      cache42.set(a4, cache52);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache4 = cache3.get(a3);
    if (!cache4) {
      cache4 = new WeakMap;
      cache3.set(a3, cache4);
      const cache52 = new WeakMap;
      cache4.set(a4, cache52);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache52.set(a5, newValue);
      return newValue;
    }
    let cache5 = cache4.get(a4);
    if (!cache5) {
      cache5 = new WeakMap;
      cache4.set(a4, cache5);
      const newValue = fn(a1, a2, a3, a4, a5);
      cache5.set(a5, newValue);
      return newValue;
    }
    const cachedValue = cache5.get(a5);
    if (cachedValue === undefined) {
      const newValue = fn(a1, a2, a3, a4, a5);
      cache5.set(a5, newValue);
      return newValue;
    }
    return cachedValue;
  };
}

// ../../node_modules/@graphql-tools/utils/esm/getDirectiveExtensions.js
function getDirectiveExtensions(directableObj, schema5, pathToDirectivesInExtensions = ["directives"]) {
  const directiveExtensions = {};
  if (directableObj.extensions) {
    let directivesInExtensions = directableObj.extensions;
    for (const pathSegment of pathToDirectivesInExtensions) {
      directivesInExtensions = directivesInExtensions?.[pathSegment];
    }
    if (directivesInExtensions != null) {
      for (const directiveNameProp in directivesInExtensions) {
        const directiveObjs = directivesInExtensions[directiveNameProp];
        const directiveName = directiveNameProp;
        if (Array.isArray(directiveObjs)) {
          for (const directiveObj of directiveObjs) {
            let existingDirectiveExtensions = directiveExtensions[directiveName];
            if (!existingDirectiveExtensions) {
              existingDirectiveExtensions = [];
              directiveExtensions[directiveName] = existingDirectiveExtensions;
            }
            existingDirectiveExtensions.push(directiveObj);
          }
        } else {
          let existingDirectiveExtensions = directiveExtensions[directiveName];
          if (!existingDirectiveExtensions) {
            existingDirectiveExtensions = [];
            directiveExtensions[directiveName] = existingDirectiveExtensions;
          }
          existingDirectiveExtensions.push(directiveObjs);
        }
      }
    }
  }
  const memoizedStringify = memoize1((obj) => JSON.stringify(obj));
  const astNodes = [];
  if (directableObj.astNode) {
    astNodes.push(directableObj.astNode);
  }
  if (directableObj.extensionASTNodes) {
    astNodes.push(...directableObj.extensionASTNodes);
  }
  for (const astNode of astNodes) {
    if (astNode.directives?.length) {
      for (const directive of astNode.directives) {
        const directiveName = directive.name.value;
        let existingDirectiveExtensions = directiveExtensions[directiveName];
        if (!existingDirectiveExtensions) {
          existingDirectiveExtensions = [];
          directiveExtensions[directiveName] = existingDirectiveExtensions;
        }
        const directiveInSchema = schema5?.getDirective(directiveName);
        let value = {};
        if (directiveInSchema) {
          value = getArgumentValues2(directiveInSchema, directive);
        }
        if (directive.arguments) {
          for (const argNode of directive.arguments) {
            const argName = argNode.name.value;
            if (value[argName] == null) {
              const argInDirective = directiveInSchema?.args.find((arg) => arg.name === argName);
              if (argInDirective) {
                value[argName] = valueFromAST(argNode.value, argInDirective.type);
              }
            }
            if (value[argName] == null) {
              value[argName] = valueFromASTUntyped(argNode.value);
            }
          }
        }
        if (astNodes.length > 0 && existingDirectiveExtensions.length > 0) {
          const valStr = memoizedStringify(value);
          if (existingDirectiveExtensions.some((val) => memoizedStringify(val) === valStr)) {
            continue;
          }
        }
        existingDirectiveExtensions.push(value);
      }
    }
  }
  return directiveExtensions;
}

// ../../node_modules/@graphql-tools/utils/esm/get-directives.js
function getDirectivesInExtensions(node, pathToDirectivesInExtensions = ["directives"]) {
  const directiveExtensions = getDirectiveExtensions(node, undefined, pathToDirectivesInExtensions);
  return Object.entries(directiveExtensions).map(([directiveName, directiveArgsArr]) => directiveArgsArr?.map((directiveArgs) => ({
    name: directiveName,
    args: directiveArgs
  }))).flat(Infinity).filter(Boolean);
}
// ../../node_modules/@graphql-tools/utils/esm/astFromType.js
function astFromType(type) {
  if (isNonNullType(type)) {
    const innerType = astFromType(type.ofType);
    if (innerType.kind === Kind.NON_NULL_TYPE) {
      throw new Error(`Invalid type node ${inspect26(type)}. Inner type of non-null type cannot be a non-null type.`);
    }
    return {
      kind: Kind.NON_NULL_TYPE,
      type: innerType
    };
  } else if (isListType(type)) {
    return {
      kind: Kind.LIST_TYPE,
      type: astFromType(type.ofType)
    };
  }
  return {
    kind: Kind.NAMED_TYPE,
    name: {
      kind: Kind.NAME,
      value: type.name
    }
  };
}

// ../../node_modules/@graphql-tools/utils/esm/astFromValueUntyped.js
function astFromValueUntyped(value) {
  if (value === null) {
    return { kind: Kind.NULL };
  }
  if (value === undefined) {
    return null;
  }
  if (Array.isArray(value)) {
    const valuesNodes = [];
    for (const item of value) {
      const itemNode = astFromValueUntyped(item);
      if (itemNode != null) {
        valuesNodes.push(itemNode);
      }
    }
    return { kind: Kind.LIST, values: valuesNodes };
  }
  if (typeof value === "object") {
    if (value?.toJSON) {
      return astFromValueUntyped(value.toJSON());
    }
    const fieldNodes = [];
    for (const fieldName in value) {
      const fieldValue = value[fieldName];
      const ast8 = astFromValueUntyped(fieldValue);
      if (ast8) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: { kind: Kind.NAME, value: fieldName },
          value: ast8
        });
      }
    }
    return { kind: Kind.OBJECT, fields: fieldNodes };
  }
  if (typeof value === "boolean") {
    return { kind: Kind.BOOLEAN, value };
  }
  if (typeof value === "bigint") {
    return { kind: Kind.INT, value: String(value) };
  }
  if (typeof value === "number" && isFinite(value)) {
    const stringNum = String(value);
    return integerStringRegExp2.test(stringNum) ? { kind: Kind.INT, value: stringNum } : { kind: Kind.FLOAT, value: stringNum };
  }
  if (typeof value === "string") {
    return { kind: Kind.STRING, value };
  }
  throw new TypeError(`Cannot convert value to AST: ${value}.`);
}
var integerStringRegExp2 = /^-?(?:0|[1-9][0-9]*)$/;

// ../../node_modules/@graphql-tools/utils/esm/astFromValue.js
function astFromValue4(value, type) {
  if (isNonNullType(type)) {
    const astValue = astFromValue4(value, type.ofType);
    if (astValue?.kind === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value === null) {
    return { kind: Kind.NULL };
  }
  if (value === undefined) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject4(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValue4(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return { kind: Kind.LIST, values: valuesNodes };
    }
    return astFromValue4(value, itemType);
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike10(value)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type.getFields())) {
      const fieldValue = astFromValue4(value[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: { kind: Kind.NAME, value: field.name },
          value: fieldValue
        });
      }
    }
    return { kind: Kind.OBJECT, fields: fieldNodes };
  }
  if (isLeafType(type)) {
    const serialized = type.serialize(value);
    if (serialized == null) {
      return null;
    }
    if (isEnumType(type)) {
      return { kind: Kind.ENUM, value: serialized };
    }
    if (type.name === "ID" && typeof serialized === "string" && integerStringRegExp3.test(serialized)) {
      return { kind: Kind.INT, value: serialized };
    }
    return astFromValueUntyped(serialized);
  }
  console.assert(false, "Unexpected input type: " + inspect26(type));
}
var integerStringRegExp3 = /^-?(?:0|[1-9][0-9]*)$/;

// ../../node_modules/@graphql-tools/utils/esm/descriptionFromObject.js
function getDescriptionNode(obj) {
  if (obj.astNode?.description) {
    return {
      ...obj.astNode.description,
      block: true
    };
  }
  if (obj.description) {
    return {
      kind: Kind.STRING,
      value: obj.description,
      block: true
    };
  }
}

// ../../node_modules/@graphql-tools/utils/esm/rootTypes.js
function getDefinedRootType(schema5, operation, nodes) {
  const rootTypeMap = getRootTypeMap(schema5);
  const rootType = rootTypeMap.get(operation);
  if (rootType == null) {
    throw createGraphQLError(`Schema is not configured to execute ${operation} operation.`, {
      nodes
    });
  }
  return rootType;
}
var getRootTypeNames = memoize1(function getRootTypeNames2(schema5) {
  const rootTypes = getRootTypes(schema5);
  return new Set([...rootTypes].map((type) => type.name));
});
var getRootTypes = memoize1(function getRootTypes2(schema5) {
  const rootTypeMap = getRootTypeMap(schema5);
  return new Set(rootTypeMap.values());
});
var getRootTypeMap = memoize1(function getRootTypeMap2(schema5) {
  const rootTypeMap = new Map;
  const queryType = schema5.getQueryType();
  if (queryType) {
    rootTypeMap.set("query", queryType);
  }
  const mutationType = schema5.getMutationType();
  if (mutationType) {
    rootTypeMap.set("mutation", mutationType);
  }
  const subscriptionType = schema5.getSubscriptionType();
  if (subscriptionType) {
    rootTypeMap.set("subscription", subscriptionType);
  }
  return rootTypeMap;
});

// ../../node_modules/@graphql-tools/utils/esm/print-schema-with-directives.js
function getDocumentNodeFromSchema(schema5, options = {}) {
  const pathToDirectivesInExtensions = options.pathToDirectivesInExtensions;
  const typesMap = schema5.getTypeMap();
  const schemaNode = astFromSchema(schema5, pathToDirectivesInExtensions);
  const definitions = schemaNode != null ? [schemaNode] : [];
  const directives12 = schema5.getDirectives();
  for (const directive of directives12) {
    if (isSpecifiedDirective(directive)) {
      continue;
    }
    definitions.push(astFromDirective(directive, schema5, pathToDirectivesInExtensions));
  }
  for (const typeName in typesMap) {
    const type = typesMap[typeName];
    const isPredefinedScalar = isSpecifiedScalarType(type);
    const isIntrospection = isIntrospectionType(type);
    if (isPredefinedScalar || isIntrospection) {
      continue;
    }
    if (isObjectType(type)) {
      definitions.push(astFromObjectType(type, schema5, pathToDirectivesInExtensions));
    } else if (isInterfaceType(type)) {
      definitions.push(astFromInterfaceType(type, schema5, pathToDirectivesInExtensions));
    } else if (isUnionType(type)) {
      definitions.push(astFromUnionType(type, schema5, pathToDirectivesInExtensions));
    } else if (isInputObjectType(type)) {
      definitions.push(astFromInputObjectType(type, schema5, pathToDirectivesInExtensions));
    } else if (isEnumType(type)) {
      definitions.push(astFromEnumType(type, schema5, pathToDirectivesInExtensions));
    } else if (isScalarType(type)) {
      definitions.push(astFromScalarType(type, schema5, pathToDirectivesInExtensions));
    } else {
      throw new Error(`Unknown type ${type}.`);
    }
  }
  return {
    kind: Kind.DOCUMENT,
    definitions
  };
}
function astFromSchema(schema5, pathToDirectivesInExtensions) {
  const operationTypeMap = new Map([
    ["query", undefined],
    ["mutation", undefined],
    ["subscription", undefined]
  ]);
  const nodes = [];
  if (schema5.astNode != null) {
    nodes.push(schema5.astNode);
  }
  if (schema5.extensionASTNodes != null) {
    for (const extensionASTNode of schema5.extensionASTNodes) {
      nodes.push(extensionASTNode);
    }
  }
  for (const node of nodes) {
    if (node.operationTypes) {
      for (const operationTypeDefinitionNode of node.operationTypes) {
        operationTypeMap.set(operationTypeDefinitionNode.operation, operationTypeDefinitionNode);
      }
    }
  }
  const rootTypeMap = getRootTypeMap(schema5);
  for (const [operationTypeNode, operationTypeDefinitionNode] of operationTypeMap) {
    const rootType = rootTypeMap.get(operationTypeNode);
    if (rootType != null) {
      const rootTypeAST = astFromType(rootType);
      if (operationTypeDefinitionNode != null) {
        operationTypeDefinitionNode.type = rootTypeAST;
      } else {
        operationTypeMap.set(operationTypeNode, {
          kind: Kind.OPERATION_TYPE_DEFINITION,
          operation: operationTypeNode,
          type: rootTypeAST
        });
      }
    }
  }
  const operationTypes = [...operationTypeMap.values()].filter(isSome);
  const directives12 = getDirectiveNodes(schema5, schema5, pathToDirectivesInExtensions);
  if (!operationTypes.length && !directives12.length) {
    return null;
  }
  const schemaNode = {
    kind: operationTypes != null ? Kind.SCHEMA_DEFINITION : Kind.SCHEMA_EXTENSION,
    operationTypes,
    directives: directives12
  };
  const descriptionNode = getDescriptionNode(schema5);
  if (descriptionNode) {
    schemaNode.description = descriptionNode;
  }
  return schemaNode;
}
function astFromDirective(directive, schema5, pathToDirectivesInExtensions) {
  return {
    kind: Kind.DIRECTIVE_DEFINITION,
    description: getDescriptionNode(directive),
    name: {
      kind: Kind.NAME,
      value: directive.name
    },
    arguments: directive.args?.map((arg) => astFromArg(arg, schema5, pathToDirectivesInExtensions)),
    repeatable: directive.isRepeatable,
    locations: directive.locations?.map((location3) => ({
      kind: Kind.NAME,
      value: location3
    })) || []
  };
}
function getDirectiveNodes(entity, schema5, pathToDirectivesInExtensions) {
  let directiveNodesBesidesDeprecatedAndSpecifiedBy = [];
  const directivesInExtensions = getDirectivesInExtensions(entity, pathToDirectivesInExtensions);
  let directives12;
  if (directivesInExtensions != null) {
    directives12 = makeDirectiveNodes(schema5, directivesInExtensions);
  }
  let deprecatedDirectiveNode = null;
  let specifiedByDirectiveNode = null;
  if (directives12 != null) {
    directiveNodesBesidesDeprecatedAndSpecifiedBy = directives12.filter((directive) => directive.name.value !== "deprecated" && directive.name.value !== "specifiedBy");
    if (entity.deprecationReason != null) {
      deprecatedDirectiveNode = directives12.filter((directive) => directive.name.value === "deprecated")?.[0];
    }
    if (entity.specifiedByUrl != null || entity.specifiedByURL != null) {
      specifiedByDirectiveNode = directives12.filter((directive) => directive.name.value === "specifiedBy")?.[0];
    }
  }
  if (entity.deprecationReason != null && deprecatedDirectiveNode == null) {
    deprecatedDirectiveNode = makeDeprecatedDirective(entity.deprecationReason);
  }
  if (entity.specifiedByUrl != null || entity.specifiedByURL != null && specifiedByDirectiveNode == null) {
    const specifiedByValue = entity.specifiedByUrl || entity.specifiedByURL;
    const specifiedByArgs = {
      url: specifiedByValue
    };
    specifiedByDirectiveNode = makeDirectiveNode("specifiedBy", specifiedByArgs);
  }
  if (deprecatedDirectiveNode != null) {
    directiveNodesBesidesDeprecatedAndSpecifiedBy.push(deprecatedDirectiveNode);
  }
  if (specifiedByDirectiveNode != null) {
    directiveNodesBesidesDeprecatedAndSpecifiedBy.push(specifiedByDirectiveNode);
  }
  return directiveNodesBesidesDeprecatedAndSpecifiedBy;
}
function astFromArg(arg, schema5, pathToDirectivesInExtensions) {
  return {
    kind: Kind.INPUT_VALUE_DEFINITION,
    description: getDescriptionNode(arg),
    name: {
      kind: Kind.NAME,
      value: arg.name
    },
    type: astFromType(arg.type),
    defaultValue: arg.defaultValue !== undefined ? astFromValue4(arg.defaultValue, arg.type) ?? undefined : undefined,
    directives: getDirectiveNodes(arg, schema5, pathToDirectivesInExtensions)
  };
}
function astFromObjectType(type, schema5, pathToDirectivesInExtensions) {
  return {
    kind: Kind.OBJECT_TYPE_DEFINITION,
    description: getDescriptionNode(type),
    name: {
      kind: Kind.NAME,
      value: type.name
    },
    fields: Object.values(type.getFields()).map((field) => astFromField(field, schema5, pathToDirectivesInExtensions)),
    interfaces: Object.values(type.getInterfaces()).map((iFace) => astFromType(iFace)),
    directives: getDirectiveNodes(type, schema5, pathToDirectivesInExtensions)
  };
}
function astFromInterfaceType(type, schema5, pathToDirectivesInExtensions) {
  const node = {
    kind: Kind.INTERFACE_TYPE_DEFINITION,
    description: getDescriptionNode(type),
    name: {
      kind: Kind.NAME,
      value: type.name
    },
    fields: Object.values(type.getFields()).map((field) => astFromField(field, schema5, pathToDirectivesInExtensions)),
    directives: getDirectiveNodes(type, schema5, pathToDirectivesInExtensions)
  };
  if ("getInterfaces" in type) {
    node.interfaces = Object.values(type.getInterfaces()).map((iFace) => astFromType(iFace));
  }
  return node;
}
function astFromUnionType(type, schema5, pathToDirectivesInExtensions) {
  return {
    kind: Kind.UNION_TYPE_DEFINITION,
    description: getDescriptionNode(type),
    name: {
      kind: Kind.NAME,
      value: type.name
    },
    directives: getDirectiveNodes(type, schema5, pathToDirectivesInExtensions),
    types: type.getTypes().map((type2) => astFromType(type2))
  };
}
function astFromInputObjectType(type, schema5, pathToDirectivesInExtensions) {
  return {
    kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
    description: getDescriptionNode(type),
    name: {
      kind: Kind.NAME,
      value: type.name
    },
    fields: Object.values(type.getFields()).map((field) => astFromInputField(field, schema5, pathToDirectivesInExtensions)),
    directives: getDirectiveNodes(type, schema5, pathToDirectivesInExtensions)
  };
}
function astFromEnumType(type, schema5, pathToDirectivesInExtensions) {
  return {
    kind: Kind.ENUM_TYPE_DEFINITION,
    description: getDescriptionNode(type),
    name: {
      kind: Kind.NAME,
      value: type.name
    },
    values: Object.values(type.getValues()).map((value) => astFromEnumValue(value, schema5, pathToDirectivesInExtensions)),
    directives: getDirectiveNodes(type, schema5, pathToDirectivesInExtensions)
  };
}
function astFromScalarType(type, schema5, pathToDirectivesInExtensions) {
  const directivesInExtensions = getDirectivesInExtensions(type, pathToDirectivesInExtensions);
  const directives12 = makeDirectiveNodes(schema5, directivesInExtensions);
  const specifiedByValue = type["specifiedByUrl"] || type["specifiedByURL"];
  if (specifiedByValue && !directives12.some((directiveNode) => directiveNode.name.value === "specifiedBy")) {
    const specifiedByArgs = {
      url: specifiedByValue
    };
    directives12.push(makeDirectiveNode("specifiedBy", specifiedByArgs));
  }
  return {
    kind: Kind.SCALAR_TYPE_DEFINITION,
    description: getDescriptionNode(type),
    name: {
      kind: Kind.NAME,
      value: type.name
    },
    directives: directives12
  };
}
function astFromField(field, schema5, pathToDirectivesInExtensions) {
  return {
    kind: Kind.FIELD_DEFINITION,
    description: getDescriptionNode(field),
    name: {
      kind: Kind.NAME,
      value: field.name
    },
    arguments: field.args.map((arg) => astFromArg(arg, schema5, pathToDirectivesInExtensions)),
    type: astFromType(field.type),
    directives: getDirectiveNodes(field, schema5, pathToDirectivesInExtensions)
  };
}
function astFromInputField(field, schema5, pathToDirectivesInExtensions) {
  return {
    kind: Kind.INPUT_VALUE_DEFINITION,
    description: getDescriptionNode(field),
    name: {
      kind: Kind.NAME,
      value: field.name
    },
    type: astFromType(field.type),
    directives: getDirectiveNodes(field, schema5, pathToDirectivesInExtensions),
    defaultValue: astFromValue4(field.defaultValue, field.type) ?? undefined
  };
}
function astFromEnumValue(value, schema5, pathToDirectivesInExtensions) {
  return {
    kind: Kind.ENUM_VALUE_DEFINITION,
    description: getDescriptionNode(value),
    name: {
      kind: Kind.NAME,
      value: value.name
    },
    directives: getDirectiveNodes(value, schema5, pathToDirectivesInExtensions)
  };
}
function makeDeprecatedDirective(deprecationReason) {
  return makeDirectiveNode("deprecated", { reason: deprecationReason }, GraphQLDeprecatedDirective);
}
function makeDirectiveNode(name, args, directive) {
  const directiveArguments = [];
  for (const argName in args) {
    const argValue = args[argName];
    let value;
    if (directive != null) {
      const arg = directive.args.find((arg2) => arg2.name === argName);
      if (arg) {
        value = astFromValue4(argValue, arg.type);
      }
    }
    if (value == null) {
      value = astFromValueUntyped(argValue);
    }
    if (value != null) {
      directiveArguments.push({
        kind: Kind.ARGUMENT,
        name: {
          kind: Kind.NAME,
          value: argName
        },
        value
      });
    }
  }
  return {
    kind: Kind.DIRECTIVE,
    name: {
      kind: Kind.NAME,
      value: name
    },
    arguments: directiveArguments
  };
}
function makeDirectiveNodes(schema5, directiveValues) {
  const directiveNodes = [];
  for (const { name, args } of directiveValues) {
    const directive = schema5?.getDirective(name);
    directiveNodes.push(makeDirectiveNode(name, args, directive));
  }
  return directiveNodes;
}
// ../../node_modules/@graphql-tools/utils/esm/validate-documents.js
function validateGraphQlDocuments(schema5, documents, rules = createDefaultRules()) {
  const definitions = new Set;
  const fragmentsDefinitionsMap = new Map;
  for (const document of documents) {
    for (const docDefinition of document.definitions) {
      if (docDefinition.kind === Kind.FRAGMENT_DEFINITION) {
        fragmentsDefinitionsMap.set(docDefinition.name.value, docDefinition);
      } else {
        definitions.add(docDefinition);
      }
    }
  }
  const fullAST = {
    kind: Kind.DOCUMENT,
    definitions: Array.from([...definitions, ...fragmentsDefinitionsMap.values()])
  };
  const errors3 = validate2(schema5, fullAST, rules);
  for (const error of errors3) {
    error.stack = error.message;
    if (error.locations) {
      for (const location3 of error.locations) {
        error.stack += `\n    at ${error.source?.name}:${location3.line}:${location3.column}`;
      }
    }
  }
  return errors3;
}
function createDefaultRules() {
  let ignored = ["NoUnusedFragmentsRule", "NoUnusedVariablesRule", "KnownDirectivesRule"];
  if (versionInfo.major < 15) {
    ignored = ignored.map((rule) => rule.replace(/Rule$/, ""));
  }
  return specifiedRules.filter((f) => !ignored.includes(f.name));
}
// ../../node_modules/@graphql-tools/utils/esm/comments.js
function resetComments() {
  commentsRegistry = {};
}
function collectComment(node) {
  const entityName = node.name?.value;
  if (entityName == null) {
    return;
  }
  pushComment(node, entityName);
  switch (node.kind) {
    case "EnumTypeDefinition":
      if (node.values) {
        for (const value of node.values) {
          pushComment(value, entityName, value.name.value);
        }
      }
      break;
    case "ObjectTypeDefinition":
    case "InputObjectTypeDefinition":
    case "InterfaceTypeDefinition":
      if (node.fields) {
        for (const field of node.fields) {
          pushComment(field, entityName, field.name.value);
          if (isFieldDefinitionNode(field) && field.arguments) {
            for (const arg of field.arguments) {
              pushComment(arg, entityName, field.name.value, arg.name.value);
            }
          }
        }
      }
      break;
  }
}
function pushComment(node, entity, field, argument) {
  const comment = getComment(node);
  if (typeof comment !== "string" || comment.length === 0) {
    return;
  }
  const keys = [entity];
  if (field) {
    keys.push(field);
    if (argument) {
      keys.push(argument);
    }
  }
  const path = keys.join(".");
  if (!commentsRegistry[path]) {
    commentsRegistry[path] = [];
  }
  commentsRegistry[path].push(comment);
}
function printComment(comment) {
  return "\n# " + comment.replace(/\n/g, "\n# ");
}
var join2 = function(maybeArray, separator) {
  return maybeArray ? maybeArray.filter((x) => x).join(separator || "") : "";
};
var hasMultilineItems2 = function(maybeArray) {
  return maybeArray?.some((str) => str.includes("\n")) ?? false;
};
var addDescription = function(cb) {
  return (node, _key, _parent, path, ancestors) => {
    const keys = [];
    const parent = path.reduce((prev, key2) => {
      if (["fields", "arguments", "values"].includes(key2) && prev.name) {
        keys.push(prev.name.value);
      }
      return prev[key2];
    }, ancestors[0]);
    const key = [...keys, parent?.name?.value].filter(Boolean).join(".");
    const items = [];
    if (node.kind.includes("Definition") && commentsRegistry[key]) {
      items.push(...commentsRegistry[key]);
    }
    return join2([...items.map(printComment), node.description, cb(node, _key, _parent, path, ancestors)], "\n");
  };
};
var indent2 = function(maybeString) {
  return maybeString && `  ${maybeString.replace(/\n/g, "\n  ")}`;
};
var block2 = function(array) {
  return array && array.length !== 0 ? `{\n${indent2(join2(array, "\n"))}\n}` : "";
};
var wrap2 = function(start, maybeString, end) {
  return maybeString ? start + maybeString + (end || "") : "";
};
var printBlockString2 = function(value, isDescription = false) {
  const escaped = value.replace(/"""/g, '\\"""');
  return (value[0] === " " || value[0] === "\t") && value.indexOf("\n") === -1 ? `"""${escaped.replace(/"$/, '"\n')}"""` : `"""\n${isDescription ? escaped : indent2(escaped)}\n"""`;
};
function printWithComments(ast8) {
  return visit(ast8, printDocASTReducerWithComments);
}
var isFieldDefinitionNode = function(node) {
  return node.kind === "FieldDefinition";
};
function getComment(node) {
  const rawValue = getLeadingCommentBlock(node);
  if (rawValue !== undefined) {
    return dedentBlockStringValue(`\n${rawValue}`);
  }
}
function getLeadingCommentBlock(node) {
  const loc = node.loc;
  if (!loc) {
    return;
  }
  const comments = [];
  let token = loc.startToken.prev;
  while (token != null && token.kind === TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {
    const value = String(token.value);
    comments.push(value);
    token = token.prev;
  }
  return comments.length > 0 ? comments.reverse().join("\n") : undefined;
}
function dedentBlockStringValue(rawString) {
  const lines = rawString.split(/\r\n|[\n\r]/g);
  const commonIndent = getBlockStringIndentation(lines);
  if (commonIndent !== 0) {
    for (let i = 1;i < lines.length; i++) {
      lines[i] = lines[i].slice(commonIndent);
    }
  }
  while (lines.length > 0 && isBlank(lines[0])) {
    lines.shift();
  }
  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
    lines.pop();
  }
  return lines.join("\n");
}
function getBlockStringIndentation(lines) {
  let commonIndent = null;
  for (let i = 1;i < lines.length; i++) {
    const line = lines[i];
    const indent3 = leadingWhitespace2(line);
    if (indent3 === line.length) {
      continue;
    }
    if (commonIndent === null || indent3 < commonIndent) {
      commonIndent = indent3;
      if (commonIndent === 0) {
        break;
      }
    }
  }
  return commonIndent === null ? 0 : commonIndent;
}
var leadingWhitespace2 = function(str) {
  let i = 0;
  while (i < str.length && (str[i] === " " || str[i] === "\t")) {
    i++;
  }
  return i;
};
var isBlank = function(str) {
  return leadingWhitespace2(str) === str.length;
};
var MAX_LINE_LENGTH2 = 80;
var commentsRegistry = {};
var printDocASTReducer2 = {
  Name: { leave: (node) => node.value },
  Variable: { leave: (node) => "$" + node.name },
  Document: {
    leave: (node) => join2(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave: (node) => {
      const varDefs = wrap2("(", join2(node.variableDefinitions, ", "), ")");
      const prefix = join2([node.operation, join2([node.name, varDefs]), join2(node.directives, " ")], " ");
      return prefix + " " + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type, defaultValue, directives: directives12 }) => variable + ": " + type + wrap2(" = ", defaultValue) + wrap2(" ", join2(directives12, " "))
  },
  SelectionSet: { leave: ({ selections }) => block2(selections) },
  Field: {
    leave({ alias, name, arguments: args, directives: directives12, selectionSet }) {
      const prefix = wrap2("", alias, ": ") + name;
      let argsLine = prefix + wrap2("(", join2(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH2) {
        argsLine = prefix + wrap2("(\n", indent2(join2(args, "\n")), "\n)");
      }
      return join2([argsLine, join2(directives12, " "), selectionSet], " ");
    }
  },
  Argument: { leave: ({ name, value }) => name + ": " + value },
  FragmentSpread: {
    leave: ({ name, directives: directives12 }) => "..." + name + wrap2(" ", join2(directives12, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives: directives12, selectionSet }) => join2(["...", wrap2("on ", typeCondition), join2(directives12, " "), selectionSet], " ")
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives: directives12, selectionSet }) => `fragment ${name}${wrap2("(", join2(variableDefinitions, ", "), ")")} ` + `on ${typeCondition} ${wrap2("", join2(directives12, " "), " ")}` + selectionSet
  },
  IntValue: { leave: ({ value }) => value },
  FloatValue: { leave: ({ value }) => value },
  StringValue: {
    leave: ({ value, block: isBlockString }) => {
      if (isBlockString) {
        return printBlockString2(value);
      }
      return JSON.stringify(value);
    }
  },
  BooleanValue: { leave: ({ value }) => value ? "true" : "false" },
  NullValue: { leave: () => "null" },
  EnumValue: { leave: ({ value }) => value },
  ListValue: { leave: ({ values: values3 }) => "[" + join2(values3, ", ") + "]" },
  ObjectValue: { leave: ({ fields }) => "{" + join2(fields, ", ") + "}" },
  ObjectField: { leave: ({ name, value }) => name + ": " + value },
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap2("(", join2(args, ", "), ")")
  },
  NamedType: { leave: ({ name }) => name },
  ListType: { leave: ({ type }) => "[" + type + "]" },
  NonNullType: { leave: ({ type }) => type + "!" },
  SchemaDefinition: {
    leave: ({ directives: directives12, operationTypes }) => join2(["schema", join2(directives12, " "), block2(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type }) => operation + ": " + type
  },
  ScalarTypeDefinition: {
    leave: ({ name, directives: directives12 }) => join2(["scalar", name, join2(directives12, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ name, interfaces, directives: directives12, fields }) => join2([
      "type",
      name,
      wrap2("implements ", join2(interfaces, " & ")),
      join2(directives12, " "),
      block2(fields)
    ], " ")
  },
  FieldDefinition: {
    leave: ({ name, arguments: args, type, directives: directives12 }) => name + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join2(args, "\n")), "\n)") : wrap2("(", join2(args, ", "), ")")) + ": " + type + wrap2(" ", join2(directives12, " "))
  },
  InputValueDefinition: {
    leave: ({ name, type, defaultValue, directives: directives12 }) => join2([name + ": " + type, wrap2("= ", defaultValue), join2(directives12, " ")], " ")
  },
  InterfaceTypeDefinition: {
    leave: ({ name, interfaces, directives: directives12, fields }) => join2([
      "interface",
      name,
      wrap2("implements ", join2(interfaces, " & ")),
      join2(directives12, " "),
      block2(fields)
    ], " ")
  },
  UnionTypeDefinition: {
    leave: ({ name, directives: directives12, types }) => join2(["union", name, join2(directives12, " "), wrap2("= ", join2(types, " | "))], " ")
  },
  EnumTypeDefinition: {
    leave: ({ name, directives: directives12, values: values3 }) => join2(["enum", name, join2(directives12, " "), block2(values3)], " ")
  },
  EnumValueDefinition: {
    leave: ({ name, directives: directives12 }) => join2([name, join2(directives12, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ name, directives: directives12, fields }) => join2(["input", name, join2(directives12, " "), block2(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ name, arguments: args, repeatable, locations }) => "directive @" + name + (hasMultilineItems2(args) ? wrap2("(\n", indent2(join2(args, "\n")), "\n)") : wrap2("(", join2(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join2(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: directives12, operationTypes }) => join2(["extend schema", join2(directives12, " "), block2(operationTypes)], " ")
  },
  ScalarTypeExtension: {
    leave: ({ name, directives: directives12 }) => join2(["extend scalar", name, join2(directives12, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives: directives12, fields }) => join2([
      "extend type",
      name,
      wrap2("implements ", join2(interfaces, " & ")),
      join2(directives12, " "),
      block2(fields)
    ], " ")
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives: directives12, fields }) => join2([
      "extend interface",
      name,
      wrap2("implements ", join2(interfaces, " & ")),
      join2(directives12, " "),
      block2(fields)
    ], " ")
  },
  UnionTypeExtension: {
    leave: ({ name, directives: directives12, types }) => join2(["extend union", name, join2(directives12, " "), wrap2("= ", join2(types, " | "))], " ")
  },
  EnumTypeExtension: {
    leave: ({ name, directives: directives12, values: values3 }) => join2(["extend enum", name, join2(directives12, " "), block2(values3)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives: directives12, fields }) => join2(["extend input", name, join2(directives12, " "), block2(fields)], " ")
  }
};
var printDocASTReducerWithComments = Object.keys(printDocASTReducer2).reduce((prev, key) => ({
  ...prev,
  [key]: {
    leave: addDescription(printDocASTReducer2[key].leave)
  }
}), {});
// ../../node_modules/@graphql-tools/utils/esm/Interfaces.js
var MapperKind;
(function(MapperKind2) {
  MapperKind2["TYPE"] = "MapperKind.TYPE";
  MapperKind2["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
  MapperKind2["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
  MapperKind2["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
  MapperKind2["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
  MapperKind2["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
  MapperKind2["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
  MapperKind2["UNION_TYPE"] = "MapperKind.UNION_TYPE";
  MapperKind2["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
  MapperKind2["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
  MapperKind2["QUERY"] = "MapperKind.QUERY";
  MapperKind2["MUTATION"] = "MapperKind.MUTATION";
  MapperKind2["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
  MapperKind2["DIRECTIVE"] = "MapperKind.DIRECTIVE";
  MapperKind2["FIELD"] = "MapperKind.FIELD";
  MapperKind2["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
  MapperKind2["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
  MapperKind2["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
  MapperKind2["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
  MapperKind2["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
  MapperKind2["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
  MapperKind2["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
  MapperKind2["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
  MapperKind2["ARGUMENT"] = "MapperKind.ARGUMENT";
  MapperKind2["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
})(MapperKind || (MapperKind = {}));

// ../../node_modules/@graphql-tools/utils/esm/getObjectTypeFromTypeMap.js
function getObjectTypeFromTypeMap(typeMap, type) {
  if (type) {
    const maybeObjectType = typeMap[type.name];
    if (isObjectType(maybeObjectType)) {
      return maybeObjectType;
    }
  }
}

// ../../node_modules/@graphql-tools/utils/esm/stub.js
function isNamedStub(type) {
  if ("getFields" in type) {
    const fields = type.getFields();
    for (const fieldName in fields) {
      const field = fields[fieldName];
      return field.name === "_fake";
    }
  }
  return false;
}
function getBuiltInForStub(type) {
  switch (type.name) {
    case GraphQLInt.name:
      return GraphQLInt;
    case GraphQLFloat.name:
      return GraphQLFloat;
    case GraphQLString.name:
      return GraphQLString;
    case GraphQLBoolean.name:
      return GraphQLBoolean;
    case GraphQLID.name:
      return GraphQLID;
    default:
      return type;
  }
}

// ../../node_modules/@graphql-tools/utils/esm/rewire.js
function rewireTypes(originalTypeMap, directives12) {
  const referenceTypeMap = Object.create(null);
  for (const typeName in originalTypeMap) {
    referenceTypeMap[typeName] = originalTypeMap[typeName];
  }
  const newTypeMap = Object.create(null);
  for (const typeName in referenceTypeMap) {
    const namedType = referenceTypeMap[typeName];
    if (namedType == null || typeName.startsWith("__")) {
      continue;
    }
    const newName = namedType.name;
    if (newName.startsWith("__")) {
      continue;
    }
    if (newTypeMap[newName] != null) {
      console.warn(`Duplicate schema type name ${newName} found; keeping the existing one found in the schema`);
      continue;
    }
    newTypeMap[newName] = namedType;
  }
  for (const typeName in newTypeMap) {
    newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
  }
  const newDirectives = directives12.map((directive) => rewireDirective(directive));
  return {
    typeMap: newTypeMap,
    directives: newDirectives
  };
  function rewireDirective(directive) {
    if (isSpecifiedDirective(directive)) {
      return directive;
    }
    const directiveConfig = directive.toConfig();
    directiveConfig.args = rewireArgs(directiveConfig.args);
    return new GraphQLDirective(directiveConfig);
  }
  function rewireArgs(args) {
    const rewiredArgs = {};
    for (const argName in args) {
      const arg = args[argName];
      const rewiredArgType = rewireType(arg.type);
      if (rewiredArgType != null) {
        arg.type = rewiredArgType;
        rewiredArgs[argName] = arg;
      }
    }
    return rewiredArgs;
  }
  function rewireNamedType(type) {
    if (isObjectType(type)) {
      const config = type.toConfig();
      const newConfig = {
        ...config,
        fields: () => rewireFields(config.fields),
        interfaces: () => rewireNamedTypes(config.interfaces)
      };
      return new GraphQLObjectType(newConfig);
    } else if (isInterfaceType(type)) {
      const config = type.toConfig();
      const newConfig = {
        ...config,
        fields: () => rewireFields(config.fields)
      };
      if ("interfaces" in newConfig) {
        newConfig.interfaces = () => rewireNamedTypes(config.interfaces);
      }
      return new GraphQLInterfaceType(newConfig);
    } else if (isUnionType(type)) {
      const config = type.toConfig();
      const newConfig = {
        ...config,
        types: () => rewireNamedTypes(config.types)
      };
      return new GraphQLUnionType(newConfig);
    } else if (isInputObjectType(type)) {
      const config = type.toConfig();
      const newConfig = {
        ...config,
        fields: () => rewireInputFields(config.fields)
      };
      return new GraphQLInputObjectType(newConfig);
    } else if (isEnumType(type)) {
      const enumConfig = type.toConfig();
      return new GraphQLEnumType(enumConfig);
    } else if (isScalarType(type)) {
      if (isSpecifiedScalarType(type)) {
        return type;
      }
      const scalarConfig = type.toConfig();
      return new GraphQLScalarType(scalarConfig);
    }
    throw new Error(`Unexpected schema type: ${type}`);
  }
  function rewireFields(fields) {
    const rewiredFields = {};
    for (const fieldName in fields) {
      const field = fields[fieldName];
      const rewiredFieldType = rewireType(field.type);
      if (rewiredFieldType != null && field.args) {
        field.type = rewiredFieldType;
        field.args = rewireArgs(field.args);
        rewiredFields[fieldName] = field;
      }
    }
    return rewiredFields;
  }
  function rewireInputFields(fields) {
    const rewiredFields = {};
    for (const fieldName in fields) {
      const field = fields[fieldName];
      const rewiredFieldType = rewireType(field.type);
      if (rewiredFieldType != null) {
        field.type = rewiredFieldType;
        rewiredFields[fieldName] = field;
      }
    }
    return rewiredFields;
  }
  function rewireNamedTypes(namedTypes) {
    const rewiredTypes = [];
    for (const namedType of namedTypes) {
      const rewiredType = rewireType(namedType);
      if (rewiredType != null) {
        rewiredTypes.push(rewiredType);
      }
    }
    return rewiredTypes;
  }
  function rewireType(type) {
    if (isListType(type)) {
      const rewiredType = rewireType(type.ofType);
      return rewiredType != null ? new GraphQLList(rewiredType) : null;
    } else if (isNonNullType(type)) {
      const rewiredType = rewireType(type.ofType);
      return rewiredType != null ? new GraphQLNonNull(rewiredType) : null;
    } else if (isNamedType(type)) {
      let rewiredType = referenceTypeMap[type.name];
      if (rewiredType === undefined) {
        rewiredType = isNamedStub(type) ? getBuiltInForStub(type) : rewireNamedType(type);
        newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;
      }
      return rewiredType != null ? newTypeMap[rewiredType.name] : null;
    }
    return null;
  }
}

// ../../node_modules/@graphql-tools/utils/esm/transformInputValue.js
function transformInputValue(type, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
  if (value == null) {
    return value;
  }
  const nullableType = getNullableType(type);
  if (isLeafType(nullableType)) {
    return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;
  } else if (isListType(nullableType)) {
    return asArray(value).map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
  } else if (isInputObjectType(nullableType)) {
    const fields = nullableType.getFields();
    const newValue = {};
    for (const key in value) {
      const field = fields[key];
      if (field != null) {
        newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);
      }
    }
    return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
  }
}
function serializeInputValue(type, value) {
  return transformInputValue(type, value, (t, v) => {
    try {
      return t.serialize(v);
    } catch {
      return v;
    }
  });
}
function parseInputValue(type, value) {
  return transformInputValue(type, value, (t, v) => {
    try {
      return t.parseValue(v);
    } catch {
      return v;
    }
  });
}

// ../../node_modules/@graphql-tools/utils/esm/mapSchema.js
function mapSchema(schema5, schemaMapper = {}) {
  const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema5.getTypeMap(), schema5, serializeInputValue), schema5, schemaMapper, (type) => isLeafType(type)), schema5, schemaMapper), schema5, parseInputValue), schema5, schemaMapper, (type) => !isLeafType(type)), schema5, schemaMapper), schema5, schemaMapper);
  const originalDirectives = schema5.getDirectives();
  const newDirectives = mapDirectives(originalDirectives, schema5, schemaMapper);
  const { typeMap, directives: directives12 } = rewireTypes(newTypeMap, newDirectives);
  return new GraphQLSchema({
    ...schema5.toConfig(),
    query: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema5.getQueryType())),
    mutation: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema5.getMutationType())),
    subscription: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema5.getSubscriptionType())),
    types: Object.values(typeMap),
    directives: directives12
  });
}
var mapTypes = function(originalTypeMap, schema5, schemaMapper, testFn = () => true) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (originalType == null || !testFn(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const typeMapper = getTypeMapper(schema5, schemaMapper, typeName);
      if (typeMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const maybeNewType = typeMapper(originalType, schema5);
      if (maybeNewType === undefined) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      newTypeMap[typeName] = maybeNewType;
    }
  }
  return newTypeMap;
};
var mapEnumValues = function(originalTypeMap, schema5, schemaMapper) {
  const enumValueMapper = getEnumValueMapper(schemaMapper);
  if (!enumValueMapper) {
    return originalTypeMap;
  }
  return mapTypes(originalTypeMap, schema5, {
    [MapperKind.ENUM_TYPE]: (type) => {
      const config = type.toConfig();
      const originalEnumValueConfigMap = config.values;
      const newEnumValueConfigMap = {};
      for (const externalValue in originalEnumValueConfigMap) {
        const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
        const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema5, externalValue);
        if (mappedEnumValue === undefined) {
          newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
        } else if (Array.isArray(mappedEnumValue)) {
          const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
          newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === undefined ? originalEnumValueConfig : newEnumValueConfig;
        } else if (mappedEnumValue !== null) {
          newEnumValueConfigMap[externalValue] = mappedEnumValue;
        }
      }
      return correctASTNodes(new GraphQLEnumType({
        ...config,
        values: newEnumValueConfigMap
      }));
    }
  }, (type) => isEnumType(type));
};
var mapDefaultValues = function(originalTypeMap, schema5, fn) {
  const newTypeMap = mapArguments(originalTypeMap, schema5, {
    [MapperKind.ARGUMENT]: (argumentConfig) => {
      if (argumentConfig.defaultValue === undefined) {
        return argumentConfig;
      }
      const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);
      if (maybeNewType != null) {
        return {
          ...argumentConfig,
          defaultValue: fn(maybeNewType, argumentConfig.defaultValue)
        };
      }
    }
  });
  return mapFields(newTypeMap, schema5, {
    [MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {
      if (inputFieldConfig.defaultValue === undefined) {
        return inputFieldConfig;
      }
      const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);
      if (maybeNewType != null) {
        return {
          ...inputFieldConfig,
          defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)
        };
      }
    }
  });
};
var getNewType = function(newTypeMap, type) {
  if (isListType(type)) {
    const newType = getNewType(newTypeMap, type.ofType);
    return newType != null ? new GraphQLList(newType) : null;
  } else if (isNonNullType(type)) {
    const newType = getNewType(newTypeMap, type.ofType);
    return newType != null ? new GraphQLNonNull(newType) : null;
  } else if (isNamedType(type)) {
    const newType = newTypeMap[type.name];
    return newType != null ? newType : null;
  }
  return null;
};
var mapFields = function(originalTypeMap, schema5, schemaMapper) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (!isObjectType(originalType) && !isInterfaceType(originalType) && !isInputObjectType(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const fieldMapper = getFieldMapper(schema5, schemaMapper, typeName);
      if (fieldMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const config = originalType.toConfig();
      const originalFieldConfigMap = config.fields;
      const newFieldConfigMap = {};
      for (const fieldName in originalFieldConfigMap) {
        const originalFieldConfig = originalFieldConfigMap[fieldName];
        const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema5);
        if (mappedField === undefined) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
        } else if (Array.isArray(mappedField)) {
          const [newFieldName, newFieldConfig] = mappedField;
          if (newFieldConfig.astNode != null) {
            newFieldConfig.astNode = {
              ...newFieldConfig.astNode,
              name: {
                ...newFieldConfig.astNode.name,
                value: newFieldName
              }
            };
          }
          newFieldConfigMap[newFieldName] = newFieldConfig === undefined ? originalFieldConfig : newFieldConfig;
        } else if (mappedField !== null) {
          newFieldConfigMap[fieldName] = mappedField;
        }
      }
      if (isObjectType(originalType)) {
        newTypeMap[typeName] = correctASTNodes(new GraphQLObjectType({
          ...config,
          fields: newFieldConfigMap
        }));
      } else if (isInterfaceType(originalType)) {
        newTypeMap[typeName] = correctASTNodes(new GraphQLInterfaceType({
          ...config,
          fields: newFieldConfigMap
        }));
      } else {
        newTypeMap[typeName] = correctASTNodes(new GraphQLInputObjectType({
          ...config,
          fields: newFieldConfigMap
        }));
      }
    }
  }
  return newTypeMap;
};
var mapArguments = function(originalTypeMap, schema5, schemaMapper) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (!isObjectType(originalType) && !isInterfaceType(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const argumentMapper = getArgumentMapper(schemaMapper);
      if (argumentMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const config = originalType.toConfig();
      const originalFieldConfigMap = config.fields;
      const newFieldConfigMap = {};
      for (const fieldName in originalFieldConfigMap) {
        const originalFieldConfig = originalFieldConfigMap[fieldName];
        const originalArgumentConfigMap = originalFieldConfig.args;
        if (originalArgumentConfigMap == null) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
          continue;
        }
        const argumentNames = Object.keys(originalArgumentConfigMap);
        if (!argumentNames.length) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
          continue;
        }
        const newArgumentConfigMap = {};
        for (const argumentName of argumentNames) {
          const originalArgumentConfig = originalArgumentConfigMap[argumentName];
          const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema5);
          if (mappedArgument === undefined) {
            newArgumentConfigMap[argumentName] = originalArgumentConfig;
          } else if (Array.isArray(mappedArgument)) {
            const [newArgumentName, newArgumentConfig] = mappedArgument;
            newArgumentConfigMap[newArgumentName] = newArgumentConfig;
          } else if (mappedArgument !== null) {
            newArgumentConfigMap[argumentName] = mappedArgument;
          }
        }
        newFieldConfigMap[fieldName] = {
          ...originalFieldConfig,
          args: newArgumentConfigMap
        };
      }
      if (isObjectType(originalType)) {
        newTypeMap[typeName] = new GraphQLObjectType({
          ...config,
          fields: newFieldConfigMap
        });
      } else if (isInterfaceType(originalType)) {
        newTypeMap[typeName] = new GraphQLInterfaceType({
          ...config,
          fields: newFieldConfigMap
        });
      } else {
        newTypeMap[typeName] = new GraphQLInputObjectType({
          ...config,
          fields: newFieldConfigMap
        });
      }
    }
  }
  return newTypeMap;
};
var mapDirectives = function(originalDirectives, schema5, schemaMapper) {
  const directiveMapper = getDirectiveMapper(schemaMapper);
  if (directiveMapper == null) {
    return originalDirectives.slice();
  }
  const newDirectives = [];
  for (const directive of originalDirectives) {
    const mappedDirective = directiveMapper(directive, schema5);
    if (mappedDirective === undefined) {
      newDirectives.push(directive);
    } else if (mappedDirective !== null) {
      newDirectives.push(mappedDirective);
    }
  }
  return newDirectives;
};
var getTypeSpecifiers = function(schema5, typeName) {
  const type = schema5.getType(typeName);
  const specifiers = [MapperKind.TYPE];
  if (isObjectType(type)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);
    if (typeName === schema5.getQueryType()?.name) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);
    } else if (typeName === schema5.getMutationType()?.name) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);
    } else if (typeName === schema5.getSubscriptionType()?.name) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);
    }
  } else if (isInputObjectType(type)) {
    specifiers.push(MapperKind.INPUT_OBJECT_TYPE);
  } else if (isInterfaceType(type)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);
  } else if (isUnionType(type)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);
  } else if (isEnumType(type)) {
    specifiers.push(MapperKind.ENUM_TYPE);
  } else if (isScalarType(type)) {
    specifiers.push(MapperKind.SCALAR_TYPE);
  }
  return specifiers;
};
var getTypeMapper = function(schema5, schemaMapper, typeName) {
  const specifiers = getTypeSpecifiers(schema5, typeName);
  let typeMapper;
  const stack = [...specifiers];
  while (!typeMapper && stack.length > 0) {
    const next = stack.pop();
    typeMapper = schemaMapper[next];
  }
  return typeMapper != null ? typeMapper : null;
};
var getFieldSpecifiers = function(schema5, typeName) {
  const type = schema5.getType(typeName);
  const specifiers = [MapperKind.FIELD];
  if (isObjectType(type)) {
    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.OBJECT_FIELD);
    if (typeName === schema5.getQueryType()?.name) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.QUERY_ROOT_FIELD);
    } else if (typeName === schema5.getMutationType()?.name) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.MUTATION_ROOT_FIELD);
    } else if (typeName === schema5.getSubscriptionType()?.name) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.SUBSCRIPTION_ROOT_FIELD);
    }
  } else if (isInterfaceType(type)) {
    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.INTERFACE_FIELD);
  } else if (isInputObjectType(type)) {
    specifiers.push(MapperKind.INPUT_OBJECT_FIELD);
  }
  return specifiers;
};
var getFieldMapper = function(schema5, schemaMapper, typeName) {
  const specifiers = getFieldSpecifiers(schema5, typeName);
  let fieldMapper;
  const stack = [...specifiers];
  while (!fieldMapper && stack.length > 0) {
    const next = stack.pop();
    fieldMapper = schemaMapper[next];
  }
  return fieldMapper ?? null;
};
var getArgumentMapper = function(schemaMapper) {
  const argumentMapper = schemaMapper[MapperKind.ARGUMENT];
  return argumentMapper != null ? argumentMapper : null;
};
var getDirectiveMapper = function(schemaMapper) {
  const directiveMapper = schemaMapper[MapperKind.DIRECTIVE];
  return directiveMapper != null ? directiveMapper : null;
};
var getEnumValueMapper = function(schemaMapper) {
  const enumValueMapper = schemaMapper[MapperKind.ENUM_VALUE];
  return enumValueMapper != null ? enumValueMapper : null;
};
function correctASTNodes(type) {
  if (isObjectType(type)) {
    const config = type.toConfig();
    if (config.astNode != null) {
      const fields = [];
      for (const fieldName in config.fields) {
        const fieldConfig = config.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config.astNode = {
        ...config.astNode,
        kind: Kind.OBJECT_TYPE_DEFINITION,
        fields
      };
    }
    if (config.extensionASTNodes != null) {
      config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
        ...node,
        kind: Kind.OBJECT_TYPE_EXTENSION,
        fields: undefined
      }));
    }
    return new GraphQLObjectType(config);
  } else if (isInterfaceType(type)) {
    const config = type.toConfig();
    if (config.astNode != null) {
      const fields = [];
      for (const fieldName in config.fields) {
        const fieldConfig = config.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config.astNode = {
        ...config.astNode,
        kind: Kind.INTERFACE_TYPE_DEFINITION,
        fields
      };
    }
    if (config.extensionASTNodes != null) {
      config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
        ...node,
        kind: Kind.INTERFACE_TYPE_EXTENSION,
        fields: undefined
      }));
    }
    return new GraphQLInterfaceType(config);
  } else if (isInputObjectType(type)) {
    const config = type.toConfig();
    if (config.astNode != null) {
      const fields = [];
      for (const fieldName in config.fields) {
        const fieldConfig = config.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config.astNode = {
        ...config.astNode,
        kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
        fields
      };
    }
    if (config.extensionASTNodes != null) {
      config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
        ...node,
        kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
        fields: undefined
      }));
    }
    return new GraphQLInputObjectType(config);
  } else if (isEnumType(type)) {
    const config = type.toConfig();
    if (config.astNode != null) {
      const values3 = [];
      for (const enumKey in config.values) {
        const enumValueConfig = config.values[enumKey];
        if (enumValueConfig.astNode != null) {
          values3.push(enumValueConfig.astNode);
        }
      }
      config.astNode = {
        ...config.astNode,
        values: values3
      };
    }
    if (config.extensionASTNodes != null) {
      config.extensionASTNodes = config.extensionASTNodes.map((node) => ({
        ...node,
        values: undefined
      }));
    }
    return new GraphQLEnumType(config);
  } else {
    return type;
  }
}
// ../../node_modules/@graphql-tools/utils/esm/heal.js
function healSchema(schema5) {
  healTypes(schema5.getTypeMap(), schema5.getDirectives());
  return schema5;
}
function healTypes(originalTypeMap, directives12) {
  const actualNamedTypeMap = Object.create(null);
  for (const typeName in originalTypeMap) {
    const namedType = originalTypeMap[typeName];
    if (namedType == null || typeName.startsWith("__")) {
      continue;
    }
    const actualName = namedType.name;
    if (actualName.startsWith("__")) {
      continue;
    }
    if (actualNamedTypeMap[actualName] != null) {
      console.warn(`Duplicate schema type name ${actualName} found; keeping the existing one found in the schema`);
      continue;
    }
    actualNamedTypeMap[actualName] = namedType;
  }
  for (const typeName in actualNamedTypeMap) {
    const namedType = actualNamedTypeMap[typeName];
    originalTypeMap[typeName] = namedType;
  }
  for (const decl of directives12) {
    decl.args = decl.args.filter((arg) => {
      arg.type = healType(arg.type);
      return arg.type !== null;
    });
  }
  for (const typeName in originalTypeMap) {
    const namedType = originalTypeMap[typeName];
    if (!typeName.startsWith("__") && typeName in actualNamedTypeMap) {
      if (namedType != null) {
        healNamedType(namedType);
      }
    }
  }
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__") && !(typeName in actualNamedTypeMap)) {
      delete originalTypeMap[typeName];
    }
  }
  function healNamedType(type) {
    if (isObjectType(type)) {
      healFields(type);
      healInterfaces(type);
      return;
    } else if (isInterfaceType(type)) {
      healFields(type);
      if ("getInterfaces" in type) {
        healInterfaces(type);
      }
      return;
    } else if (isUnionType(type)) {
      healUnderlyingTypes(type);
      return;
    } else if (isInputObjectType(type)) {
      healInputFields(type);
      return;
    } else if (isLeafType(type)) {
      return;
    }
    throw new Error(`Unexpected schema type: ${type}`);
  }
  function healFields(type) {
    const fieldMap = type.getFields();
    for (const [key, field] of Object.entries(fieldMap)) {
      field.args.map((arg) => {
        arg.type = healType(arg.type);
        return arg.type === null ? null : arg;
      }).filter(Boolean);
      field.type = healType(field.type);
      if (field.type === null) {
        delete fieldMap[key];
      }
    }
  }
  function healInterfaces(type) {
    if ("getInterfaces" in type) {
      const interfaces = type.getInterfaces();
      interfaces.push(...interfaces.splice(0).map((iface) => healType(iface)).filter(Boolean));
    }
  }
  function healInputFields(type) {
    const fieldMap = type.getFields();
    for (const [key, field] of Object.entries(fieldMap)) {
      field.type = healType(field.type);
      if (field.type === null) {
        delete fieldMap[key];
      }
    }
  }
  function healUnderlyingTypes(type) {
    const types = type.getTypes();
    types.push(...types.splice(0).map((t) => healType(t)).filter(Boolean));
  }
  function healType(type) {
    if (isListType(type)) {
      const healedType = healType(type.ofType);
      return healedType != null ? new GraphQLList(healedType) : null;
    } else if (isNonNullType(type)) {
      const healedType = healType(type.ofType);
      return healedType != null ? new GraphQLNonNull(healedType) : null;
    } else if (isNamedType(type)) {
      const officialType = originalTypeMap[type.name];
      if (officialType && type !== officialType) {
        return officialType;
      }
    }
    return type;
  }
}
// ../../node_modules/@graphql-tools/utils/esm/getResolversFromSchema.js
function getResolversFromSchema(schema5, includeDefaultMergedResolver) {
  const resolvers = Object.create(null);
  const typeMap = schema5.getTypeMap();
  for (const typeName in typeMap) {
    if (!typeName.startsWith("__")) {
      const type = typeMap[typeName];
      if (isScalarType(type)) {
        if (!isSpecifiedScalarType(type)) {
          const config = type.toConfig();
          delete config.astNode;
          resolvers[typeName] = new GraphQLScalarType(config);
        }
      } else if (isEnumType(type)) {
        resolvers[typeName] = {};
        const values3 = type.getValues();
        for (const value of values3) {
          resolvers[typeName][value.name] = value.value;
        }
      } else if (isInterfaceType(type)) {
        if (type.resolveType != null) {
          resolvers[typeName] = {
            __resolveType: type.resolveType
          };
        }
      } else if (isUnionType(type)) {
        if (type.resolveType != null) {
          resolvers[typeName] = {
            __resolveType: type.resolveType
          };
        }
      } else if (isObjectType(type)) {
        resolvers[typeName] = {};
        if (type.isTypeOf != null) {
          resolvers[typeName].__isTypeOf = type.isTypeOf;
        }
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          if (field.subscribe != null) {
            resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
            resolvers[typeName][fieldName].subscribe = field.subscribe;
          }
          if (field.resolve != null && field.resolve?.name !== "defaultFieldResolver") {
            switch (field.resolve?.name) {
              case "defaultMergedResolver":
                if (!includeDefaultMergedResolver) {
                  continue;
                }
                break;
              case "defaultFieldResolver":
                continue;
            }
            resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {};
            resolvers[typeName][fieldName].resolve = field.resolve;
          }
        }
      }
    }
  }
  return resolvers;
}
// ../../node_modules/@graphql-tools/utils/esm/forEachField.js
function forEachField(schema5, fn) {
  const typeMap = schema5.getTypeMap();
  for (const typeName in typeMap) {
    const type = typeMap[typeName];
    if (!getNamedType(type).name.startsWith("__") && isObjectType(type)) {
      const fields = type.getFields();
      for (const fieldName in fields) {
        const field = fields[fieldName];
        fn(field, typeName, fieldName);
      }
    }
  }
}
// ../../node_modules/@graphql-tools/utils/esm/forEachDefaultValue.js
function forEachDefaultValue(schema5, fn) {
  const typeMap = schema5.getTypeMap();
  for (const typeName in typeMap) {
    const type = typeMap[typeName];
    if (!getNamedType(type).name.startsWith("__")) {
      if (isObjectType(type)) {
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          for (const arg of field.args) {
            arg.defaultValue = fn(arg.type, arg.defaultValue);
          }
        }
      } else if (isInputObjectType(type)) {
        const fields = type.getFields();
        for (const fieldName in fields) {
          const field = fields[fieldName];
          field.defaultValue = fn(field.type, field.defaultValue);
        }
      }
    }
  }
}
// ../../node_modules/@graphql-tools/utils/esm/mergeDeep.js
function mergeDeep(sources, respectPrototype = false, respectArrays = false, respectArrayLength = false) {
  if (respectArrays && respectArrayLength) {
    let expectedLength;
    const areArraysInTheSameLength = sources.every((source2) => {
      if (Array.isArray(source2)) {
        if (expectedLength === undefined) {
          expectedLength = source2.length;
          return true;
        } else if (expectedLength === source2.length) {
          return true;
        }
      }
      return false;
    });
    if (areArraysInTheSameLength) {
      return new Array(expectedLength).fill(null).map((_, index) => mergeDeep(sources.map((source2) => source2[index]), respectPrototype, respectArrays, respectArrayLength));
    }
  }
  const output = {};
  if (respectPrototype) {
    Object.setPrototypeOf(output, Object.create(Object.getPrototypeOf(sources[0])));
  }
  for (const source2 of sources) {
    if (isObject(source2)) {
      if (respectPrototype) {
        const outputPrototype = Object.getPrototypeOf(output);
        const sourcePrototype = Object.getPrototypeOf(source2);
        if (sourcePrototype) {
          for (const key of Object.getOwnPropertyNames(sourcePrototype)) {
            const descriptor = Object.getOwnPropertyDescriptor(sourcePrototype, key);
            if (isSome(descriptor)) {
              Object.defineProperty(outputPrototype, key, descriptor);
            }
          }
        }
      }
      for (const key in source2) {
        if (isObject(source2[key])) {
          if (!(key in output)) {
            Object.assign(output, { [key]: source2[key] });
          } else {
            output[key] = mergeDeep([output[key], source2[key]], respectPrototype, respectArrays, respectArrayLength);
          }
        } else if (respectArrays && Array.isArray(output[key])) {
          if (Array.isArray(source2[key])) {
            if (respectArrayLength && output[key].length === source2[key].length) {
              output[key] = mergeDeep([output[key], source2[key]], respectPrototype, respectArrays, respectArrayLength);
            } else {
              output[key].push(...source2[key]);
            }
          } else {
            output[key].push(source2[key]);
          }
        } else {
          Object.assign(output, { [key]: source2[key] });
        }
      }
    }
  }
  return output;
}
var isObject = function(item) {
  return item && typeof item === "object" && !Array.isArray(item);
};
// ../../node_modules/@graphql-tools/utils/esm/mapAsyncIterator.js
function mapAsyncIterator(iterator, onNext, onError, onEnd) {
  if (Symbol.asyncIterator in iterator) {
    iterator = iterator[Symbol.asyncIterator]();
  }
  let $return;
  let abruptClose;
  let onEndWithValue;
  if (onEnd) {
    onEndWithValue = (value) => {
      const onEnd$ = onEnd();
      return isPromise3(onEnd$) ? onEnd$.then(() => value) : value;
    };
  }
  if (typeof iterator.return === "function") {
    $return = iterator.return;
    abruptClose = (error) => {
      const rethrow = () => Promise.reject(error);
      return $return.call(iterator).then(rethrow, rethrow);
    };
  }
  function mapResult(result) {
    if (result.done) {
      return onEndWithValue ? onEndWithValue(result) : result;
    }
    return asyncMapValue(result.value, onNext).then(iteratorResult, abruptClose);
  }
  let mapReject;
  if (onError) {
    const reject = onError;
    mapReject = (error) => asyncMapValue(error, reject).then(iteratorResult, abruptClose);
  }
  return {
    next() {
      return iterator.next().then(mapResult, mapReject);
    },
    return() {
      const res$ = $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({ value: undefined, done: true });
      return onEndWithValue ? res$.then(onEndWithValue) : res$;
    },
    throw(error) {
      if (typeof iterator.throw === "function") {
        return iterator.throw(error).then(mapResult, mapReject);
      }
      return Promise.reject(error).catch(abruptClose);
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
var asyncMapValue = function(value, callback) {
  return new Promise((resolve) => resolve(callback(value)));
};
var iteratorResult = function(value) {
  return { value, done: false };
};
// ../../node_modules/@graphql-tools/utils/esm/AccumulatorMap.js
class AccumulatorMap extends Map {
  get [Symbol.toStringTag]() {
    return "AccumulatorMap";
  }
  add(key, item) {
    const group = this.get(key);
    if (group === undefined) {
      this.set(key, [item]);
    } else {
      group.push(item);
    }
  }
}

// ../../node_modules/@graphql-tools/utils/esm/directives.js
var GraphQLDeferDirective = new GraphQLDirective({
  name: "defer",
  description: "Directs the executor to defer this fragment when the `if` argument is true or undefined.",
  locations: [DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Deferred when true or undefined.",
      defaultValue: true
    },
    label: {
      type: GraphQLString,
      description: "Unique name"
    }
  }
});
var GraphQLStreamDirective = new GraphQLDirective({
  name: "stream",
  description: "Directs the executor to stream plural fields when the `if` argument is true or undefined.",
  locations: [DirectiveLocation.FIELD],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Stream when true or undefined.",
      defaultValue: true
    },
    label: {
      type: GraphQLString,
      description: "Unique name"
    },
    initialCount: {
      defaultValue: 0,
      type: GraphQLInt,
      description: "Number of items to return immediately"
    }
  }
});

// ../../node_modules/@graphql-tools/utils/esm/collectFields.js
var collectFieldsImpl2 = function(schema5, fragments, variableValues, runtimeType, selectionSet, fields, patches, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode2(variableValues, selection)) {
          continue;
        }
        fields.add(getFieldEntryKey2(selection), selection);
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode2(variableValues, selection) || !doesFragmentConditionMatch2(schema5, selection, runtimeType)) {
          continue;
        }
        const defer = getDeferValues(variableValues, selection);
        if (defer) {
          const patchFields = new AccumulatorMap;
          collectFieldsImpl2(schema5, fragments, variableValues, runtimeType, selection.selectionSet, patchFields, patches, visitedFragmentNames);
          patches.push({
            label: defer.label,
            fields: patchFields
          });
        } else {
          collectFieldsImpl2(schema5, fragments, variableValues, runtimeType, selection.selectionSet, fields, patches, visitedFragmentNames);
        }
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (!shouldIncludeNode2(variableValues, selection)) {
          continue;
        }
        const defer = getDeferValues(variableValues, selection);
        if (visitedFragmentNames.has(fragName) && !defer) {
          continue;
        }
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch2(schema5, fragment, runtimeType)) {
          continue;
        }
        if (!defer) {
          visitedFragmentNames.add(fragName);
        }
        if (defer) {
          const patchFields = new AccumulatorMap;
          collectFieldsImpl2(schema5, fragments, variableValues, runtimeType, fragment.selectionSet, patchFields, patches, visitedFragmentNames);
          patches.push({
            label: defer.label,
            fields: patchFields
          });
        } else {
          collectFieldsImpl2(schema5, fragments, variableValues, runtimeType, fragment.selectionSet, fields, patches, visitedFragmentNames);
        }
        break;
      }
    }
  }
};
function collectFields4(schema5, fragments, variableValues, runtimeType, selectionSet) {
  const fields = new AccumulatorMap;
  const patches = [];
  collectFieldsImpl2(schema5, fragments, variableValues, runtimeType, selectionSet, fields, patches, new Set);
  return { fields, patches };
}
function shouldIncludeNode2(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if (skip?.["if"] === true) {
    return false;
  }
  const include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);
  if (include?.["if"] === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch2(schema5, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema5, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    const possibleTypes = schema5.getPossibleTypes(conditionalType);
    return possibleTypes.includes(type);
  }
  return false;
}
function getFieldEntryKey2(node) {
  return node.alias ? node.alias.value : node.name.value;
}
function getDeferValues(variableValues, node) {
  const defer = getDirectiveValues(GraphQLDeferDirective, node, variableValues);
  if (!defer) {
    return;
  }
  if (defer["if"] === false) {
    return;
  }
  return {
    label: typeof defer["label"] === "string" ? defer["label"] : undefined
  };
}
var collectSubFields = memoize5(function collectSubfields3(schema5, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = new AccumulatorMap;
  const visitedFragmentNames = new Set;
  const subPatches = [];
  const subFieldsAndPatches = {
    fields: subFieldNodes,
    patches: subPatches
  };
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl2(schema5, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, subPatches, visitedFragmentNames);
    }
  }
  return subFieldsAndPatches;
});
// ../../node_modules/@graphql-tools/utils/esm/isAsyncIterable.js
function isAsyncIterable(value) {
  return value?.[Symbol.asyncIterator] != null;
}
// ../../node_modules/@graphql-tools/utils/esm/isDocumentNode.js
function isDocumentNode(object) {
  return object && typeof object === "object" && "kind" in object && object.kind === Kind.DOCUMENT;
}
// ../../node_modules/@graphql-tools/utils/esm/extractExtensionsFromSchema.js
var handleDirectiveExtensions = function(extensions, removeDirectives) {
  extensions = extensions || {};
  const { directives: existingDirectives, ...rest } = extensions;
  const finalExtensions = {
    ...rest
  };
  if (!removeDirectives) {
    if (existingDirectives != null) {
      const directives13 = {};
      for (const directiveName in existingDirectives) {
        directives13[directiveName] = [...asArray(existingDirectives[directiveName])];
      }
      finalExtensions.directives = directives13;
    }
  }
  return finalExtensions;
};
function extractExtensionsFromSchema(schema5, removeDirectives = false) {
  const result = {
    schemaExtensions: handleDirectiveExtensions(schema5.extensions, removeDirectives),
    types: {}
  };
  mapSchema(schema5, {
    [MapperKind.OBJECT_TYPE]: (type) => {
      result.types[type.name] = {
        fields: {},
        type: "object",
        extensions: handleDirectiveExtensions(type.extensions, removeDirectives)
      };
      return type;
    },
    [MapperKind.INTERFACE_TYPE]: (type) => {
      result.types[type.name] = {
        fields: {},
        type: "interface",
        extensions: handleDirectiveExtensions(type.extensions, removeDirectives)
      };
      return type;
    },
    [MapperKind.FIELD]: (field, fieldName, typeName) => {
      result.types[typeName].fields[fieldName] = {
        arguments: {},
        extensions: handleDirectiveExtensions(field.extensions, removeDirectives)
      };
      const args = field.args;
      if (args != null) {
        for (const argName in args) {
          result.types[typeName].fields[fieldName].arguments[argName] = handleDirectiveExtensions(args[argName].extensions, removeDirectives);
        }
      }
      return field;
    },
    [MapperKind.ENUM_TYPE]: (type) => {
      result.types[type.name] = {
        values: {},
        type: "enum",
        extensions: handleDirectiveExtensions(type.extensions, removeDirectives)
      };
      return type;
    },
    [MapperKind.ENUM_VALUE]: (value, typeName, _schema, valueName) => {
      result.types[typeName].values[valueName] = handleDirectiveExtensions(value.extensions, removeDirectives);
      return value;
    },
    [MapperKind.SCALAR_TYPE]: (type) => {
      result.types[type.name] = {
        type: "scalar",
        extensions: handleDirectiveExtensions(type.extensions, removeDirectives)
      };
      return type;
    },
    [MapperKind.UNION_TYPE]: (type) => {
      result.types[type.name] = {
        type: "union",
        extensions: handleDirectiveExtensions(type.extensions, removeDirectives)
      };
      return type;
    },
    [MapperKind.INPUT_OBJECT_TYPE]: (type) => {
      result.types[type.name] = {
        fields: {},
        type: "input",
        extensions: handleDirectiveExtensions(type.extensions, removeDirectives)
      };
      return type;
    },
    [MapperKind.INPUT_OBJECT_FIELD]: (field, fieldName, typeName) => {
      result.types[typeName].fields[fieldName] = {
        extensions: handleDirectiveExtensions(field.extensions, removeDirectives)
      };
      return field;
    }
  });
  return result;
}
// ../../node_modules/@graphql-tools/utils/esm/Path.js
function addPath2(prev, key, typename) {
  return { prev, key, typename };
}
function pathToArray2(path) {
  const flattened = [];
  let curr = path;
  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }
  return flattened.reverse();
}
function printPathArray3(path) {
  return path.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
}
// ../../node_modules/graphql-yoga/esm/error.js
var isAggregateError = function(obj) {
  return obj != null && typeof obj === "object" && "errors" in obj;
};
var hasToString = function(obj) {
  return obj != null && typeof obj.toString === "function";
};
function isGraphQLError(val) {
  return val instanceof GraphQLError;
}
function isOriginalGraphQLError(val) {
  if (val instanceof GraphQLError) {
    if (val.originalError != null) {
      return isOriginalGraphQLError(val.originalError);
    }
    return true;
  }
  return false;
}
function handleError(error, maskedErrorsOpts, logger) {
  const errors4 = new Set;
  if (isAggregateError(error)) {
    for (const singleError of error.errors) {
      const handledErrors = handleError(singleError, maskedErrorsOpts, logger);
      for (const handledError of handledErrors) {
        errors4.add(handledError);
      }
    }
  } else if (maskedErrorsOpts) {
    const maskedError = maskedErrorsOpts.maskError(error, maskedErrorsOpts.errorMessage, maskedErrorsOpts.isDev);
    if (maskedError !== error) {
      logger.error(error);
    }
    errors4.add(isGraphQLError(maskedError) ? maskedError : createGraphQLError(maskedError.message, {
      originalError: maskedError
    }));
  } else if (isGraphQLError(error)) {
    errors4.add(error);
  } else if (error instanceof Error) {
    errors4.add(createGraphQLError(error.message, {
      originalError: error
    }));
  } else if (typeof error === "string") {
    errors4.add(createGraphQLError(error, {
      extensions: {
        unexpected: true
      }
    }));
  } else if (hasToString(error)) {
    errors4.add(createGraphQLError(error.toString(), {
      extensions: {
        unexpected: true
      }
    }));
  } else {
    logger.error(error);
    errors4.add(createGraphQLError("Unexpected error.", {
      extensions: {
        http: {
          unexpected: true
        }
      }
    }));
  }
  return Array.from(errors4);
}
function getResponseInitByRespectingErrors(result, headers = {}, isApplicationJson = false) {
  let status;
  let unexpectedErrorExists = false;
  if ("extensions" in result && result.extensions?.http) {
    if (result.extensions.http.headers) {
      Object.assign(headers, result.extensions.http.headers);
    }
    if (result.extensions.http.status) {
      status = result.extensions.http.status;
    }
  }
  if ("errors" in result && result.errors?.length) {
    for (const error of result.errors) {
      if (error.extensions?.http) {
        if (error.extensions.http.headers) {
          Object.assign(headers, error.extensions.http.headers);
        }
        if (isApplicationJson && error.extensions.http.spec) {
          continue;
        }
        if (error.extensions.http.status && (!status || error.extensions.http.status > status)) {
          status = error.extensions.http.status;
        }
      } else if (!isOriginalGraphQLError(error) || error.extensions?.unexpected) {
        unexpectedErrorExists = true;
      }
    }
  } else {
    status ||= 200;
  }
  if (!status) {
    if (unexpectedErrorExists && !("data" in result)) {
      status = 500;
    } else {
      status = 200;
    }
  }
  return {
    status,
    headers
  };
}
function areGraphQLErrors(obj) {
  return Array.isArray(obj) && obj.length > 0 && obj.some(isGraphQLError);
}

// ../../node_modules/@graphql-yoga/logger/esm/index.js
var ansiCodes = {
  red: "\x1B[31m",
  yellow: "\x1B[33m",
  magenta: "\x1B[35m",
  cyan: "\x1B[36m",
  reset: "\x1B[0m"
};
var warnPrefix = ansiCodes.yellow + "WARN" + ansiCodes.reset;
var infoPrefix = ansiCodes.cyan + "INFO" + ansiCodes.reset;
var errorPrefix = ansiCodes.red + "ERR" + ansiCodes.reset;
var debugPrefix = ansiCodes.magenta + "DEBUG" + ansiCodes.reset;
var logLevelScores = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
  silent: 4
};
var noop = () => {
};
var consoleLog = (prefix) => (...args) => console.log(prefix, ...args);
var debugLog = console.debug ? (...args) => console.debug(debugPrefix, ...args) : consoleLog(debugPrefix);
var infoLog = console.info ? (...args) => console.info(infoPrefix, ...args) : consoleLog(infoPrefix);
var warnLog = console.warn ? (...args) => console.warn(warnPrefix, ...args) : consoleLog(warnPrefix);
var errorLog = console.error ? (...args) => console.error(errorPrefix, ...args) : consoleLog(errorPrefix);
var createLogger = (logLevel = globalThis.process?.env["DEBUG"] === "1" ? "debug" : "info") => {
  const score = logLevelScores[logLevel];
  return {
    debug: score > logLevelScores.debug ? noop : debugLog,
    info: score > logLevelScores.info ? noop : infoLog,
    warn: score > logLevelScores.warn ? noop : warnLog,
    error: score > logLevelScores.error ? noop : errorLog
  };
};

// ../../node_modules/graphql-yoga/esm/graphiql-html.js
var graphiql_html_default = "<!doctype html><html lang=en><head><meta charset=utf-8><title>__TITLE__</title><link rel=icon href=https://raw.githubusercontent.com/dotansimha/graphql-yoga/main/website/public/favicon.ico><link rel=stylesheet href=https://unpkg.com/@graphql-yoga/graphiql@4.1.1/dist/style.css></head><body id=body class=no-focus-outline><noscript>You need to enable JavaScript to run this app.</noscript><div id=root></div><script type=module>import{renderYogaGraphiQL}from\"https://unpkg.com/@graphql-yoga/graphiql@4.1.1/dist/yoga-graphiql.es.js\";renderYogaGraphiQL(root,__OPTS__)</script></body></html>";

// ../../node_modules/graphql-yoga/esm/plugins/use-graphiql.js
function shouldRenderGraphiQL({ headers, method }) {
  return method === "GET" && !!headers?.get("accept")?.includes("text/html");
}
function useGraphiQL(config) {
  const logger = config.logger ?? console;
  let graphiqlOptionsFactory;
  if (typeof config?.options === "function") {
    graphiqlOptionsFactory = config?.options;
  } else if (typeof config?.options === "object") {
    graphiqlOptionsFactory = () => config?.options;
  } else if (config?.options === false) {
    graphiqlOptionsFactory = () => false;
  } else {
    graphiqlOptionsFactory = () => ({});
  }
  const renderer = config?.render ?? renderGraphiQL;
  let urlPattern;
  const getUrlPattern = ({ URLPattern }) => {
    urlPattern ||= new URLPattern({
      pathname: config.graphqlEndpoint
    });
    return urlPattern;
  };
  return {
    async onRequest({ request, serverContext, fetchAPI, endResponse, url }) {
      if (shouldRenderGraphiQL(request) && (request.url.endsWith(config.graphqlEndpoint) || url.pathname === config.graphqlEndpoint || getUrlPattern(fetchAPI).test(url))) {
        logger.debug(`Rendering GraphiQL`);
        const graphiqlOptions = await graphiqlOptionsFactory(request, serverContext);
        if (graphiqlOptions) {
          const graphiQLBody = await renderer({
            ...graphiqlOptions === true ? {} : graphiqlOptions
          });
          const response = new fetchAPI.Response(graphiQLBody, {
            headers: {
              "Content-Type": "text/html"
            },
            status: 200
          });
          endResponse(response);
        }
      }
    }
  };
}
var renderGraphiQL = (opts) => graphiql_html_default.replace("__TITLE__", opts?.title || "Yoga GraphiQL").replace("__OPTS__", JSON.stringify(opts ?? {}));

// ../../node_modules/graphql-yoga/esm/plugins/use-schema.js
var useSchema = (schemaDef) => {
  if (schemaDef == null) {
    return {};
  }
  if (isSchema(schemaDef)) {
    return {
      onPluginInit({ setSchema }) {
        setSchema(schemaDef);
      }
    };
  }
  if ("then" in schemaDef) {
    let schema5;
    return {
      onRequestParse() {
        return {
          async onRequestParseDone() {
            schema5 ||= await schemaDef;
          }
        };
      },
      onEnveloped({ setSchema }) {
        if (!schema5) {
          throw new Error(`You provide a promise of a schema but it hasn't been resolved yet. Make sure you use this plugin with GraphQL Yoga.`);
        }
        setSchema(schema5);
      }
    };
  }
  const schemaByRequest = new WeakMap;
  return {
    onRequestParse({ request, serverContext }) {
      return {
        async onRequestParseDone() {
          const schema5 = await schemaDef({
            ...serverContext,
            request
          });
          schemaByRequest.set(request, schema5);
        }
      };
    },
    onEnveloped({ setSchema, context }) {
      if (context?.request == null) {
        throw new Error("Request object is not available in the context. Make sure you use this plugin with GraphQL Yoga.");
      }
      const schema5 = schemaByRequest.get(context.request);
      if (schema5 == null) {
        throw new Error(`No schema found for this request. Make sure you use this plugin with GraphQL Yoga.`);
      }
      setSchema(schema5);
    }
  };
};

// ../../node_modules/@graphql-tools/schema/esm/assertResolversPresent.js
function assertResolversPresent(schema5, resolverValidationOptions = {}) {
  const { requireResolversForArgs, requireResolversForNonScalar, requireResolversForAllFields } = resolverValidationOptions;
  if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {
    throw new TypeError("requireResolversForAllFields takes precedence over the more specific assertions. Please configure either requireResolversForAllFields or requireResolversForArgs / requireResolversForNonScalar, but not a combination of them.");
  }
  forEachField(schema5, (field, typeName, fieldName) => {
    if (requireResolversForAllFields) {
      expectResolver("requireResolversForAllFields", requireResolversForAllFields, field, typeName, fieldName);
    }
    if (requireResolversForArgs && field.args.length > 0) {
      expectResolver("requireResolversForArgs", requireResolversForArgs, field, typeName, fieldName);
    }
    if (requireResolversForNonScalar !== "ignore" && !isScalarType(getNamedType(field.type))) {
      expectResolver("requireResolversForNonScalar", requireResolversForNonScalar, field, typeName, fieldName);
    }
  });
}
var expectResolver = function(validator, behavior, field, typeName, fieldName) {
  if (!field.resolve) {
    const message = `Resolver missing for "${typeName}.${fieldName}".
To disable this validator, use:
  resolverValidationOptions: {
    ${validator}: 'ignore'
  }`;
    if (behavior === "error") {
      throw new Error(message);
    }
    if (behavior === "warn") {
      console.warn(message);
    }
    return;
  }
  if (typeof field.resolve !== "function") {
    throw new Error(`Resolver "${typeName}.${fieldName}" must be a function`);
  }
};

// ../../node_modules/@graphql-tools/schema/esm/checkForResolveTypeResolver.js
function checkForResolveTypeResolver(schema5, requireResolversForResolveType) {
  mapSchema(schema5, {
    [MapperKind.ABSTRACT_TYPE]: (type) => {
      if (!type.resolveType) {
        const message = `Type "${type.name}" is missing a "__resolveType" resolver. Pass 'ignore' into ` + '"resolverValidationOptions.requireResolversForResolveType" to disable this error.';
        if (requireResolversForResolveType === "error") {
          throw new Error(message);
        }
        if (requireResolversForResolveType === "warn") {
          console.warn(message);
        }
      }
      return;
    }
  });
}

// ../../node_modules/@graphql-tools/schema/esm/extendResolversFromInterfaces.js
function extendResolversFromInterfaces(schema5, resolvers) {
  const extendedResolvers = {};
  const typeMap = schema5.getTypeMap();
  for (const typeName in typeMap) {
    const type = typeMap[typeName];
    if ("getInterfaces" in type) {
      extendedResolvers[typeName] = {};
      for (const iFace of type.getInterfaces()) {
        if (resolvers[iFace.name]) {
          for (const fieldName in resolvers[iFace.name]) {
            if (fieldName === "__isTypeOf" || !fieldName.startsWith("__")) {
              extendedResolvers[typeName][fieldName] = resolvers[iFace.name][fieldName];
            }
          }
        }
      }
      const typeResolvers = resolvers[typeName];
      extendedResolvers[typeName] = {
        ...extendedResolvers[typeName],
        ...typeResolvers
      };
    } else {
      const typeResolvers = resolvers[typeName];
      if (typeResolvers != null) {
        extendedResolvers[typeName] = typeResolvers;
      }
    }
  }
  return extendedResolvers;
}

// ../../node_modules/@graphql-tools/schema/esm/addResolversToSchema.js
function addResolversToSchema({ schema: schema5, resolvers: inputResolvers, defaultFieldResolver: defaultFieldResolver2, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false }) {
  const { requireResolversToMatchSchema = "error", requireResolversForResolveType } = resolverValidationOptions;
  const resolvers = inheritResolversFromInterfaces ? extendResolversFromInterfaces(schema5, inputResolvers) : inputResolvers;
  for (const typeName in resolvers) {
    const resolverValue = resolvers[typeName];
    const resolverType = typeof resolverValue;
    if (resolverType !== "object") {
      throw new Error(`"${typeName}" defined in resolvers, but has invalid value "${resolverValue}". The resolver's value must be of type object.`);
    }
    const type = schema5.getType(typeName);
    if (type == null) {
      const msg = `"${typeName}" defined in resolvers, but not in schema`;
      if (requireResolversToMatchSchema && requireResolversToMatchSchema !== "error") {
        if (requireResolversToMatchSchema === "warn") {
          console.warn(msg);
        }
        continue;
      }
      throw new Error(msg);
    } else if (isSpecifiedScalarType(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
        } else {
          type[fieldName] = resolverValue[fieldName];
        }
      }
    } else if (isEnumType(type)) {
      const values3 = type.getValues();
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__") && !values3.some((value) => value.name === fieldName) && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
          const msg = `${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`;
          if (requireResolversToMatchSchema === "error") {
            throw new Error(msg);
          } else {
            console.warn(msg);
          }
        }
      }
    } else if (isUnionType(type)) {
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__") && requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
          const msg = `${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`;
          if (requireResolversToMatchSchema === "error") {
            throw new Error(msg);
          } else {
            console.warn(msg);
          }
        }
      }
    } else if (isObjectType(type) || isInterfaceType(type)) {
      for (const fieldName in resolverValue) {
        if (!fieldName.startsWith("__")) {
          const fields2 = type.getFields();
          const field = fields2[fieldName];
          if (field == null) {
            if (requireResolversToMatchSchema && requireResolversToMatchSchema !== "ignore") {
              const msg = `${typeName}.${fieldName} defined in resolvers, but not in schema`;
              if (requireResolversToMatchSchema === "error") {
                throw new Error(msg);
              } else {
                console.error(msg);
              }
            }
          } else {
            const fieldResolve = resolverValue[fieldName];
            if (typeof fieldResolve !== "function" && typeof fieldResolve !== "object") {
              throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);
            }
          }
        }
      }
    }
  }
  schema5 = updateResolversInPlace ? addResolversToExistingSchema(schema5, resolvers, defaultFieldResolver2) : createNewSchemaWithResolvers(schema5, resolvers, defaultFieldResolver2);
  if (requireResolversForResolveType && requireResolversForResolveType !== "ignore") {
    checkForResolveTypeResolver(schema5, requireResolversForResolveType);
  }
  return schema5;
}
var addResolversToExistingSchema = function(schema5, resolvers, defaultFieldResolver2) {
  const typeMap = schema5.getTypeMap();
  for (const typeName in resolvers) {
    const type = schema5.getType(typeName);
    const resolverValue = resolvers[typeName];
    if (isScalarType(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
        } else if (fieldName === "astNode" && type.astNode != null) {
          type.astNode = {
            ...type.astNode,
            description: resolverValue?.astNode?.description ?? type.astNode.description,
            directives: (type.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? [])
          };
        } else if (fieldName === "extensionASTNodes" && type.extensionASTNodes != null) {
          type.extensionASTNodes = type.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);
        } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
          type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
        } else {
          type[fieldName] = resolverValue[fieldName];
        }
      }
    } else if (isEnumType(type)) {
      const config = type.toConfig();
      const enumValueConfigMap = config.values;
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          config[fieldName.substring(2)] = resolverValue[fieldName];
        } else if (fieldName === "astNode" && config.astNode != null) {
          config.astNode = {
            ...config.astNode,
            description: resolverValue?.astNode?.description ?? config.astNode.description,
            directives: (config.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? [])
          };
        } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
          config.extensionASTNodes = config.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);
        } else if (fieldName === "extensions" && type.extensions != null && resolverValue.extensions != null) {
          type.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
        } else if (enumValueConfigMap[fieldName]) {
          enumValueConfigMap[fieldName].value = resolverValue[fieldName];
        }
      }
      typeMap[typeName] = new GraphQLEnumType(config);
    } else if (isUnionType(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
        }
      }
    } else if (isObjectType(type) || isInterfaceType(type)) {
      for (const fieldName in resolverValue) {
        if (fieldName.startsWith("__")) {
          type[fieldName.substring(2)] = resolverValue[fieldName];
          continue;
        }
        const fields2 = type.getFields();
        const field = fields2[fieldName];
        if (field != null) {
          const fieldResolve = resolverValue[fieldName];
          if (typeof fieldResolve === "function") {
            field.resolve = fieldResolve.bind(resolverValue);
          } else {
            setFieldProperties(field, fieldResolve);
          }
        }
      }
    }
  }
  forEachDefaultValue(schema5, serializeInputValue);
  healSchema(schema5);
  forEachDefaultValue(schema5, parseInputValue);
  if (defaultFieldResolver2 != null) {
    forEachField(schema5, (field) => {
      if (!field.resolve) {
        field.resolve = defaultFieldResolver2;
      }
    });
  }
  return schema5;
};
var createNewSchemaWithResolvers = function(schema5, resolvers, defaultFieldResolver2) {
  schema5 = mapSchema(schema5, {
    [MapperKind.SCALAR_TYPE]: (type) => {
      const config = type.toConfig();
      const resolverValue = resolvers[type.name];
      if (!isSpecifiedScalarType(type) && resolverValue != null) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            config[fieldName.substring(2)] = resolverValue[fieldName];
          } else if (fieldName === "astNode" && config.astNode != null) {
            config.astNode = {
              ...config.astNode,
              description: resolverValue?.astNode?.description ?? config.astNode.description,
              directives: (config.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? [])
            };
          } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
            config.extensionASTNodes = config.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);
          } else if (fieldName === "extensions" && config.extensions != null && resolverValue.extensions != null) {
            config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
          } else {
            config[fieldName] = resolverValue[fieldName];
          }
        }
        return new GraphQLScalarType(config);
      }
    },
    [MapperKind.ENUM_TYPE]: (type) => {
      const resolverValue = resolvers[type.name];
      const config = type.toConfig();
      const enumValueConfigMap = config.values;
      if (resolverValue != null) {
        for (const fieldName in resolverValue) {
          if (fieldName.startsWith("__")) {
            config[fieldName.substring(2)] = resolverValue[fieldName];
          } else if (fieldName === "astNode" && config.astNode != null) {
            config.astNode = {
              ...config.astNode,
              description: resolverValue?.astNode?.description ?? config.astNode.description,
              directives: (config.astNode.directives ?? []).concat(resolverValue?.astNode?.directives ?? [])
            };
          } else if (fieldName === "extensionASTNodes" && config.extensionASTNodes != null) {
            config.extensionASTNodes = config.extensionASTNodes.concat(resolverValue?.extensionASTNodes ?? []);
          } else if (fieldName === "extensions" && config.extensions != null && resolverValue.extensions != null) {
            config.extensions = Object.assign(Object.create(null), type.extensions, resolverValue.extensions);
          } else if (enumValueConfigMap[fieldName]) {
            enumValueConfigMap[fieldName].value = resolverValue[fieldName];
          }
        }
        return new GraphQLEnumType(config);
      }
    },
    [MapperKind.UNION_TYPE]: (type) => {
      const resolverValue = resolvers[type.name];
      if (resolverValue != null) {
        const config = type.toConfig();
        if (resolverValue["__resolveType"]) {
          config.resolveType = resolverValue["__resolveType"];
        }
        return new GraphQLUnionType(config);
      }
    },
    [MapperKind.OBJECT_TYPE]: (type) => {
      const resolverValue = resolvers[type.name];
      if (resolverValue != null) {
        const config = type.toConfig();
        if (resolverValue["__isTypeOf"]) {
          config.isTypeOf = resolverValue["__isTypeOf"];
        }
        return new GraphQLObjectType(config);
      }
    },
    [MapperKind.INTERFACE_TYPE]: (type) => {
      const resolverValue = resolvers[type.name];
      if (resolverValue != null) {
        const config = type.toConfig();
        if (resolverValue["__resolveType"]) {
          config.resolveType = resolverValue["__resolveType"];
        }
        return new GraphQLInterfaceType(config);
      }
    },
    [MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {
      const resolverValue = resolvers[typeName];
      if (resolverValue != null) {
        const fieldResolve = resolverValue[fieldName];
        if (fieldResolve != null) {
          const newFieldConfig = { ...fieldConfig };
          if (typeof fieldResolve === "function") {
            newFieldConfig.resolve = fieldResolve.bind(resolverValue);
          } else {
            setFieldProperties(newFieldConfig, fieldResolve);
          }
          return newFieldConfig;
        }
      }
    }
  });
  if (defaultFieldResolver2 != null) {
    schema5 = mapSchema(schema5, {
      [MapperKind.OBJECT_FIELD]: (fieldConfig) => ({
        ...fieldConfig,
        resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver2
      })
    });
  }
  return schema5;
};
var setFieldProperties = function(field, propertiesObj) {
  for (const propertyName in propertiesObj) {
    field[propertyName] = propertiesObj[propertyName];
  }
};

// ../../node_modules/@graphql-tools/merge/esm/merge-resolvers.js
function mergeResolvers(resolversDefinitions, options) {
  if (!resolversDefinitions || Array.isArray(resolversDefinitions) && resolversDefinitions.length === 0) {
    return {};
  }
  if (!Array.isArray(resolversDefinitions)) {
    return resolversDefinitions;
  }
  if (resolversDefinitions.length === 1) {
    return resolversDefinitions[0] || {};
  }
  const resolvers = new Array;
  for (let resolversDefinition of resolversDefinitions) {
    if (Array.isArray(resolversDefinition)) {
      resolversDefinition = mergeResolvers(resolversDefinition);
    }
    if (typeof resolversDefinition === "object" && resolversDefinition) {
      resolvers.push(resolversDefinition);
    }
  }
  const result = mergeDeep(resolvers, true);
  if (options?.exclusions) {
    for (const exclusion of options.exclusions) {
      const [typeName, fieldName] = exclusion.split(".");
      if (!fieldName || fieldName === "*") {
        delete result[typeName];
      } else if (result[typeName]) {
        delete result[typeName][fieldName];
      }
    }
  }
  return result;
}

// ../../node_modules/@graphql-tools/merge/esm/typedefs-mergers/arguments.js
function mergeArguments(args1, args2, config) {
  const result = deduplicateArguments([...args2, ...args1].filter(isSome), config);
  if (config && config.sort) {
    result.sort(compareNodes);
  }
  return result;
}
var deduplicateArguments = function(args, config) {
  return args.reduce((acc, current) => {
    const dupIndex = acc.findIndex((arg) => arg.name.value === current.name.value);
    if (dupIndex === -1) {
      return acc.concat([current]);
    } else if (!config?.reverseArguments) {
      acc[dupIndex] = current;
    }
    return acc;
  }, []);
};

// ../../node_modules/@graphql-tools/merge/esm/typedefs-mergers/directives.js
var directiveAlreadyExists = function(directivesArr, otherDirective) {
  return !!directivesArr.find((directive) => directive.name.value === otherDirective.name.value);
};
var isRepeatableDirective = function(directive, directives14) {
  return !!directives14?.[directive.name.value]?.repeatable;
};
var nameAlreadyExists = function(name, namesArr) {
  return namesArr.some(({ value }) => value === name.value);
};
var mergeArguments2 = function(a1, a2) {
  const result = [...a2];
  for (const argument of a1) {
    const existingIndex = result.findIndex((a) => a.name.value === argument.name.value);
    if (existingIndex > -1) {
      const existingArg = result[existingIndex];
      if (existingArg.value.kind === "ListValue") {
        const source2 = existingArg.value.values;
        const target = argument.value.values;
        existingArg.value.values = deduplicateLists(source2, target, (targetVal, source3) => {
          const value = targetVal.value;
          return !value || !source3.some((sourceVal) => sourceVal.value === value);
        });
      } else {
        existingArg.value = argument.value;
      }
    } else {
      result.push(argument);
    }
  }
  return result;
};
var deduplicateDirectives = function(directives14, definitions) {
  return directives14.map((directive, i, all) => {
    const firstAt = all.findIndex((d) => d.name.value === directive.name.value);
    if (firstAt !== i && !isRepeatableDirective(directive, definitions)) {
      const dup = all[firstAt];
      directive.arguments = mergeArguments2(directive.arguments, dup.arguments);
      return null;
    }
    return directive;
  }).filter(isSome);
};
function mergeDirectives(d1 = [], d2 = [], config, directives14) {
  const reverseOrder = config && config.reverseDirectives;
  const asNext = reverseOrder ? d1 : d2;
  const asFirst = reverseOrder ? d2 : d1;
  const result = deduplicateDirectives([...asNext], directives14);
  for (const directive of asFirst) {
    if (directiveAlreadyExists(result, directive) && !isRepeatableDirective(directive, directives14)) {
      const existingDirectiveIndex = result.findIndex((d) => d.name.value === directive.name.value);
      const existingDirective = result[existingDirectiveIndex];
      result[existingDirectiveIndex].arguments = mergeArguments2(directive.arguments || [], existingDirective.arguments || []);
    } else {
      result.push(directive);
    }
  }
  return result;
}
function mergeDirective(node, existingNode) {
  if (existingNode) {
    return {
      ...node,
      arguments: deduplicateLists(existingNode.arguments || [], node.arguments || [], (arg, existingArgs) => !nameAlreadyExists(arg.name, existingArgs.map((a) => a.name))),
      locations: [
        ...existingNode.locations,
        ...node.locations.filter((name) => !nameAlreadyExists(name, existingNode.locations))
      ]
    };
  }
  return node;
}
var deduplicateLists = function(source2, target, filterFn) {
  return source2.concat(target.filter((val) => filterFn(val, source2)));
};

// ../../node_modules/@graphql-tools/merge/esm/typedefs-mergers/enum-values.js
function mergeEnumValues(first, second, config, directives15) {
  if (config?.consistentEnumMerge) {
    const reversed = [];
    if (first) {
      reversed.push(...first);
    }
    first = second;
    second = reversed;
  }
  const enumValueMap = new Map;
  if (first) {
    for (const firstValue of first) {
      enumValueMap.set(firstValue.name.value, firstValue);
    }
  }
  if (second) {
    for (const secondValue of second) {
      const enumValue = secondValue.name.value;
      if (enumValueMap.has(enumValue)) {
        const firstValue = enumValueMap.get(enumValue);
        firstValue.description = secondValue.description || firstValue.description;
        firstValue.directives = mergeDirectives(secondValue.directives, firstValue.directives, directives15);
      } else {
        enumValueMap.set(enumValue, secondValue);
      }
    }
  }
  const result = [...enumValueMap.values()];
  if (config && config.sort) {
    result.sort(compareNodes);
  }
  return result;
}

// ../../node_modules/@graphql-tools/merge/esm/typedefs-mergers/enum.js
function mergeEnum(e1, e2, config, directives16) {
  if (e2) {
    return {
      name: e1.name,
      description: e1["description"] || e2["description"],
      kind: config?.convertExtensions || e1.kind === "EnumTypeDefinition" || e2.kind === "EnumTypeDefinition" ? "EnumTypeDefinition" : "EnumTypeExtension",
      loc: e1.loc,
      directives: mergeDirectives(e1.directives, e2.directives, config, directives16),
      values: mergeEnumValues(e1.values, e2.values, config)
    };
  }
  return config?.convertExtensions ? {
    ...e1,
    kind: Kind.ENUM_TYPE_DEFINITION
  } : e1;
}

// ../../node_modules/@graphql-tools/merge/esm/typedefs-mergers/utils.js
function isStringTypes(types2) {
  return typeof types2 === "string";
}
function isSourceTypes(types2) {
  return types2 instanceof Source;
}
function extractType(type) {
  let visitedType = type;
  while (visitedType.kind === Kind.LIST_TYPE || visitedType.kind === "NonNullType") {
    visitedType = visitedType.type;
  }
  return visitedType;
}
function isWrappingTypeNode(type) {
  return type.kind !== Kind.NAMED_TYPE;
}
function isListTypeNode(type) {
  return type.kind === Kind.LIST_TYPE;
}
function isNonNullTypeNode(type) {
  return type.kind === Kind.NON_NULL_TYPE;
}
function printTypeNode(type) {
  if (isListTypeNode(type)) {
    return `[${printTypeNode(type.type)}]`;
  }
  if (isNonNullTypeNode(type)) {
    return `${printTypeNode(type.type)}!`;
  }
  return type.name.value;
}
function defaultStringComparator(a, b) {
  if (a == null && b == null) {
    return CompareVal.A_EQUALS_B;
  }
  if (a == null) {
    return CompareVal.A_SMALLER_THAN_B;
  }
  if (b == null) {
    return CompareVal.A_GREATER_THAN_B;
  }
  if (a < b)
    return CompareVal.A_SMALLER_THAN_B;
  if (a > b)
    return CompareVal.A_GREATER_THAN_B;
  return CompareVal.A_EQUALS_B;
}
var CompareVal;
(function(CompareVal2) {
  CompareVal2[CompareVal2["A_SMALLER_THAN_B"] = -1] = "A_SMALLER_THAN_B";
  CompareVal2[CompareVal2["A_EQUALS_B"] = 0] = "A_EQUALS_B";
  CompareVal2[CompareVal2["A_GREATER_THAN_B"] = 1] = "A_GREATER_THAN_B";
})(CompareVal || (CompareVal = {}));

// ../../node_modules/@graphql-tools/merge/esm/typedefs-mergers/fields.js
var fieldAlreadyExists = function(fieldsArr, otherField) {
  const resultIndex = fieldsArr.findIndex((field) => field.name.value === otherField.name.value);
  return [resultIndex > -1 ? fieldsArr[resultIndex] : null, resultIndex];
};
function mergeFields(type, f1, f2, config, directives17) {
  const result = [];
  if (f2 != null) {
    result.push(...f2);
  }
  if (f1 != null) {
    for (const field of f1) {
      const [existing, existingIndex] = fieldAlreadyExists(result, field);
      if (existing && !config?.ignoreFieldConflicts) {
        const newField = config?.onFieldTypeConflict && config.onFieldTypeConflict(existing, field, type, config?.throwOnConflict) || preventConflicts(type, existing, field, config?.throwOnConflict);
        newField.arguments = mergeArguments(field["arguments"] || [], existing["arguments"] || [], config);
        newField.directives = mergeDirectives(field.directives, existing.directives, config, directives17);
        newField.description = field.description || existing.description;
        result[existingIndex] = newField;
      } else {
        result.push(field);
      }
    }
  }
  if (config && config.sort) {
    result.sort(compareNodes);
  }
  if (config && config.exclusions) {
    const exclusions = config.exclusions;
    return result.filter((field) => !exclusions.includes(`${type.name.value}.${field.name.value}`));
  }
  return result;
}
var preventConflicts = function(type, a, b, ignoreNullability = false) {
  const aType = printTypeNode(a.type);
  const bType = printTypeNode(b.type);
  if (aType !== bType) {
    const t12 = extractType(a.type);
    const t2 = extractType(b.type);
    if (t12.name.value !== t2.name.value) {
      throw new Error(`Field "${b.name.value}" already defined with a different type. Declared as "${t12.name.value}", but you tried to override with "${t2.name.value}"`);
    }
    if (!safeChangeForFieldType(a.type, b.type, !ignoreNullability)) {
      throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);
    }
  }
  if (isNonNullTypeNode(b.type) && !isNonNullTypeNode(a.type)) {
    a.type = b.type;
  }
  return a;
};
var safeChangeForFieldType = function(oldType, newType, ignoreNullability = false) {
  if (!isWrappingTypeNode(oldType) && !isWrappingTypeNode(newType)) {
    return oldType.toString() === newType.toString();
  }
  if (isNonNullTypeNode(newType)) {
    const ofType = isNonNullTypeNode(oldType) ? oldType.type : oldType;
    return safeChangeForFieldType(ofType, newType.type);
  }
  if (isNonNullTypeNode(oldType)) {
    return safeChangeForFieldType(newType, oldType, ignoreNullability);
  }
  if (isListTypeNode(oldType)) {
    return isListTypeNode(newType) && safeChangeForFieldType(oldType.type, newType.type) || isNonNullTypeNode(newType) && safeChangeForFieldType(oldType, newType["type"]);
  }
  return false;
};

// ../../node_modules/@graphql-tools/merge/esm/typedefs-mergers/input-type.js
function mergeInputType(node, existingNode, config, directives18) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: config?.convertExtensions || node.kind === "InputObjectTypeDefinition" || existingNode.kind === "InputObjectTypeDefinition" ? "InputObjectTypeDefinition" : "InputObjectTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config),
        directives: mergeDirectives(node.directives, existingNode.directives, config, directives18)
      };
    } catch (e) {
      throw new Error(`Unable to merge GraphQL input type "${node.name.value}": ${e.message}`);
    }
  }
  return config?.convertExtensions ? {
    ...node,
    kind: Kind.INPUT_OBJECT_TYPE_DEFINITION
  } : node;
}

// ../../node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-named-type-array.js
var alreadyExists = function(arr, other) {
  return !!arr.find((i) => i.name.value === other.name.value);
};
function mergeNamedTypeArray(first = [], second = [], config = {}) {
  const result = [...second, ...first.filter((d) => !alreadyExists(second, d))];
  if (config && config.sort) {
    result.sort(compareNodes);
  }
  return result;
}

// ../../node_modules/@graphql-tools/merge/esm/typedefs-mergers/interface.js
function mergeInterface(node, existingNode, config, directives19) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: config?.convertExtensions || node.kind === "InterfaceTypeDefinition" || existingNode.kind === "InterfaceTypeDefinition" ? "InterfaceTypeDefinition" : "InterfaceTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config, directives19),
        directives: mergeDirectives(node.directives, existingNode.directives, config, directives19),
        interfaces: node["interfaces"] ? mergeNamedTypeArray(node["interfaces"], existingNode["interfaces"], config) : undefined
      };
    } catch (e) {
      throw new Error(`Unable to merge GraphQL interface "${node.name.value}": ${e.message}`);
    }
  }
  return config?.convertExtensions ? {
    ...node,
    kind: Kind.INTERFACE_TYPE_DEFINITION
  } : node;
}

// ../../node_modules/@graphql-tools/merge/esm/typedefs-mergers/scalar.js
function mergeScalar(node, existingNode, config, directives20) {
  if (existingNode) {
    return {
      name: node.name,
      description: node["description"] || existingNode["description"],
      kind: config?.convertExtensions || node.kind === "ScalarTypeDefinition" || existingNode.kind === "ScalarTypeDefinition" ? "ScalarTypeDefinition" : "ScalarTypeExtension",
      loc: node.loc,
      directives: mergeDirectives(node.directives, existingNode.directives, config, directives20)
    };
  }
  return config?.convertExtensions ? {
    ...node,
    kind: Kind.SCALAR_TYPE_DEFINITION
  } : node;
}

// ../../node_modules/@graphql-tools/merge/esm/typedefs-mergers/schema-def.js
var mergeOperationTypes = function(opNodeList = [], existingOpNodeList = []) {
  const finalOpNodeList = [];
  for (const opNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {
    const opNode = opNodeList.find((n) => n.operation === opNodeType) || existingOpNodeList.find((n) => n.operation === opNodeType);
    if (opNode) {
      finalOpNodeList.push(opNode);
    }
  }
  return finalOpNodeList;
};
function mergeSchemaDefs(node, existingNode, config, directives21) {
  if (existingNode) {
    return {
      kind: node.kind === Kind.SCHEMA_DEFINITION || existingNode.kind === Kind.SCHEMA_DEFINITION ? Kind.SCHEMA_DEFINITION : Kind.SCHEMA_EXTENSION,
      description: node["description"] || existingNode["description"],
      directives: mergeDirectives(node.directives, existingNode.directives, config, directives21),
      operationTypes: mergeOperationTypes(node.operationTypes, existingNode.operationTypes)
    };
  }
  return config?.convertExtensions ? {
    ...node,
    kind: Kind.SCHEMA_DEFINITION
  } : node;
}
var DEFAULT_OPERATION_TYPE_NAME_MAP = {
  query: "Query",
  mutation: "Mutation",
  subscription: "Subscription"
};

// ../../node_modules/@graphql-tools/merge/esm/typedefs-mergers/type.js
function mergeType(node, existingNode, config, directives22) {
  if (existingNode) {
    try {
      return {
        name: node.name,
        description: node["description"] || existingNode["description"],
        kind: config?.convertExtensions || node.kind === "ObjectTypeDefinition" || existingNode.kind === "ObjectTypeDefinition" ? "ObjectTypeDefinition" : "ObjectTypeExtension",
        loc: node.loc,
        fields: mergeFields(node, node.fields, existingNode.fields, config, directives22),
        directives: mergeDirectives(node.directives, existingNode.directives, config, directives22),
        interfaces: mergeNamedTypeArray(node.interfaces, existingNode.interfaces, config)
      };
    } catch (e) {
      throw new Error(`Unable to merge GraphQL type "${node.name.value}": ${e.message}`);
    }
  }
  return config?.convertExtensions ? {
    ...node,
    kind: Kind.OBJECT_TYPE_DEFINITION
  } : node;
}

// ../../node_modules/@graphql-tools/merge/esm/typedefs-mergers/union.js
function mergeUnion(first, second, config, directives23) {
  if (second) {
    return {
      name: first.name,
      description: first["description"] || second["description"],
      directives: mergeDirectives(first.directives, second.directives, config, directives23),
      kind: config?.convertExtensions || first.kind === "UnionTypeDefinition" || second.kind === "UnionTypeDefinition" ? Kind.UNION_TYPE_DEFINITION : Kind.UNION_TYPE_EXTENSION,
      loc: first.loc,
      types: mergeNamedTypeArray(first.types, second.types, config)
    };
  }
  return config?.convertExtensions ? {
    ...first,
    kind: Kind.UNION_TYPE_DEFINITION
  } : first;
}

// ../../node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-nodes.js
function isNamedDefinitionNode(definitionNode) {
  return "name" in definitionNode;
}
function mergeGraphQLNodes(nodes, config, directives24 = {}) {
  const mergedResultMap = directives24;
  for (const nodeDefinition of nodes) {
    if (isNamedDefinitionNode(nodeDefinition)) {
      const name = nodeDefinition.name?.value;
      if (config?.commentDescriptions) {
        collectComment(nodeDefinition);
      }
      if (name == null) {
        continue;
      }
      if (config?.exclusions?.includes(name + ".*") || config?.exclusions?.includes(name)) {
        delete mergedResultMap[name];
      } else {
        switch (nodeDefinition.kind) {
          case Kind.OBJECT_TYPE_DEFINITION:
          case Kind.OBJECT_TYPE_EXTENSION:
            mergedResultMap[name] = mergeType(nodeDefinition, mergedResultMap[name], config, directives24);
            break;
          case Kind.ENUM_TYPE_DEFINITION:
          case Kind.ENUM_TYPE_EXTENSION:
            mergedResultMap[name] = mergeEnum(nodeDefinition, mergedResultMap[name], config, directives24);
            break;
          case Kind.UNION_TYPE_DEFINITION:
          case Kind.UNION_TYPE_EXTENSION:
            mergedResultMap[name] = mergeUnion(nodeDefinition, mergedResultMap[name], config, directives24);
            break;
          case Kind.SCALAR_TYPE_DEFINITION:
          case Kind.SCALAR_TYPE_EXTENSION:
            mergedResultMap[name] = mergeScalar(nodeDefinition, mergedResultMap[name], config, directives24);
            break;
          case Kind.INPUT_OBJECT_TYPE_DEFINITION:
          case Kind.INPUT_OBJECT_TYPE_EXTENSION:
            mergedResultMap[name] = mergeInputType(nodeDefinition, mergedResultMap[name], config, directives24);
            break;
          case Kind.INTERFACE_TYPE_DEFINITION:
          case Kind.INTERFACE_TYPE_EXTENSION:
            mergedResultMap[name] = mergeInterface(nodeDefinition, mergedResultMap[name], config, directives24);
            break;
          case Kind.DIRECTIVE_DEFINITION:
            if (mergedResultMap[name]) {
              const isInheritedFromPrototype = name in {};
              if (isInheritedFromPrototype) {
                if (!isASTNode(mergedResultMap[name])) {
                  mergedResultMap[name] = undefined;
                }
              }
            }
            mergedResultMap[name] = mergeDirective(nodeDefinition, mergedResultMap[name]);
            break;
        }
      }
    } else if (nodeDefinition.kind === Kind.SCHEMA_DEFINITION || nodeDefinition.kind === Kind.SCHEMA_EXTENSION) {
      mergedResultMap[schemaDefSymbol] = mergeSchemaDefs(nodeDefinition, mergedResultMap[schemaDefSymbol], config);
    }
  }
  return mergedResultMap;
}
var isASTNode = function(node) {
  return node != null && typeof node === "object" && "kind" in node && typeof node.kind === "string";
};
var schemaDefSymbol = "SCHEMA_DEF_SYMBOL";

// ../../node_modules/@graphql-tools/merge/esm/typedefs-mergers/merge-typedefs.js
function mergeTypeDefs(typeSource, config) {
  resetComments();
  const doc = {
    kind: Kind.DOCUMENT,
    definitions: mergeGraphQLTypes(typeSource, {
      useSchemaDefinition: true,
      forceSchemaDefinition: false,
      throwOnConflict: false,
      commentDescriptions: false,
      ...config
    })
  };
  let result;
  if (config?.commentDescriptions) {
    result = printWithComments(doc);
  } else {
    result = doc;
  }
  resetComments();
  return result;
}
var visitTypeSources = function(typeSource, options, allDirectives = [], allNodes = [], visitedTypeSources = new Set) {
  if (typeSource && !visitedTypeSources.has(typeSource)) {
    visitedTypeSources.add(typeSource);
    if (typeof typeSource === "function") {
      visitTypeSources(typeSource(), options, allDirectives, allNodes, visitedTypeSources);
    } else if (Array.isArray(typeSource)) {
      for (const type2 of typeSource) {
        visitTypeSources(type2, options, allDirectives, allNodes, visitedTypeSources);
      }
    } else if (isSchema(typeSource)) {
      const documentNode = getDocumentNodeFromSchema(typeSource, options);
      visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);
    } else if (isStringTypes(typeSource) || isSourceTypes(typeSource)) {
      const documentNode = parse(typeSource, options);
      visitTypeSources(documentNode.definitions, options, allDirectives, allNodes, visitedTypeSources);
    } else if (typeof typeSource === "object" && isDefinitionNode(typeSource)) {
      if (typeSource.kind === Kind.DIRECTIVE_DEFINITION) {
        allDirectives.push(typeSource);
      } else {
        allNodes.push(typeSource);
      }
    } else if (isDocumentNode(typeSource)) {
      visitTypeSources(typeSource.definitions, options, allDirectives, allNodes, visitedTypeSources);
    } else {
      throw new Error(`typeDefs must contain only strings, documents, schemas, or functions, got ${typeof typeSource}`);
    }
  }
  return { allDirectives, allNodes };
};
function mergeGraphQLTypes(typeSource, config) {
  resetComments();
  const { allDirectives, allNodes } = visitTypeSources(typeSource, config);
  const mergedDirectives = mergeGraphQLNodes(allDirectives, config);
  const mergedNodes = mergeGraphQLNodes(allNodes, config, mergedDirectives);
  if (config?.useSchemaDefinition) {
    const schemaDef = mergedNodes[schemaDefSymbol] || {
      kind: Kind.SCHEMA_DEFINITION,
      operationTypes: []
    };
    const operationTypes = schemaDef.operationTypes;
    for (const opTypeDefNodeType in DEFAULT_OPERATION_TYPE_NAME_MAP) {
      const opTypeDefNode = operationTypes.find((operationType) => operationType.operation === opTypeDefNodeType);
      if (!opTypeDefNode) {
        const possibleRootTypeName = DEFAULT_OPERATION_TYPE_NAME_MAP[opTypeDefNodeType];
        const existingPossibleRootType = mergedNodes[possibleRootTypeName];
        if (existingPossibleRootType != null && existingPossibleRootType.name != null) {
          operationTypes.push({
            kind: Kind.OPERATION_TYPE_DEFINITION,
            type: {
              kind: Kind.NAMED_TYPE,
              name: existingPossibleRootType.name
            },
            operation: opTypeDefNodeType
          });
        }
      }
    }
    if (schemaDef?.operationTypes?.length != null && schemaDef.operationTypes.length > 0) {
      mergedNodes[schemaDefSymbol] = schemaDef;
    }
  }
  if (config?.forceSchemaDefinition && !mergedNodes[schemaDefSymbol]?.operationTypes?.length) {
    mergedNodes[schemaDefSymbol] = {
      kind: Kind.SCHEMA_DEFINITION,
      operationTypes: [
        {
          kind: Kind.OPERATION_TYPE_DEFINITION,
          operation: "query",
          type: {
            kind: Kind.NAMED_TYPE,
            name: {
              kind: Kind.NAME,
              value: "Query"
            }
          }
        }
      ]
    };
  }
  const mergedNodeDefinitions = Object.values(mergedNodes);
  if (config?.sort) {
    const sortFn = typeof config.sort === "function" ? config.sort : defaultStringComparator;
    mergedNodeDefinitions.sort((a, b) => sortFn(a.name?.value, b.name?.value));
  }
  return mergedNodeDefinitions;
}

// ../../node_modules/@graphql-tools/merge/esm/extensions.js
var applyExtensionObject = function(obj, extensions) {
  if (!obj || !extensions || extensions === obj.extensions) {
    return;
  }
  if (!obj.extensions) {
    obj.extensions = extensions;
    return;
  }
  obj.extensions = mergeDeep([obj.extensions, extensions], false, true);
};
function applyExtensions(schema5, extensions) {
  applyExtensionObject(schema5, extensions.schemaExtensions);
  for (const [typeName, data] of Object.entries(extensions.types || {})) {
    const type2 = schema5.getType(typeName);
    if (type2) {
      applyExtensionObject(type2, data.extensions);
      if (data.type === "object" || data.type === "interface") {
        for (const [fieldName, fieldData] of Object.entries(data.fields)) {
          const field = type2.getFields()[fieldName];
          if (field) {
            applyExtensionObject(field, fieldData.extensions);
            for (const [arg, argData] of Object.entries(fieldData.arguments)) {
              applyExtensionObject(field.args.find((a) => a.name === arg), argData);
            }
          }
        }
      } else if (data.type === "input") {
        for (const [fieldName, fieldData] of Object.entries(data.fields)) {
          const field = type2.getFields()[fieldName];
          applyExtensionObject(field, fieldData.extensions);
        }
      } else if (data.type === "enum") {
        for (const [valueName, valueData] of Object.entries(data.values)) {
          const value = type2.getValue(valueName);
          applyExtensionObject(value, valueData);
        }
      }
    }
  }
  return schema5;
}

// ../../node_modules/@graphql-tools/schema/esm/makeExecutableSchema.js
function makeExecutableSchema({ typeDefs, resolvers = {}, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false, schemaExtensions, defaultFieldResolver: defaultFieldResolver2, ...otherOptions }) {
  if (typeof resolverValidationOptions !== "object") {
    throw new Error("Expected `resolverValidationOptions` to be an object");
  }
  if (!typeDefs) {
    throw new Error("Must provide typeDefs");
  }
  let schema5;
  if (isSchema(typeDefs)) {
    schema5 = typeDefs;
  } else if (otherOptions?.commentDescriptions) {
    const mergedTypeDefs = mergeTypeDefs(typeDefs, {
      ...otherOptions,
      commentDescriptions: true
    });
    schema5 = buildSchema(mergedTypeDefs, otherOptions);
  } else {
    const mergedTypeDefs = mergeTypeDefs(typeDefs, otherOptions);
    schema5 = buildASTSchema(mergedTypeDefs, otherOptions);
  }
  schema5 = addResolversToSchema({
    schema: schema5,
    resolvers: mergeResolvers(resolvers),
    resolverValidationOptions,
    inheritResolversFromInterfaces,
    updateResolversInPlace,
    defaultFieldResolver: defaultFieldResolver2
  });
  if (Object.keys(resolverValidationOptions).length > 0) {
    assertResolversPresent(schema5, resolverValidationOptions);
  }
  if (schemaExtensions) {
    for (const schemaExtension of asArray(schemaExtensions)) {
      applyExtensions(schema5, schemaExtension);
    }
  }
  return schema5;
}

// ../../node_modules/@graphql-tools/schema/esm/merge-schemas.js
function mergeSchemas(config) {
  const extractedTypeDefs = [];
  const extractedResolvers = [];
  const extractedSchemaExtensions = [];
  if (config.schemas != null) {
    for (const schema5 of config.schemas) {
      extractedTypeDefs.push(getDocumentNodeFromSchema(schema5));
      extractedResolvers.push(getResolversFromSchema(schema5));
      extractedSchemaExtensions.push(extractExtensionsFromSchema(schema5));
    }
  }
  if (config.typeDefs != null) {
    extractedTypeDefs.push(config.typeDefs);
  }
  if (config.resolvers != null) {
    const additionalResolvers = asArray(config.resolvers);
    extractedResolvers.push(...additionalResolvers);
  }
  if (config.schemaExtensions != null) {
    const additionalSchemaExtensions = asArray(config.schemaExtensions);
    extractedSchemaExtensions.push(...additionalSchemaExtensions);
  }
  return makeExecutableSchema({
    ...config,
    typeDefs: extractedTypeDefs,
    resolvers: extractedResolvers,
    schemaExtensions: extractedSchemaExtensions
  });
}

// ../../node_modules/@envelop/core/esm/document-string-map.js
var documentStringMap = new WeakMap;

// ../../node_modules/@envelop/core/esm/utils.js
var getSubscribeArgs = function(args) {
  return args.length === 1 ? args[0] : {
    schema: args[0],
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    fieldResolver: args[6],
    subscribeFieldResolver: args[7]
  };
};
function mapAsyncIterator3(source2, mapper) {
  const iterator = source2[Symbol.asyncIterator]();
  async function mapResult(result) {
    if (result.done) {
      return result;
    }
    try {
      return { value: await mapper(result.value), done: false };
    } catch (error) {
      try {
        await iterator.return?.();
      } catch (_error) {
      }
      throw error;
    }
  }
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      return await mapResult(await iterator.next());
    },
    async return() {
      const promise = iterator.return?.();
      return promise ? await mapResult(await promise) : { value: undefined, done: true };
    },
    async throw(error) {
      const promise = iterator.throw?.();
      if (promise) {
        return await mapResult(await promise);
      }
      throw error;
    }
  };
  return stream;
}
var getExecuteArgs = function(args) {
  return args.length === 1 ? args[0] : {
    schema: args[0],
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    fieldResolver: args[6],
    typeResolver: args[7]
  };
};
function isAsyncIterable3(maybeAsyncIterable) {
  return typeof maybeAsyncIterable === "object" && maybeAsyncIterable != null && typeof maybeAsyncIterable[Symbol.asyncIterator] === "function";
}
function handleStreamOrSingleExecutionResult(payload, fn) {
  if (isAsyncIterable3(payload.result)) {
    return { onNext: fn };
  }
  fn({
    args: payload.args,
    result: payload.result,
    setResult: payload.setResult
  });
  return;
}
function finalAsyncIterator(source2, onFinal) {
  const iterator = source2[Symbol.asyncIterator]();
  let isDone = false;
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      const result = await iterator.next();
      if (result.done && isDone === false) {
        isDone = true;
        onFinal();
      }
      return result;
    },
    async return() {
      const promise = iterator.return?.();
      if (isDone === false) {
        isDone = true;
        onFinal();
      }
      return promise ? await promise : { done: true, value: undefined };
    },
    async throw(error) {
      const promise = iterator.throw?.();
      if (promise) {
        return await promise;
      }
      throw error;
    }
  };
  return stream;
}
function errorAsyncIterator(source2, onError) {
  const iterator = source2[Symbol.asyncIterator]();
  const stream = {
    [Symbol.asyncIterator]() {
      return stream;
    },
    async next() {
      try {
        return await iterator.next();
      } catch (error) {
        onError(error);
        return { done: true, value: undefined };
      }
    },
    async return() {
      const promise = iterator.return?.();
      return promise ? await promise : { done: true, value: undefined };
    },
    async throw(error) {
      const promise = iterator.throw?.();
      if (promise) {
        return await promise;
      }
      throw error;
    }
  };
  return stream;
}
var envelopIsIntrospectionSymbol = Symbol("ENVELOP_IS_INTROSPECTION");
var makeSubscribe = (subscribeFn) => (...polyArgs) => subscribeFn(getSubscribeArgs(polyArgs));
var makeExecute = (executeFn) => (...polyArgs) => executeFn(getExecuteArgs(polyArgs));

// ../../node_modules/@envelop/core/esm/orchestrator.js
var throwEngineFunctionError = function(name) {
  throw Error(`No \`${name}\` function found! Register it using "useEngine" plugin.`);
};
function createEnvelopOrchestrator({ plugins }) {
  let schema5 = null;
  let initDone = false;
  const parse2 = () => throwEngineFunctionError("parse");
  const validate5 = () => throwEngineFunctionError("validate");
  const execute2 = () => throwEngineFunctionError("execute");
  const subscribe2 = () => throwEngineFunctionError("subscribe");
  const replaceSchema = (newSchema, ignorePluginIndex = -1) => {
    schema5 = newSchema;
    if (initDone) {
      for (const [i, plugin] of plugins.entries()) {
        if (i !== ignorePluginIndex) {
          plugin.onSchemaChange && plugin.onSchemaChange({
            schema: schema5,
            replaceSchema: (schemaToSet) => {
              replaceSchema(schemaToSet, i);
            }
          });
        }
      }
    }
  };
  const contextErrorHandlers = [];
  for (const [i, plugin] of plugins.entries()) {
    plugin.onPluginInit && plugin.onPluginInit({
      plugins,
      addPlugin: (newPlugin) => {
        plugins.push(newPlugin);
      },
      setSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i),
      registerContextErrorHandler: (handler) => contextErrorHandlers.push(handler)
    });
  }
  const beforeCallbacks = {
    init: [],
    parse: [],
    validate: [],
    subscribe: [],
    execute: [],
    context: []
  };
  for (const { onContextBuilding, onExecute, onParse, onSubscribe, onValidate, onEnveloped } of plugins) {
    onEnveloped && beforeCallbacks.init.push(onEnveloped);
    onContextBuilding && beforeCallbacks.context.push(onContextBuilding);
    onExecute && beforeCallbacks.execute.push(onExecute);
    onParse && beforeCallbacks.parse.push(onParse);
    onSubscribe && beforeCallbacks.subscribe.push(onSubscribe);
    onValidate && beforeCallbacks.validate.push(onValidate);
  }
  const init = (initialContext) => {
    for (const [i, onEnveloped] of beforeCallbacks.init.entries()) {
      onEnveloped({
        context: initialContext,
        extendContext: (extension) => {
          if (!initialContext) {
            return;
          }
          Object.assign(initialContext, extension);
        },
        setSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i)
      });
    }
  };
  const customParse = beforeCallbacks.parse.length ? (initialContext) => (source2, parseOptions) => {
    let result = null;
    let parseFn = parse2;
    const context = initialContext;
    const afterCalls = [];
    for (const onParse of beforeCallbacks.parse) {
      const afterFn = onParse({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        params: { source: source2, options: parseOptions },
        parseFn,
        setParseFn: (newFn) => {
          parseFn = newFn;
        },
        setParsedDocument: (newDoc) => {
          result = newDoc;
        }
      });
      afterFn && afterCalls.push(afterFn);
    }
    if (result === null) {
      try {
        result = parseFn(source2, parseOptions);
      } catch (e) {
        result = e;
      }
    }
    for (const afterCb of afterCalls) {
      afterCb({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        replaceParseResult: (newResult) => {
          result = newResult;
        },
        result
      });
    }
    if (result === null) {
      throw new Error(`Failed to parse document.`);
    }
    if (result instanceof Error) {
      throw result;
    }
    documentStringMap.set(result, source2.toString());
    return result;
  } : () => parse2;
  const customValidate = beforeCallbacks.validate.length ? (initialContext) => (schema6, documentAST, rules, typeInfo, validationOptions) => {
    let actualRules = rules ? [...rules] : undefined;
    let validateFn = validate5;
    let result = null;
    const context = initialContext;
    const afterCalls = [];
    for (const onValidate of beforeCallbacks.validate) {
      const afterFn = onValidate({
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        params: {
          schema: schema6,
          documentAST,
          rules: actualRules,
          typeInfo,
          options: validationOptions
        },
        validateFn,
        addValidationRule: (rule) => {
          if (!actualRules) {
            actualRules = [];
          }
          actualRules.push(rule);
        },
        setValidationFn: (newFn) => {
          validateFn = newFn;
        },
        setResult: (newResults) => {
          result = newResults;
        }
      });
      afterFn && afterCalls.push(afterFn);
    }
    if (!result) {
      result = validateFn(schema6, documentAST, actualRules, typeInfo, validationOptions);
    }
    if (!result) {
      return;
    }
    const valid = result.length === 0;
    for (const afterCb of afterCalls) {
      afterCb({
        valid,
        result,
        context,
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        setResult: (newResult) => {
          result = newResult;
        }
      });
    }
    return result;
  } : () => validate5;
  const customContextFactory = beforeCallbacks.context.length ? (initialContext) => async (orchestratorCtx) => {
    const afterCalls = [];
    const context = initialContext;
    if (orchestratorCtx) {
      Object.assign(context, orchestratorCtx);
    }
    try {
      let isBreakingContextBuilding = false;
      for (const onContext of beforeCallbacks.context) {
        const afterHookResult = await onContext({
          context,
          extendContext: (extension) => {
            Object.assign(context, extension);
          },
          breakContextBuilding: () => {
            isBreakingContextBuilding = true;
          }
        });
        if (typeof afterHookResult === "function") {
          afterCalls.push(afterHookResult);
        }
        if (isBreakingContextBuilding === true) {
          break;
        }
      }
      for (const afterCb of afterCalls) {
        afterCb({
          context,
          extendContext: (extension) => {
            Object.assign(context, extension);
          }
        });
      }
      return context;
    } catch (err) {
      let error = err;
      for (const errorCb of contextErrorHandlers) {
        errorCb({
          context,
          error,
          setError: (err2) => {
            error = err2;
          }
        });
      }
      throw error;
    }
  } : (initialContext) => (orchestratorCtx) => {
    if (orchestratorCtx) {
      Object.assign(initialContext, orchestratorCtx);
    }
    return initialContext;
  };
  const useCustomSubscribe = beforeCallbacks.subscribe.length;
  const customSubscribe = useCustomSubscribe ? makeSubscribe(async (args) => {
    let subscribeFn = subscribe2;
    const afterCalls = [];
    const subscribeErrorHandlers = [];
    const context = args.contextValue || {};
    let result;
    for (const onSubscribe of beforeCallbacks.subscribe) {
      const after = await onSubscribe({
        subscribeFn,
        setSubscribeFn: (newSubscribeFn) => {
          subscribeFn = newSubscribeFn;
        },
        extendContext: (extension) => {
          Object.assign(context, extension);
        },
        args,
        setResultAndStopExecution: (stopResult) => {
          result = stopResult;
        }
      });
      if (after) {
        if (after.onSubscribeResult) {
          afterCalls.push(after.onSubscribeResult);
        }
        if (after.onSubscribeError) {
          subscribeErrorHandlers.push(after.onSubscribeError);
        }
      }
      if (result !== undefined) {
        break;
      }
    }
    if (result === undefined) {
      result = await subscribeFn({
        ...args,
        contextValue: context
      });
    }
    if (!result) {
      return;
    }
    const onNextHandler = [];
    const onEndHandler = [];
    for (const afterCb of afterCalls) {
      const hookResult = afterCb({
        args,
        result,
        setResult: (newResult) => {
          result = newResult;
        }
      });
      if (hookResult) {
        if (hookResult.onNext) {
          onNextHandler.push(hookResult.onNext);
        }
        if (hookResult.onEnd) {
          onEndHandler.push(hookResult.onEnd);
        }
      }
    }
    if (onNextHandler.length && isAsyncIterable3(result)) {
      result = mapAsyncIterator3(result, async (result2) => {
        for (const onNext of onNextHandler) {
          await onNext({
            args,
            result: result2,
            setResult: (newResult) => result2 = newResult
          });
        }
        return result2;
      });
    }
    if (onEndHandler.length && isAsyncIterable3(result)) {
      result = finalAsyncIterator(result, () => {
        for (const onEnd of onEndHandler) {
          onEnd();
        }
      });
    }
    if (subscribeErrorHandlers.length && isAsyncIterable3(result)) {
      result = errorAsyncIterator(result, (err) => {
        let error = err;
        for (const handler of subscribeErrorHandlers) {
          handler({
            error,
            setError: (err2) => {
              error = err2;
            }
          });
        }
        throw error;
      });
    }
    return result;
  }) : makeSubscribe(subscribe2);
  const useCustomExecute = beforeCallbacks.execute.length;
  const customExecute = useCustomExecute ? makeExecute(async (args) => {
    let executeFn = execute2;
    let result;
    const afterCalls = [];
    const context = args.contextValue || {};
    for (const onExecute of beforeCallbacks.execute) {
      const after = await onExecute({
        executeFn,
        setExecuteFn: (newExecuteFn) => {
          executeFn = newExecuteFn;
        },
        setResultAndStopExecution: (stopResult) => {
          result = stopResult;
        },
        extendContext: (extension) => {
          if (typeof extension === "object") {
            Object.assign(context, extension);
          } else {
            throw new Error(`Invalid context extension provided! Expected "object", got: "${JSON.stringify(extension)}" (${typeof extension})`);
          }
        },
        args
      });
      if (after?.onExecuteDone) {
        afterCalls.push(after.onExecuteDone);
      }
      if (result !== undefined) {
        break;
      }
    }
    if (result === undefined) {
      result = await executeFn({
        ...args,
        contextValue: context
      });
    }
    const onNextHandler = [];
    const onEndHandler = [];
    for (const afterCb of afterCalls) {
      const hookResult = await afterCb({
        args,
        result,
        setResult: (newResult) => {
          result = newResult;
        }
      });
      if (hookResult) {
        if (hookResult.onNext) {
          onNextHandler.push(hookResult.onNext);
        }
        if (hookResult.onEnd) {
          onEndHandler.push(hookResult.onEnd);
        }
      }
    }
    if (onNextHandler.length && isAsyncIterable3(result)) {
      result = mapAsyncIterator3(result, async (result2) => {
        for (const onNext of onNextHandler) {
          await onNext({
            args,
            result: result2,
            setResult: (newResult) => {
              result2 = newResult;
            }
          });
        }
        return result2;
      });
    }
    if (onEndHandler.length && isAsyncIterable3(result)) {
      result = finalAsyncIterator(result, () => {
        for (const onEnd of onEndHandler) {
          onEnd();
        }
      });
    }
    return result;
  }) : makeExecute(execute2);
  initDone = true;
  if (schema5) {
    for (const [i, plugin] of plugins.entries()) {
      plugin.onSchemaChange && plugin.onSchemaChange({
        schema: schema5,
        replaceSchema: (modifiedSchema) => replaceSchema(modifiedSchema, i)
      });
    }
  }
  return {
    getCurrentSchema() {
      return schema5;
    },
    init,
    parse: customParse,
    validate: customValidate,
    execute: customExecute,
    subscribe: customSubscribe,
    contextFactory: customContextFactory
  };
}

// ../../node_modules/@envelop/core/esm/create.js
var notEmpty = function(value) {
  return value != null;
};
function envelop(options) {
  const plugins = options.plugins.filter(notEmpty);
  const orchestrator2 = createEnvelopOrchestrator({
    plugins
  });
  const getEnveloped = (initialContext = {}) => {
    const typedOrchestrator = orchestrator2;
    typedOrchestrator.init(initialContext);
    return {
      parse: typedOrchestrator.parse(initialContext),
      validate: typedOrchestrator.validate(initialContext),
      contextFactory: typedOrchestrator.contextFactory(initialContext),
      execute: typedOrchestrator.execute,
      subscribe: typedOrchestrator.subscribe,
      schema: typedOrchestrator.getCurrentSchema()
    };
  };
  getEnveloped._plugins = plugins;
  return getEnveloped;
}

// ../../node_modules/@envelop/core/esm/plugins/use-masked-errors.js
function isGraphQLError2(error) {
  return error instanceof Error && error.name === "GraphQLError";
}
function isOriginalGraphQLError2(error) {
  if (isGraphQLError2(error)) {
    if (error.originalError != null) {
      return isOriginalGraphQLError2(error.originalError);
    }
    return true;
  }
  return false;
}
var createSerializableGraphQLError = function(message, originalError, isDev) {
  const error = new Error(message);
  error.name = "GraphQLError";
  if (isDev) {
    const extensions = originalError instanceof Error ? { message: originalError.message, stack: originalError.stack } : { message: String(originalError) };
    Object.defineProperty(error, "extensions", {
      get() {
        return extensions;
      }
    });
  }
  Object.defineProperty(error, "toJSON", {
    value() {
      return {
        message: error.message,
        extensions: error.extensions
      };
    }
  });
  return error;
};
function useMaskedErrors(opts) {
  const maskError = opts?.maskError ?? defaultMaskError;
  const message = opts?.errorMessage || DEFAULT_ERROR_MESSAGE;
  const handleResult = makeHandleResult(maskError, message);
  return {
    onPluginInit(context) {
      context.registerContextErrorHandler(({ error, setError }) => {
        setError(maskError(error, message));
      });
    },
    onExecute() {
      return {
        onExecuteDone(payload) {
          return handleStreamOrSingleExecutionResult(payload, handleResult);
        }
      };
    },
    onSubscribe() {
      return {
        onSubscribeResult(payload) {
          return handleStreamOrSingleExecutionResult(payload, handleResult);
        },
        onSubscribeError({ error, setError }) {
          setError(maskError(error, message));
        }
      };
    }
  };
}
var DEFAULT_ERROR_MESSAGE = "Unexpected error.";
var createDefaultMaskError = (isDev) => (error, message) => {
  if (isOriginalGraphQLError2(error)) {
    return error;
  }
  return createSerializableGraphQLError(message, error, isDev);
};
var isDev = globalThis.process?.env?.NODE_ENV === "development";
var defaultMaskError = createDefaultMaskError(isDev);
var makeHandleResult = (maskError, message) => ({ result, setResult }) => {
  if (result.errors != null) {
    setResult({ ...result, errors: result.errors.map((error) => maskError(error, message)) });
  }
};

// ../../node_modules/@envelop/core/esm/plugins/use-extend-context.js
var useExtendContext = (contextFactory) => ({
  async onContextBuilding({ context, extendContext }) {
    extendContext(await contextFactory(context));
  }
});

// ../../node_modules/@envelop/core/esm/plugins/use-engine.js
var useEngine = (engine) => {
  return {
    onExecute: ({ setExecuteFn }) => {
      if (engine.execute) {
        setExecuteFn(engine.execute);
      }
    },
    onParse: ({ setParseFn }) => {
      if (engine.parse) {
        setParseFn(engine.parse);
      }
    },
    onValidate: ({ setValidationFn, addValidationRule }) => {
      if (engine.validate) {
        setValidationFn(engine.validate);
      }
      engine.specifiedRules?.map(addValidationRule);
    },
    onSubscribe: ({ setSubscribeFn }) => {
      if (engine.subscribe) {
        setSubscribeFn(engine.subscribe);
      }
    }
  };
};

// ../../node_modules/value-or-promise/build/module/ValueOrPromise.js
var isPromiseLike = function(object) {
  return object != null && typeof object.then === "function";
};
var defaultOnRejectedFn = (reason) => {
  throw reason;
};

class ValueOrPromise {
  state;
  constructor(executor2) {
    let value;
    try {
      value = executor2();
    } catch (reason) {
      this.state = { status: "rejected", value: reason };
      return;
    }
    if (isPromiseLike(value)) {
      this.state = { status: "pending", value };
      return;
    }
    this.state = { status: "fulfilled", value };
  }
  then(onFulfilled, onRejected) {
    const state = this.state;
    if (state.status === "pending") {
      return new ValueOrPromise(() => state.value.then(onFulfilled, onRejected));
    }
    const onRejectedFn = typeof onRejected === "function" ? onRejected : defaultOnRejectedFn;
    if (state.status === "rejected") {
      return new ValueOrPromise(() => onRejectedFn(state.value));
    }
    try {
      const onFulfilledFn = typeof onFulfilled === "function" ? onFulfilled : undefined;
      return onFulfilledFn === undefined ? new ValueOrPromise(() => state.value) : new ValueOrPromise(() => onFulfilledFn(state.value));
    } catch (e) {
      return new ValueOrPromise(() => onRejectedFn(e));
    }
  }
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  resolve() {
    const state = this.state;
    if (state.status === "pending") {
      return Promise.resolve(state.value);
    }
    if (state.status === "rejected") {
      throw state.value;
    }
    return state.value;
  }
  static all(valueOrPromises) {
    let rejected = false;
    let reason;
    let containsPromise = false;
    const values3 = [];
    for (const valueOrPromise of valueOrPromises) {
      const state = valueOrPromise.state;
      if (state.status === "rejected") {
        if (rejected) {
          continue;
        }
        rejected = true;
        reason = state.value;
        continue;
      }
      if (state.status === "pending") {
        containsPromise = true;
      }
      values3.push(state.value);
    }
    if (containsPromise) {
      if (rejected) {
        Promise.all(values3).catch(() => {
        });
        return new ValueOrPromise(() => {
          throw reason;
        });
      }
      return new ValueOrPromise(() => Promise.all(values3));
    }
    return new ValueOrPromise(() => values3);
  }
}
// ../../node_modules/@graphql-tools/executor/esm/execution/coerceError.js
function coerceError(error) {
  if (error instanceof Error) {
    return error;
  }
  if (typeof error === "object" && error != null) {
    if ("message" in error && typeof error.message === "string") {
      let errorOptions;
      if ("cause" in error) {
        errorOptions = { cause: error.cause };
      }
      const coercedError = new Error(error.message, errorOptions);
      if ("stack" in error && typeof error.stack === "string") {
        coercedError.stack = error.stack;
      }
      if ("name" in error && typeof error.name === "string") {
        coercedError.name = error.name;
      }
      return coercedError;
    }
  }
  return new Error(String(error));
}

// ../../node_modules/@graphql-tools/executor/esm/execution/flattenAsyncIterable.js
function flattenAsyncIterable(iterable) {
  const topIterator = iterable[Symbol.asyncIterator]();
  let currentNestedIterator;
  let waitForCurrentNestedIterator;
  let done = false;
  async function next() {
    if (done) {
      return { value: undefined, done: true };
    }
    try {
      if (!currentNestedIterator) {
        if (waitForCurrentNestedIterator) {
          await waitForCurrentNestedIterator;
          return await next();
        }
        let resolve;
        waitForCurrentNestedIterator = new Promise((r) => {
          resolve = r;
        });
        const topIteratorResult = await topIterator.next();
        if (topIteratorResult.done) {
          done = true;
          return await next();
        }
        currentNestedIterator = topIteratorResult.value[Symbol.asyncIterator]();
        waitForCurrentNestedIterator = undefined;
        resolve();
        return await next();
      }
      const rememberCurrentNestedIterator = currentNestedIterator;
      const nestedIteratorResult = await currentNestedIterator.next();
      if (!nestedIteratorResult.done) {
        return nestedIteratorResult;
      }
      if (currentNestedIterator === rememberCurrentNestedIterator) {
        currentNestedIterator = undefined;
      }
      return await next();
    } catch (err) {
      done = true;
      throw err;
    }
  }
  return {
    next,
    async return() {
      done = true;
      await Promise.all([currentNestedIterator?.return?.(), topIterator.return?.()]);
      return { value: undefined, done: true };
    },
    async throw(error) {
      done = true;
      await Promise.all([currentNestedIterator?.throw?.(error), topIterator.throw?.(error)]);
      throw error;
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// ../../node_modules/@graphql-tools/executor/esm/execution/invariant.js
function invariant13(condition, message) {
  if (!condition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}

// ../../node_modules/@graphql-tools/executor/esm/execution/promiseForObject.js
async function promiseForObject(object, signal) {
  const resolvedObject = Object.create(null);
  await new Promise((resolve, reject) => {
    signal?.addEventListener("abort", () => {
      reject(signal.reason);
    });
    Promise.all(Object.entries(object).map(async ([key, value]) => {
      resolvedObject[key] = await value;
    })).then(() => resolve(), reject);
  });
  return resolvedObject;
}

// ../../node_modules/@graphql-tools/executor/esm/execution/values.js
function getVariableValues2(schema5, varDefNodes, inputs, options) {
  const errors4 = [];
  const maxErrors = options?.maxErrors;
  try {
    const coerced = coerceVariableValues(schema5, varDefNodes, inputs, (error) => {
      if (maxErrors != null && errors4.length >= maxErrors) {
        throw createGraphQLError("Too many errors processing variables, error limit reached. Execution aborted.");
      }
      errors4.push(error);
    });
    if (errors4.length === 0) {
      return { coerced };
    }
  } catch (error) {
    errors4.push(error);
  }
  return { errors: errors4 };
}
var coerceVariableValues = function(schema5, varDefNodes, inputs, onError) {
  const coercedValues = {};
  for (const varDefNode of varDefNodes) {
    const varName = varDefNode.variable.name.value;
    const varType = typeFromAST(schema5, varDefNode.type);
    if (!isInputType(varType)) {
      const varTypeStr = print(varDefNode.type);
      onError(createGraphQLError(`Variable "\$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`, { nodes: varDefNode.type }));
      continue;
    }
    if (!hasOwnProperty2(inputs, varName)) {
      if (varDefNode.defaultValue) {
        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);
      } else if (isNonNullType(varType)) {
        const varTypeStr = inspect26(varType);
        onError(createGraphQLError(`Variable "\$${varName}" of required type "${varTypeStr}" was not provided.`, {
          nodes: varDefNode
        }));
      }
      continue;
    }
    const value = inputs[varName];
    if (value === null && isNonNullType(varType)) {
      const varTypeStr = inspect26(varType);
      onError(createGraphQLError(`Variable "\$${varName}" of non-null type "${varTypeStr}" must not be null.`, {
        nodes: varDefNode
      }));
      continue;
    }
    coercedValues[varName] = coerceInputValue(value, varType, (path, invalidValue, error) => {
      let prefix = `Variable "\$${varName}" got invalid value ` + inspect26(invalidValue);
      if (path.length > 0) {
        prefix += ` at "${varName}${printPathArray3(path)}"`;
      }
      onError(createGraphQLError(prefix + "; " + error.message, {
        nodes: varDefNode,
        originalError: error
      }));
    });
  }
  return coercedValues;
};

// ../../node_modules/@graphql-tools/executor/esm/execution/execute.js
function execute2(args) {
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext.map((e) => {
        Object.defineProperty(e, "extensions", {
          value: {
            ...e.extensions,
            http: {
              ...e.extensions?.["http"],
              status: 400
            }
          }
        });
        return e;
      })
    };
  }
  return executeImpl(exeContext);
}
var executeImpl = function(exeContext) {
  if (exeContext.signal?.aborted) {
    throw exeContext.signal.reason;
  }
  const result = new ValueOrPromise(() => executeOperation(exeContext)).then((data) => {
    const initialResult = buildResponse(data, exeContext.errors);
    if (exeContext.subsequentPayloads.size > 0) {
      return {
        initialResult: {
          ...initialResult,
          hasNext: true
        },
        subsequentResults: yieldSubsequentPayloads(exeContext)
      };
    }
    return initialResult;
  }, (error) => {
    if (exeContext.signal?.aborted) {
      throw exeContext.signal.reason;
    }
    if (error.errors) {
      exeContext.errors.push(...error.errors);
    } else {
      exeContext.errors.push(error);
    }
    return buildResponse(null, exeContext.errors);
  }).resolve();
  return result;
};
var buildResponse = function(data, errors4) {
  return errors4.length === 0 ? { data } : { errors: errors4, data };
};
function buildExecutionContext(args) {
  const { schema: schema5, document, rootValue, contextValue, variableValues: rawVariableValues, operationName, fieldResolver, typeResolver, subscribeFieldResolver, signal } = args;
  assertValidSchema(schema5);
  const fragments = getFragmentsFromDocument(document);
  let operation;
  for (const definition29 of document.definitions) {
    switch (definition29.kind) {
      case Kind.OPERATION_DEFINITION:
        if (operationName == null) {
          if (operation !== undefined) {
            return [
              createGraphQLError("Must provide operation name if query contains multiple operations.")
            ];
          }
          operation = definition29;
        } else if (definition29.name?.value === operationName) {
          operation = definition29;
        }
        break;
      default:
    }
  }
  if (operation == null) {
    if (operationName != null) {
      return [createGraphQLError(`Unknown operation named "${operationName}".`)];
    }
    return [createGraphQLError("Must provide an operation.")];
  }
  const variableDefinitions = operation.variableDefinitions ?? [];
  const coercedVariableValues = getVariableValues2(schema5, variableDefinitions, rawVariableValues ?? {}, {
    maxErrors: 50
  });
  if (coercedVariableValues.errors) {
    return coercedVariableValues.errors;
  }
  return {
    schema: schema5,
    fragments,
    rootValue,
    contextValue,
    operation,
    variableValues: coercedVariableValues.coerced,
    fieldResolver: fieldResolver ?? defaultFieldResolver2,
    typeResolver: typeResolver ?? defaultTypeResolver2,
    subscribeFieldResolver: subscribeFieldResolver ?? defaultFieldResolver2,
    subsequentPayloads: new Set,
    errors: [],
    signal
  };
}
var buildPerEventExecutionContext = function(exeContext, payload) {
  return {
    ...exeContext,
    rootValue: payload,
    subsequentPayloads: new Set,
    errors: []
  };
};
var executeOperation = function(exeContext) {
  const { operation, schema: schema5, fragments, variableValues, rootValue } = exeContext;
  const rootType = getDefinedRootType(schema5, operation.operation, [operation]);
  if (rootType == null) {
    createGraphQLError(`Schema is not configured to execute ${operation.operation} operation.`, {
      nodes: operation
    });
  }
  const { fields: rootFields, patches } = collectFields4(schema5, fragments, variableValues, rootType, operation.selectionSet);
  const path = undefined;
  let result;
  if (operation.operation === "mutation") {
    result = executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);
  } else {
    result = executeFields(exeContext, rootType, rootValue, path, rootFields);
  }
  for (const patch of patches) {
    const { label, fields: patchFields } = patch;
    executeDeferredFragment(exeContext, rootType, rootValue, patchFields, label, path);
  }
  return result;
};
var executeFieldsSerially = function(exeContext, parentType, sourceValue, path, fields5) {
  return promiseReduce(fields5, (results, [responseName, fieldNodes]) => {
    const fieldPath = addPath2(path, responseName, parentType.name);
    if (exeContext.signal?.aborted) {
      throw exeContext.signal.reason;
    }
    return new ValueOrPromise(() => executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath)).then((result) => {
      if (result === undefined) {
        return results;
      }
      results[responseName] = result;
      return results;
    });
  }, Object.create(null)).resolve();
};
var executeFields = function(exeContext, parentType, sourceValue, path, fields5, asyncPayloadRecord) {
  const results = Object.create(null);
  let containsPromise = false;
  try {
    for (const [responseName, fieldNodes] of fields5) {
      if (exeContext.signal?.aborted) {
        throw exeContext.signal.reason;
      }
      const fieldPath = addPath2(path, responseName, parentType.name);
      const result = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath, asyncPayloadRecord);
      if (result !== undefined) {
        results[responseName] = result;
        if (isPromise3(result)) {
          containsPromise = true;
        }
      }
    }
  } catch (error) {
    if (containsPromise) {
      return promiseForObject(results, exeContext.signal).finally(() => {
        throw error;
      });
    }
    throw error;
  }
  if (!containsPromise) {
    return results;
  }
  return promiseForObject(results, exeContext.signal);
};
var executeField = function(exeContext, parentType, source2, fieldNodes, path, asyncPayloadRecord) {
  const errors4 = asyncPayloadRecord?.errors ?? exeContext.errors;
  const fieldDef = getFieldDef2(exeContext.schema, parentType, fieldNodes[0]);
  if (!fieldDef) {
    return;
  }
  const returnType = fieldDef.type;
  const resolveFn = fieldDef.resolve ?? exeContext.fieldResolver;
  const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);
  try {
    const args = getArgumentValues2(fieldDef, fieldNodes[0], exeContext.variableValues);
    const contextValue = exeContext.contextValue;
    const result = resolveFn(source2, args, contextValue, info);
    let completed;
    if (isPromise3(result)) {
      completed = result.then((resolved) => completeValue(exeContext, returnType, fieldNodes, info, path, resolved, asyncPayloadRecord));
    } else {
      completed = completeValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
    }
    if (isPromise3(completed)) {
      return completed.then(undefined, (rawError) => {
        if (rawError instanceof AggregateError) {
          return new AggregateError(rawError.errors.map((rawErrorItem) => {
            rawErrorItem = coerceError(rawErrorItem);
            const error2 = locatedError(rawErrorItem, fieldNodes, pathToArray2(path));
            const handledError2 = handleFieldError(error2, returnType, errors4);
            filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
            return handledError2;
          }));
        }
        rawError = coerceError(rawError);
        const error = locatedError(rawError, fieldNodes, pathToArray2(path));
        const handledError = handleFieldError(error, returnType, errors4);
        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
        return handledError;
      });
    }
    return completed;
  } catch (rawError) {
    if (rawError instanceof AggregateError) {
      return new AggregateError(rawError.errors.map((rawErrorItem) => {
        const coercedError2 = coerceError(rawErrorItem);
        const error2 = locatedError(coercedError2, fieldNodes, pathToArray2(path));
        return handleFieldError(error2, returnType, errors4);
      }));
    }
    const coercedError = coerceError(rawError);
    const error = locatedError(coercedError, fieldNodes, pathToArray2(path));
    const handledError = handleFieldError(error, returnType, errors4);
    filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
    return handledError;
  }
};
function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
  return {
    fieldName: fieldDef.name,
    fieldNodes,
    returnType: fieldDef.type,
    parentType,
    path,
    schema: exeContext.schema,
    fragments: exeContext.fragments,
    rootValue: exeContext.rootValue,
    operation: exeContext.operation,
    variableValues: exeContext.variableValues
  };
}
var handleFieldError = function(error, returnType, errors4) {
  if (isNonNullType(returnType)) {
    throw error;
  }
  if (error.extensions?.[CRITICAL_ERROR]) {
    throw error;
  }
  errors4.push(error);
  return null;
};
var completeValue = function(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  if (result instanceof Error) {
    throw result;
  }
  if (isNonNullType(returnType)) {
    const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result, asyncPayloadRecord);
    if (completed === null) {
      throw new Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);
    }
    return completed;
  }
  if (result == null) {
    return null;
  }
  if (isListType(returnType)) {
    return completeListValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
  }
  if (isLeafType(returnType)) {
    return completeLeafValue(returnType, result);
  }
  if (isAbstractType(returnType)) {
    return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
  }
  if (isObjectType(returnType)) {
    return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord);
  }
  console.assert(false, "Cannot complete value of unexpected output type: " + inspect26(returnType));
};
var getStreamValues = function(exeContext, fieldNodes, path) {
  if (typeof path.key === "number") {
    return;
  }
  const stream = getDirectiveValues(GraphQLStreamDirective, fieldNodes[0], exeContext.variableValues);
  if (!stream) {
    return;
  }
  if (stream.if === false) {
    return;
  }
  invariant13(typeof stream["initialCount"] === "number", "initialCount must be a number");
  invariant13(stream["initialCount"] >= 0, "initialCount must be a positive integer");
  return {
    initialCount: stream["initialCount"],
    label: typeof stream["label"] === "string" ? stream["label"] : undefined
  };
};
async function completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path, iterator, asyncPayloadRecord) {
  exeContext.signal?.addEventListener("abort", () => {
    iterator.return?.();
  });
  const errors4 = asyncPayloadRecord?.errors ?? exeContext.errors;
  const stream = getStreamValues(exeContext, fieldNodes, path);
  let containsPromise = false;
  const completedResults = [];
  let index = 0;
  while (true) {
    if (stream && typeof stream.initialCount === "number" && index >= stream.initialCount) {
      executeStreamIterator(index, iterator, exeContext, fieldNodes, info, itemType, path, stream.label, asyncPayloadRecord);
      break;
    }
    const itemPath = addPath2(path, index, undefined);
    let iteration;
    try {
      iteration = await iterator.next();
      if (iteration.done) {
        break;
      }
    } catch (rawError) {
      const coercedError = coerceError(rawError);
      const error = locatedError(coercedError, fieldNodes, pathToArray2(itemPath));
      completedResults.push(handleFieldError(error, itemType, errors4));
      break;
    }
    if (completeListItemValue(iteration.value, completedResults, errors4, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {
      containsPromise = true;
    }
    index += 1;
  }
  return containsPromise ? Promise.all(completedResults) : completedResults;
}
var completeListValue = function(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  const itemType = returnType.ofType;
  const errors4 = asyncPayloadRecord?.errors ?? exeContext.errors;
  if (isAsyncIterable(result)) {
    const iterator = result[Symbol.asyncIterator]();
    return completeAsyncIteratorValue(exeContext, itemType, fieldNodes, info, path, iterator, asyncPayloadRecord);
  }
  if (!isIterableObject4(result)) {
    throw createGraphQLError(`Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`);
  }
  const stream = getStreamValues(exeContext, fieldNodes, path);
  let containsPromise = false;
  let previousAsyncPayloadRecord = asyncPayloadRecord;
  const completedResults = [];
  let index = 0;
  for (const item of result) {
    const itemPath = addPath2(path, index, undefined);
    if (stream && typeof stream.initialCount === "number" && index >= stream.initialCount) {
      previousAsyncPayloadRecord = executeStreamField(path, itemPath, item, exeContext, fieldNodes, info, itemType, stream.label, previousAsyncPayloadRecord);
      index++;
      continue;
    }
    if (completeListItemValue(item, completedResults, errors4, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord)) {
      containsPromise = true;
    }
    index++;
  }
  return containsPromise ? Promise.all(completedResults) : completedResults;
};
var completeListItemValue = function(item, completedResults, errors4, exeContext, itemType, fieldNodes, info, itemPath, asyncPayloadRecord) {
  try {
    let completedItem;
    if (isPromise3(item)) {
      completedItem = item.then((resolved) => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));
    } else {
      completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
    }
    if (isPromise3(completedItem)) {
      completedResults.push(completedItem.then(undefined, (rawError) => {
        rawError = coerceError(rawError);
        const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
        const handledError = handleFieldError(error, itemType, errors4);
        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
        return handledError;
      }));
      return true;
    }
    completedResults.push(completedItem);
  } catch (rawError) {
    const coercedError = coerceError(rawError);
    const error = locatedError(coercedError, fieldNodes, pathToArray2(itemPath));
    const handledError = handleFieldError(error, itemType, errors4);
    filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    completedResults.push(handledError);
  }
  return false;
};
var completeLeafValue = function(returnType, result) {
  let serializedResult;
  try {
    serializedResult = returnType.serialize(result);
  } catch (err) {
    if (err instanceof GraphQLError) {
      throw new Error(err.message);
    }
    throw err;
  }
  if (serializedResult == null) {
    throw new Error(`Expected \`${inspect26(returnType)}.serialize(${inspect26(result)})\` to ` + `return non-nullable value, returned: ${inspect26(serializedResult)}`);
  }
  return serializedResult;
};
var completeAbstractValue = function(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  const resolveTypeFn = returnType.resolveType ?? exeContext.typeResolver;
  const contextValue = exeContext.contextValue;
  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
  if (isPromise3(runtimeType)) {
    return runtimeType.then((resolvedRuntimeType) => completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result, asyncPayloadRecord));
  }
  return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result, asyncPayloadRecord);
};
var ensureValidRuntimeType = function(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
  if (runtimeTypeName == null) {
    throw createGraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`, { nodes: fieldNodes });
  }
  if (isObjectType(runtimeTypeName)) {
    if (versionInfo.major >= 16) {
      throw createGraphQLError("Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.");
    }
    runtimeTypeName = runtimeTypeName.name;
  }
  if (typeof runtimeTypeName !== "string") {
    throw createGraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with ` + `value ${inspect26(result)}, received "${inspect26(runtimeTypeName)}".`);
  }
  const runtimeType = exeContext.schema.getType(runtimeTypeName);
  if (runtimeType == null) {
    throw createGraphQLError(`Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`, { nodes: fieldNodes });
  }
  if (!isObjectType(runtimeType)) {
    throw createGraphQLError(`Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`, { nodes: fieldNodes });
  }
  if (!exeContext.schema.isSubType(returnType, runtimeType)) {
    throw createGraphQLError(`Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`, { nodes: fieldNodes });
  }
  return runtimeType;
};
var completeObjectValue = function(exeContext, returnType, fieldNodes, info, path, result, asyncPayloadRecord) {
  if (returnType.isTypeOf) {
    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
    if (isPromise3(isTypeOf)) {
      return isTypeOf.then((resolvedIsTypeOf) => {
        if (!resolvedIsTypeOf) {
          throw invalidReturnTypeError(returnType, result, fieldNodes);
        }
        return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord);
      });
    }
    if (!isTypeOf) {
      throw invalidReturnTypeError(returnType, result, fieldNodes);
    }
  }
  return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord);
};
var invalidReturnTypeError = function(returnType, result, fieldNodes) {
  return createGraphQLError(`Expected value of type "${returnType.name}" but got: ${inspect26(result)}.`, {
    nodes: fieldNodes
  });
};
var collectAndExecuteSubfields = function(exeContext, returnType, fieldNodes, path, result, asyncPayloadRecord) {
  const { fields: subFieldNodes, patches: subPatches } = collectSubfields4(exeContext, returnType, fieldNodes);
  const subFields = executeFields(exeContext, returnType, result, path, subFieldNodes, asyncPayloadRecord);
  for (const subPatch of subPatches) {
    const { label, fields: subPatchFieldNodes } = subPatch;
    executeDeferredFragment(exeContext, returnType, result, subPatchFieldNodes, label, path, asyncPayloadRecord);
  }
  return subFields;
};
function subscribe2(args) {
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext.map((e) => {
        Object.defineProperty(e, "extensions", {
          value: {
            ...e.extensions,
            http: {
              ...e.extensions?.["http"],
              status: 400
            }
          }
        });
        return e;
      })
    };
  }
  const resultOrStream = createSourceEventStreamImpl(exeContext);
  if (isPromise3(resultOrStream)) {
    return resultOrStream.then((resolvedResultOrStream) => mapSourceToResponse(exeContext, resolvedResultOrStream));
  }
  return mapSourceToResponse(exeContext, resultOrStream);
}
function flattenIncrementalResults(incrementalResults) {
  const subsequentIterator = incrementalResults.subsequentResults;
  let initialResultSent = false;
  let done = false;
  return {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      if (done) {
        return Promise.resolve({
          value: undefined,
          done
        });
      }
      if (initialResultSent) {
        return subsequentIterator.next();
      }
      initialResultSent = true;
      return Promise.resolve({
        value: incrementalResults.initialResult,
        done
      });
    },
    return() {
      done = true;
      return subsequentIterator.return();
    },
    throw(error) {
      done = true;
      return subsequentIterator.throw(error);
    }
  };
}
async function* ensureAsyncIterable(someExecutionResult) {
  if ("initialResult" in someExecutionResult) {
    yield* flattenIncrementalResults(someExecutionResult);
  } else {
    yield someExecutionResult;
  }
}
var mapSourceToResponse = function(exeContext, resultOrStream) {
  if (!isAsyncIterable(resultOrStream)) {
    return resultOrStream;
  }
  return flattenAsyncIterable(mapAsyncIterator(resultOrStream, async (payload) => ensureAsyncIterable(await executeImpl(buildPerEventExecutionContext(exeContext, payload))), (error) => {
    if (error instanceof AggregateError) {
      throw new AggregateError(error.errors.map((e) => wrapError(e, exeContext.operation)), error.message);
    }
    throw wrapError(error, exeContext.operation);
  }));
};
var wrapError = function(error, operation) {
  return createGraphQLError(error.message, {
    originalError: error,
    nodes: [operation]
  });
};
var createSourceEventStreamImpl = function(exeContext) {
  try {
    const eventStream = executeSubscription(exeContext);
    if (isPromise3(eventStream)) {
      return eventStream.then(undefined, (error) => ({ errors: [error] }));
    }
    return eventStream;
  } catch (error) {
    return { errors: [error] };
  }
};
var executeSubscription = function(exeContext) {
  const { schema: schema5, fragments, operation, variableValues, rootValue } = exeContext;
  const rootType = schema5.getSubscriptionType();
  if (rootType == null) {
    throw createGraphQLError("Schema is not configured to execute subscription operation.", {
      nodes: operation
    });
  }
  const { fields: rootFields } = collectFields4(schema5, fragments, variableValues, rootType, operation.selectionSet);
  const [responseName, fieldNodes] = [...rootFields.entries()][0];
  const fieldName = fieldNodes[0].name.value;
  const fieldDef = getFieldDef2(schema5, rootType, fieldNodes[0]);
  if (!fieldDef) {
    throw createGraphQLError(`The subscription field "${fieldName}" is not defined.`, {
      nodes: fieldNodes
    });
  }
  const path = addPath2(undefined, responseName, rootType.name);
  const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, rootType, path);
  try {
    const args = getArgumentValues2(fieldDef, fieldNodes[0], variableValues);
    const contextValue = exeContext.contextValue;
    const resolveFn = fieldDef.subscribe ?? exeContext.subscribeFieldResolver;
    const result = resolveFn(rootValue, args, contextValue, info);
    if (isPromise3(result)) {
      return result.then(assertEventStream).then(undefined, (error) => {
        throw locatedError(error, fieldNodes, pathToArray2(path));
      });
    }
    return assertEventStream(result, exeContext.signal);
  } catch (error) {
    throw locatedError(error, fieldNodes, pathToArray2(path));
  }
};
var assertEventStream = function(result, signal) {
  if (result instanceof Error) {
    throw result;
  }
  if (!isAsyncIterable(result)) {
    throw createGraphQLError("Subscription field must return Async Iterable. " + `Received: ${inspect26(result)}.`);
  }
  return {
    [Symbol.asyncIterator]() {
      const asyncIterator = result[Symbol.asyncIterator]();
      signal?.addEventListener("abort", () => {
        asyncIterator.return?.();
      });
      return asyncIterator;
    }
  };
};
var executeDeferredFragment = function(exeContext, parentType, sourceValue, fields5, label, path, parentContext) {
  const asyncPayloadRecord = new DeferredFragmentRecord({
    label,
    path,
    parentContext,
    exeContext
  });
  let promiseOrData;
  try {
    promiseOrData = executeFields(exeContext, parentType, sourceValue, path, fields5, asyncPayloadRecord);
    if (isPromise3(promiseOrData)) {
      promiseOrData = promiseOrData.then(null, (e) => {
        asyncPayloadRecord.errors.push(e);
        return null;
      });
    }
  } catch (e) {
    asyncPayloadRecord.errors.push(e);
    promiseOrData = null;
  }
  asyncPayloadRecord.addData(promiseOrData);
};
var executeStreamField = function(path, itemPath, item, exeContext, fieldNodes, info, itemType, label, parentContext) {
  const asyncPayloadRecord = new StreamRecord({
    label,
    path: itemPath,
    parentContext,
    exeContext
  });
  let completedItem;
  try {
    try {
      if (isPromise3(item)) {
        completedItem = item.then((resolved) => completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved, asyncPayloadRecord));
      } else {
        completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
      }
      if (isPromise3(completedItem)) {
        completedItem = completedItem.then(undefined, (rawError) => {
          rawError = coerceError(rawError);
          const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
          const handledError = handleFieldError(error, itemType, asyncPayloadRecord.errors);
          filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
          return handledError;
        });
      }
    } catch (rawError) {
      const coercedError = coerceError(rawError);
      const error = locatedError(coercedError, fieldNodes, pathToArray2(itemPath));
      completedItem = handleFieldError(error, itemType, asyncPayloadRecord.errors);
      filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    }
  } catch (error) {
    asyncPayloadRecord.errors.push(error);
    filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
    asyncPayloadRecord.addItems(null);
    return asyncPayloadRecord;
  }
  let completedItems;
  if (isPromise3(completedItem)) {
    completedItems = completedItem.then((value) => [value], (error) => {
      asyncPayloadRecord.errors.push(error);
      filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
      return null;
    });
  } else {
    completedItems = [completedItem];
  }
  asyncPayloadRecord.addItems(completedItems);
  return asyncPayloadRecord;
};
async function executeStreamIteratorItem(iterator, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath) {
  let item;
  try {
    const { value, done } = await iterator.next();
    if (done) {
      asyncPayloadRecord.setIsCompletedIterator();
      return { done, value: undefined };
    }
    item = value;
  } catch (rawError) {
    const coercedError = coerceError(rawError);
    const error = locatedError(coercedError, fieldNodes, pathToArray2(itemPath));
    const value = handleFieldError(error, itemType, asyncPayloadRecord.errors);
    return { done: true, value };
  }
  let completedItem;
  try {
    completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item, asyncPayloadRecord);
    if (isPromise3(completedItem)) {
      completedItem = completedItem.then(undefined, (rawError) => {
        const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
        const handledError = handleFieldError(error, itemType, asyncPayloadRecord.errors);
        filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
        return handledError;
      });
    }
    return { done: false, value: completedItem };
  } catch (rawError) {
    const error = locatedError(rawError, fieldNodes, pathToArray2(itemPath));
    const value = handleFieldError(error, itemType, asyncPayloadRecord.errors);
    filterSubsequentPayloads(exeContext, itemPath, asyncPayloadRecord);
    return { done: false, value };
  }
}
async function executeStreamIterator(initialIndex, iterator, exeContext, fieldNodes, info, itemType, path, label, parentContext) {
  let index = initialIndex;
  let previousAsyncPayloadRecord = parentContext ?? undefined;
  while (true) {
    const itemPath = addPath2(path, index, undefined);
    const asyncPayloadRecord = new StreamRecord({
      label,
      path: itemPath,
      parentContext: previousAsyncPayloadRecord,
      iterator,
      exeContext
    });
    let iteration;
    try {
      iteration = await executeStreamIteratorItem(iterator, exeContext, fieldNodes, info, itemType, asyncPayloadRecord, itemPath);
    } catch (error) {
      asyncPayloadRecord.errors.push(error);
      filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
      asyncPayloadRecord.addItems(null);
      if (iterator?.return) {
        iterator.return().catch(() => {
        });
      }
      return;
    }
    const { done, value: completedItem } = iteration;
    let completedItems;
    if (isPromise3(completedItem)) {
      completedItems = completedItem.then((value) => [value], (error) => {
        asyncPayloadRecord.errors.push(error);
        filterSubsequentPayloads(exeContext, path, asyncPayloadRecord);
        return null;
      });
    } else {
      completedItems = [completedItem];
    }
    asyncPayloadRecord.addItems(completedItems);
    if (done) {
      break;
    }
    previousAsyncPayloadRecord = asyncPayloadRecord;
    index++;
  }
}
var filterSubsequentPayloads = function(exeContext, nullPath, currentAsyncRecord) {
  const nullPathArray = pathToArray2(nullPath);
  exeContext.subsequentPayloads.forEach((asyncRecord) => {
    if (asyncRecord === currentAsyncRecord) {
      return;
    }
    for (let i = 0;i < nullPathArray.length; i++) {
      if (asyncRecord.path[i] !== nullPathArray[i]) {
        return;
      }
    }
    if (isStreamPayload(asyncRecord) && asyncRecord.iterator?.return) {
      asyncRecord.iterator.return().catch(() => {
      });
    }
    exeContext.subsequentPayloads.delete(asyncRecord);
  });
};
var getCompletedIncrementalResults = function(exeContext) {
  const incrementalResults = [];
  for (const asyncPayloadRecord of exeContext.subsequentPayloads) {
    const incrementalResult = {};
    if (!asyncPayloadRecord.isCompleted) {
      continue;
    }
    exeContext.subsequentPayloads.delete(asyncPayloadRecord);
    if (isStreamPayload(asyncPayloadRecord)) {
      const items = asyncPayloadRecord.items;
      if (asyncPayloadRecord.isCompletedIterator) {
        continue;
      }
      incrementalResult.items = items;
    } else {
      const data = asyncPayloadRecord.data;
      incrementalResult.data = data ?? null;
    }
    incrementalResult.path = asyncPayloadRecord.path;
    if (asyncPayloadRecord.label) {
      incrementalResult.label = asyncPayloadRecord.label;
    }
    if (asyncPayloadRecord.errors.length > 0) {
      incrementalResult.errors = asyncPayloadRecord.errors;
    }
    incrementalResults.push(incrementalResult);
  }
  return incrementalResults;
};
var yieldSubsequentPayloads = function(exeContext) {
  let isDone = false;
  const abortPromise = new Promise((_, reject) => {
    exeContext.signal?.addEventListener("abort", () => {
      isDone = true;
      reject(exeContext.signal?.reason);
    });
  });
  async function next() {
    if (isDone) {
      return { value: undefined, done: true };
    }
    await Promise.race([
      abortPromise,
      ...Array.from(exeContext.subsequentPayloads).map((p) => p.promise)
    ]);
    if (isDone) {
      return { value: undefined, done: true };
    }
    const incremental = getCompletedIncrementalResults(exeContext);
    const hasNext = exeContext.subsequentPayloads.size > 0;
    if (!incremental.length && hasNext) {
      return next();
    }
    if (!hasNext) {
      isDone = true;
    }
    return {
      value: incremental.length ? { incremental, hasNext } : { hasNext },
      done: false
    };
  }
  function returnStreamIterators() {
    const promises = [];
    exeContext.subsequentPayloads.forEach((asyncPayloadRecord) => {
      if (isStreamPayload(asyncPayloadRecord) && asyncPayloadRecord.iterator?.return) {
        promises.push(asyncPayloadRecord.iterator.return());
      }
    });
    return Promise.all(promises);
  }
  return {
    [Symbol.asyncIterator]() {
      return this;
    },
    next,
    async return() {
      await returnStreamIterators();
      isDone = true;
      return { value: undefined, done: true };
    },
    async throw(error) {
      await returnStreamIterators();
      isDone = true;
      return Promise.reject(error);
    }
  };
};
var isStreamPayload = function(asyncPayload) {
  return asyncPayload.type === "stream";
};
function getFieldDef2(schema5, parentType, fieldNode) {
  const fieldName = fieldNode.name.value;
  if (fieldName === SchemaMetaFieldDef.name && schema5.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  } else if (fieldName === TypeMetaFieldDef.name && schema5.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  } else if (fieldName === TypeNameMetaFieldDef.name) {
    return TypeNameMetaFieldDef;
  }
  return parentType.getFields()[fieldName];
}
var collectSubfields4 = memoize33((exeContext, returnType, fieldNodes) => collectSubFields(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));
var getFragmentsFromDocument = memoize1(function getFragmentsFromDocument2(document) {
  const fragments = Object.create(null);
  for (const definition29 of document.definitions) {
    if (definition29.kind === Kind.FRAGMENT_DEFINITION) {
      fragments[definition29.name.value] = definition29;
    }
  }
  return fragments;
});
var CRITICAL_ERROR = "CRITICAL_ERROR";
var defaultTypeResolver2 = function(value, contextValue, info, abstractType) {
  if (isObjectLike10(value) && typeof value["__typename"] === "string") {
    return value["__typename"];
  }
  const possibleTypes = info.schema.getPossibleTypes(abstractType);
  const promisedIsTypeOfResults = [];
  for (let i = 0;i < possibleTypes.length; i++) {
    const type2 = possibleTypes[i];
    if (type2.isTypeOf) {
      const isTypeOfResult = type2.isTypeOf(value, contextValue, info);
      if (isPromise3(isTypeOfResult)) {
        promisedIsTypeOfResults[i] = isTypeOfResult;
      } else if (isTypeOfResult) {
        return type2.name;
      }
    }
  }
  if (promisedIsTypeOfResults.length) {
    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
      for (let i = 0;i < isTypeOfResults.length; i++) {
        if (isTypeOfResults[i]) {
          return possibleTypes[i].name;
        }
      }
    });
  }
};
var defaultFieldResolver2 = function(source2, args, contextValue, info) {
  if (isObjectLike10(source2) || typeof source2 === "function") {
    const property = source2[info.fieldName];
    if (typeof property === "function") {
      return source2[info.fieldName](args, contextValue, info);
    }
    return property;
  }
};

class DeferredFragmentRecord {
  type;
  errors;
  label;
  path;
  promise;
  data;
  parentContext;
  isCompleted;
  _exeContext;
  _resolve;
  constructor(opts) {
    this.type = "defer";
    this.label = opts.label;
    this.path = pathToArray2(opts.path);
    this.parentContext = opts.parentContext;
    this.errors = [];
    this._exeContext = opts.exeContext;
    this._exeContext.subsequentPayloads.add(this);
    this.isCompleted = false;
    this.data = null;
    this.promise = new Promise((resolve) => {
      this._resolve = (MaybePromise) => {
        resolve(MaybePromise);
      };
    }).then((data) => {
      this.data = data;
      this.isCompleted = true;
    });
  }
  addData(data) {
    const parentData = this.parentContext?.promise;
    if (parentData) {
      this._resolve?.(parentData.then(() => data));
      return;
    }
    this._resolve?.(data);
  }
}

class StreamRecord {
  type;
  errors;
  label;
  path;
  items;
  promise;
  parentContext;
  iterator;
  isCompletedIterator;
  isCompleted;
  _exeContext;
  _resolve;
  constructor(opts) {
    this.type = "stream";
    this.items = null;
    this.label = opts.label;
    this.path = pathToArray2(opts.path);
    this.parentContext = opts.parentContext;
    this.iterator = opts.iterator;
    this.errors = [];
    this._exeContext = opts.exeContext;
    this._exeContext.subsequentPayloads.add(this);
    this.isCompleted = false;
    this.items = null;
    this.promise = new Promise((resolve) => {
      this._resolve = (MaybePromise) => {
        resolve(MaybePromise);
      };
    }).then((items) => {
      this.items = items;
      this.isCompleted = true;
    });
  }
  addItems(items) {
    const parentData = this.parentContext?.promise;
    if (parentData) {
      this._resolve?.(parentData.then(() => items));
      return;
    }
    this._resolve?.(items);
  }
  setIsCompletedIterator() {
    this.isCompletedIterator = true;
  }
}

// ../../node_modules/@graphql-tools/executor/esm/execution/normalizedExecutor.js
function normalizedExecutor(args) {
  const operationAST = getOperationAST(args.document, args.operationName);
  if (operationAST == null) {
    throw new Error("Must provide an operation.");
  }
  if (operationAST.operation === "subscription") {
    return subscribe2(args);
  }
  return new ValueOrPromise(() => execute2(args)).then((result) => {
    if ("initialResult" in result) {
      return flattenIncrementalResults(result);
    }
    return result;
  }).resolve();
}

// ../../node_modules/@whatwg-node/fetch/dist/node-ponyfill.js
var exports_node_ponyfill = {};
__export(exports_node_ponyfill, {
  fetch: () => {
    {
      return $fetch;
    }
  },
  crypto: () => {
    {
      return $crypto;
    }
  },
  createFetch: () => {
    {
      return $createFetch;
    }
  },
  btoa: () => {
    {
      return $btoa;
    }
  },
  WritableStream: () => {
    {
      return $WritableStream;
    }
  },
  URLSearchParams: () => {
    {
      return $URLSearchParams;
    }
  },
  URLPattern: () => {
    {
      return $URLPattern;
    }
  },
  URL: () => {
    {
      return $URL;
    }
  },
  TransformStream: () => {
    {
      return $TransformStream;
    }
  },
  TextEncoder: () => {
    {
      return $TextEncoder;
    }
  },
  TextDecoder: () => {
    {
      return $TextDecoder;
    }
  },
  Response: () => {
    {
      return $Response;
    }
  },
  Request: () => {
    {
      return $Request;
    }
  },
  ReadableStream: () => {
    {
      return $ReadableStream;
    }
  },
  Headers: () => {
    {
      return $Headers;
    }
  },
  FormData: () => {
    {
      return $FormData;
    }
  },
  File: () => {
    {
      return $File;
    }
  },
  DecompressionStream: () => {
    {
      return $DecompressionStream;
    }
  },
  CompressionStream: () => {
    {
      return $CompressionStream;
    }
  },
  Blob: () => {
    {
      return $Blob;
    }
  }
});
var createNodePonyfill = require_create_node_ponyfill();
var shouldSkipPonyfill = require_shouldSkipPonyfill();
var ponyfills = createNodePonyfill();
if (!shouldSkipPonyfill()) {
  try {
    const nodelibcurlName = "node-libcurl";
    globalThis.libcurl = globalThis.libcurl || import.meta.require(nodelibcurlName);
  } catch (e) {
  }
}
var $fetch = ponyfills.fetch;
var $Headers = ponyfills.Headers;
var $Request = ponyfills.Request;
var $Response = ponyfills.Response;
var $FormData = ponyfills.FormData;
var $ReadableStream = ponyfills.ReadableStream;
var $WritableStream = ponyfills.WritableStream;
var $TransformStream = ponyfills.TransformStream;
var $CompressionStream = ponyfills.CompressionStream;
var $DecompressionStream = ponyfills.DecompressionStream;
var $Blob = ponyfills.Blob;
var $File = ponyfills.File;
var $crypto = ponyfills.crypto;
var $btoa = ponyfills.btoa;
var $TextEncoder = ponyfills.TextEncoder;
var $TextDecoder = ponyfills.TextDecoder;
var $URLPattern = ponyfills.URLPattern;
var $URL = ponyfills.URL;
var $URLSearchParams = ponyfills.URLSearchParams;
var $createFetch = createNodePonyfill;

// ../../node_modules/@whatwg-node/server/esm/utils.js
function isAsyncIterable4(body) {
  return body != null && typeof body === "object" && typeof body[Symbol.asyncIterator] === "function";
}
var getPort = function(nodeRequest) {
  if (nodeRequest.socket?.localPort) {
    return nodeRequest.socket?.localPort;
  }
  const hostInHeader = nodeRequest.headers?.[":authority"] || nodeRequest.headers?.host;
  const portInHeader = hostInHeader?.split(":")?.[1];
  if (portInHeader) {
    return portInHeader;
  }
  return 80;
};
var getHostnameWithPort = function(nodeRequest) {
  if (nodeRequest.headers?.[":authority"]) {
    return nodeRequest.headers?.[":authority"];
  }
  if (nodeRequest.headers?.host) {
    return nodeRequest.headers?.host;
  }
  const port = getPort(nodeRequest);
  if (nodeRequest.hostname) {
    return nodeRequest.hostname + ":" + port;
  }
  const localIp = nodeRequest.socket?.localAddress;
  if (localIp && !localIp?.includes("::") && !localIp?.includes("ffff")) {
    return `${localIp}:${port}`;
  }
  return "localhost";
};
var buildFullUrl = function(nodeRequest) {
  const hostnameWithPort = getHostnameWithPort(nodeRequest);
  const protocol = nodeRequest.protocol || (nodeRequest.socket?.encrypted ? "https" : "http");
  const endpoint = nodeRequest.originalUrl || nodeRequest.url || "/graphql";
  return `${protocol}://${hostnameWithPort}${endpoint}`;
};
var isRequestBody = function(body) {
  const stringTag = body[Symbol.toStringTag];
  if (typeof body === "string" || stringTag === "Uint8Array" || stringTag === "Blob" || stringTag === "FormData" || stringTag === "URLSearchParams" || isAsyncIterable4(body)) {
    return true;
  }
  return false;
};
function normalizeNodeRequest(nodeRequest, RequestCtor) {
  const rawRequest = nodeRequest.raw || nodeRequest.req || nodeRequest;
  let fullUrl = buildFullUrl(rawRequest);
  if (nodeRequest.query) {
    const url = new $URL(fullUrl);
    for (const key in nodeRequest.query) {
      url.searchParams.set(key, nodeRequest.query[key]);
    }
    fullUrl = url.toString();
  }
  let signal;
  const nodeResponse = nodeRequestResponseMap.get(nodeRequest);
  nodeRequestResponseMap.delete(nodeRequest);
  let normalizedHeaders = nodeRequest.headers;
  if (nodeRequest.headers?.[":method"]) {
    normalizedHeaders = {};
    for (const key in nodeRequest.headers) {
      if (!key.startsWith(":")) {
        normalizedHeaders[key] = nodeRequest.headers[key];
      }
    }
  }
  if (nodeResponse?.once) {
    let sendAbortSignal;
    if (RequestCtor !== globalThis.Request) {
      signal = new ServerAdapterRequestAbortSignal;
      sendAbortSignal = () => signal.sendAbort();
    } else {
      const controller = new AbortController;
      signal = controller.signal;
      sendAbortSignal = () => controller.abort();
    }
    const closeEventListener = () => {
      if (signal && !signal.aborted) {
        rawRequest.aborted = true;
        sendAbortSignal();
      }
    };
    nodeResponse.once("error", closeEventListener);
    nodeResponse.once("close", closeEventListener);
    nodeResponse.once("finish", () => {
      nodeResponse.removeListener("close", closeEventListener);
    });
  }
  if (nodeRequest.method === "GET" || nodeRequest.method === "HEAD") {
    return new RequestCtor(fullUrl, {
      method: nodeRequest.method,
      headers: normalizedHeaders,
      signal
    });
  }
  const maybeParsedBody = nodeRequest.body;
  if (maybeParsedBody != null && Object.keys(maybeParsedBody).length > 0) {
    if (isRequestBody(maybeParsedBody)) {
      return new RequestCtor(fullUrl, {
        method: nodeRequest.method,
        headers: normalizedHeaders,
        body: maybeParsedBody,
        signal
      });
    }
    const request = new RequestCtor(fullUrl, {
      method: nodeRequest.method,
      headers: normalizedHeaders,
      signal
    });
    if (!request.headers.get("content-type")?.includes("json")) {
      request.headers.set("content-type", "application/json; charset=utf-8");
    }
    return new Proxy(request, {
      get: (target, prop, receiver) => {
        switch (prop) {
          case "json":
            return async () => maybeParsedBody;
          case "text":
            return async () => JSON.stringify(maybeParsedBody);
          default:
            return Reflect.get(target, prop, receiver);
        }
      }
    });
  }
  if (globalThis.process?.versions?.bun && isReadable(rawRequest)) {
    if (!bunNodeCompatModeWarned) {
      bunNodeCompatModeWarned = true;
      console.warn(`You use Bun Node compatibility mode, which is not recommended!
It will affect your performance. Please check our Bun integration recipe, and avoid using 'http' for your server implementation.`);
    }
    return new RequestCtor(fullUrl, {
      method: nodeRequest.method,
      headers: normalizedHeaders,
      duplex: "half",
      body: new ReadableStream({
        start(controller) {
          rawRequest.on("data", (chunk) => {
            controller.enqueue(chunk);
          });
          rawRequest.on("error", (e) => {
            controller.error(e);
          });
          rawRequest.on("end", () => {
            controller.close();
          });
        },
        cancel(e) {
          rawRequest.destroy(e);
        }
      }),
      signal
    });
  }
  return new RequestCtor(fullUrl, {
    method: nodeRequest.method,
    headers: normalizedHeaders,
    body: rawRequest,
    duplex: "half",
    signal
  });
}
function isReadable(stream) {
  return stream.read != null;
}
function isNodeRequest(request) {
  return isReadable(request);
}
function isServerResponse(stream) {
  return stream != null && stream.setHeader != null && stream.end != null && stream.once != null && stream.write != null;
}
function isFetchEvent(event) {
  return event != null && event.request != null && event.respondWith != null;
}
var configureSocket = function(rawRequest) {
  rawRequest?.socket?.setTimeout?.(0);
  rawRequest?.socket?.setNoDelay?.(true);
  rawRequest?.socket?.setKeepAlive?.(true);
};
var endResponse = function(serverResponse) {
  serverResponse.end(null, null, null);
};
async function sendAsyncIterable(serverResponse, asyncIterable) {
  let closed = false;
  const closeEventListener = () => {
    closed = true;
  };
  serverResponse.once("error", closeEventListener);
  serverResponse.once("close", closeEventListener);
  serverResponse.once("finish", () => {
    serverResponse.removeListener("close", closeEventListener);
  });
  for await (const chunk of asyncIterable) {
    if (closed) {
      break;
    }
    if (!serverResponse.write(chunk)) {
      if (closed) {
        break;
      }
      await new Promise((resolve) => serverResponse.once("drain", resolve));
    }
  }
  endResponse(serverResponse);
}
function sendNodeResponse(fetchResponse, serverResponse, nodeRequest) {
  if (serverResponse.closed || serverResponse.destroyed || serverResponse.writableEnded) {
    return;
  }
  if (!fetchResponse) {
    serverResponse.statusCode = 404;
    serverResponse.end();
    return;
  }
  serverResponse.statusCode = fetchResponse.status;
  serverResponse.statusMessage = fetchResponse.statusText;
  let setCookiesSet = false;
  fetchResponse.headers.forEach((value, key) => {
    if (key === "set-cookie") {
      if (setCookiesSet) {
        return;
      }
      setCookiesSet = true;
      const setCookies = fetchResponse.headers.getSetCookie?.();
      if (setCookies) {
        serverResponse.setHeader("set-cookie", setCookies);
        return;
      }
    }
    serverResponse.setHeader(key, value);
  });
  const bufOfRes = fetchResponse._buffer;
  if (bufOfRes) {
    serverResponse.write(bufOfRes);
    endResponse(serverResponse);
    return;
  }
  const fetchBody = fetchResponse.body;
  if (fetchBody == null) {
    endResponse(serverResponse);
    return;
  }
  if (fetchBody[Symbol.toStringTag] === "Uint8Array") {
    serverResponse.write(fetchBody);
    endResponse(serverResponse);
    return;
  }
  configureSocket(nodeRequest);
  if (isReadable(fetchBody)) {
    serverResponse.once("close", () => {
      fetchBody.destroy();
    });
    fetchBody.pipe(serverResponse);
    return;
  }
  if (isAsyncIterable4(fetchBody)) {
    return sendAsyncIterable(serverResponse, fetchBody);
  }
}
function isRequestInit(val) {
  return val != null && typeof val === "object" && (("body" in val) || ("cache" in val) || ("credentials" in val) || ("headers" in val) || ("integrity" in val) || ("keepalive" in val) || ("method" in val) || ("mode" in val) || ("redirect" in val) || ("referrer" in val) || ("referrerPolicy" in val) || ("signal" in val) || ("window" in val));
}
function completeAssign(...args) {
  const [target, ...sources] = args.filter((arg) => arg != null && typeof arg === "object");
  sources.forEach((source2) => {
    const descriptors = Object.getOwnPropertyNames(source2).reduce((descriptors2, key) => {
      const descriptor = Object.getOwnPropertyDescriptor(source2, key);
      if (descriptor) {
        descriptors2[key] = Object.getOwnPropertyDescriptor(source2, key);
      }
      return descriptors2;
    }, {});
    Object.getOwnPropertySymbols(source2).forEach((sym) => {
      const descriptor = Object.getOwnPropertyDescriptor(source2, sym);
      if (descriptor?.enumerable) {
        descriptors[sym] = descriptor;
      }
    });
    Object.defineProperties(target, descriptors);
  });
  return target;
}
function isPromise4(val) {
  return val?.then != null;
}
function iterateAsyncVoid(iterable, callback) {
  const iterator = iterable[Symbol.iterator]();
  let stopEarlyFlag = false;
  function stopEarlyFn() {
    stopEarlyFlag = true;
  }
  function iterate() {
    const { done: endOfIterator, value } = iterator.next();
    if (endOfIterator) {
      return;
    }
    const result$ = callback(value, stopEarlyFn);
    if (isPromise4(result$)) {
      return result$.then(() => {
        if (stopEarlyFlag) {
          return;
        }
        return iterate();
      });
    }
    if (stopEarlyFlag) {
      return;
    }
    return iterate();
  }
  return iterate();
}
function handleErrorFromRequestHandler(error, ResponseCtor) {
  return new ResponseCtor(error.stack || error.message || error.toString(), {
    status: error.status || 500
  });
}
function isolateObject(originalCtx, waitUntilPromises) {
  if (originalCtx == null) {
    if (waitUntilPromises == null) {
      return {};
    }
    originalCtx = {};
  }
  const extraProps = {};
  const deletedProps = new Set;
  return new Proxy(originalCtx, {
    get(originalCtx2, prop) {
      if (waitUntilPromises != null && prop === "waitUntil") {
        return function waitUntil(promise) {
          waitUntilPromises.push(promise.catch((err) => console.error(err)));
        };
      }
      const extraPropVal = extraProps[prop];
      if (extraPropVal != null) {
        if (typeof extraPropVal === "function") {
          return extraPropVal.bind(extraProps);
        }
        return extraPropVal;
      }
      if (deletedProps.has(prop)) {
        return;
      }
      return originalCtx2[prop];
    },
    set(_originalCtx, prop, value) {
      extraProps[prop] = value;
      return true;
    },
    has(originalCtx2, prop) {
      if (waitUntilPromises != null && prop === "waitUntil") {
        return true;
      }
      if (deletedProps.has(prop)) {
        return false;
      }
      if (prop in extraProps) {
        return true;
      }
      return prop in originalCtx2;
    },
    defineProperty(_originalCtx, prop, descriptor) {
      return Reflect.defineProperty(extraProps, prop, descriptor);
    },
    deleteProperty(_originalCtx, prop) {
      if (prop in extraProps) {
        return Reflect.deleteProperty(extraProps, prop);
      }
      deletedProps.add(prop);
      return true;
    },
    ownKeys(originalCtx2) {
      const extraKeys = Reflect.ownKeys(extraProps);
      const originalKeys = Reflect.ownKeys(originalCtx2);
      const deletedKeys = Array.from(deletedProps);
      const allKeys = new Set(extraKeys.concat(originalKeys.filter((keys) => !deletedKeys.includes(keys))));
      if (waitUntilPromises != null) {
        allKeys.add("waitUntil");
      }
      return Array.from(allKeys);
    },
    getOwnPropertyDescriptor(originalCtx2, prop) {
      if (prop in extraProps) {
        return Reflect.getOwnPropertyDescriptor(extraProps, prop);
      }
      if (deletedProps.has(prop)) {
        return;
      }
      return Reflect.getOwnPropertyDescriptor(originalCtx2, prop);
    }
  });
}
function createDeferredPromise() {
  let resolveFn;
  let rejectFn;
  const promise = new Promise(function deferredPromiseExecutor(resolve, reject) {
    resolveFn = resolve;
    rejectFn = reject;
  });
  return {
    promise,
    get resolve() {
      return resolveFn;
    },
    get reject() {
      return rejectFn;
    }
  };
}
function handleAbortSignalAndPromiseResponse(response$, abortSignal) {
  if (isPromise4(response$) && abortSignal) {
    const deferred$ = createDeferredPromise();
    abortSignal.addEventListener("abort", function abortSignalFetchErrorHandler() {
      deferred$.reject(abortSignal.reason);
    });
    response$.then(function fetchSuccessHandler(res) {
      deferred$.resolve(res);
    }).catch(function fetchErrorHandler(err) {
      deferred$.reject(err);
    });
    return deferred$.promise;
  }
  return response$;
}
class ServerAdapterRequestAbortSignal extends EventTarget {
  aborted = false;
  _onabort = null;
  reason;
  throwIfAborted() {
    if (this.aborted) {
      throw this.reason;
    }
  }
  sendAbort() {
    this.reason = new DOMException("This operation was aborted", "AbortError");
    this.aborted = true;
    this.dispatchEvent(new Event("abort"));
  }
  get onabort() {
    return this._onabort;
  }
  set onabort(value) {
    this._onabort = value;
    if (value) {
      this.addEventListener("abort", value);
    } else {
      this.removeEventListener("abort", value);
    }
  }
  any(signals) {
    return AbortSignal.any([...signals]);
  }
}
var bunNodeCompatModeWarned = false;
var nodeRequestResponseMap = new WeakMap;
var decompressedResponseMap = new WeakMap;
var supportedEncodingsByFetchAPI = new WeakMap;

// ../../node_modules/@whatwg-node/server/esm/uwebsockets.js
function isUWSResponse(res) {
  return !!res.onData;
}
function getRequestFromUWSRequest({ req, res, fetchAPI, signal }) {
  let body;
  const method = req.getMethod();
  if (method !== "get" && method !== "head") {
    let controller;
    body = new fetchAPI.ReadableStream({
      start(c) {
        controller = c;
      }
    });
    const readable = body.readable;
    if (readable) {
      signal.addEventListener("abort", () => {
        readable.push(null);
      });
      res.onData(function(ab, isLast) {
        const chunk = Buffer.from(ab, 0, ab.byteLength);
        readable.push(Buffer.from(chunk));
        if (isLast) {
          readable.push(null);
        }
      });
    } else {
      let closed = false;
      signal.addEventListener("abort", () => {
        if (!closed) {
          closed = true;
          controller.close();
        }
      });
      res.onData(function(ab, isLast) {
        const chunk = Buffer.from(ab, 0, ab.byteLength);
        controller.enqueue(Buffer.from(chunk));
        if (isLast) {
          closed = true;
          controller.close();
        }
      });
    }
  }
  const headers = new fetchAPI.Headers;
  req.forEach((key, value) => {
    headers.append(key, value);
  });
  let url = `http://localhost${req.getUrl()}`;
  const query = req.getQuery();
  if (query) {
    url += `?${query}`;
  }
  return new fetchAPI.Request(url, {
    method,
    headers,
    body,
    signal,
    duplex: "half"
  });
}
async function forwardResponseBodyToUWSResponse(uwsResponse, fetchResponse, signal) {
  for await (const chunk of fetchResponse.body) {
    if (signal.aborted) {
      return;
    }
    uwsResponse.cork(() => {
      uwsResponse.write(chunk);
    });
  }
  uwsResponse.cork(() => {
    uwsResponse.end();
  });
}
function sendResponseToUwsOpts(uwsResponse, fetchResponse, signal) {
  if (!fetchResponse) {
    uwsResponse.writeStatus("404 Not Found");
    uwsResponse.end();
    return;
  }
  const bufferOfRes = fetchResponse._buffer;
  if (signal.aborted) {
    return;
  }
  uwsResponse.cork(() => {
    uwsResponse.writeStatus(`${fetchResponse.status} ${fetchResponse.statusText}`);
    for (const [key, value] of fetchResponse.headers) {
      if (key !== "content-length") {
        if (key === "set-cookie") {
          const setCookies = fetchResponse.headers.getSetCookie?.();
          if (setCookies) {
            for (const setCookie of setCookies) {
              uwsResponse.writeHeader(key, setCookie);
            }
            continue;
          }
        }
        uwsResponse.writeHeader(key, value);
      }
    }
    if (bufferOfRes) {
      uwsResponse.end(bufferOfRes);
    }
  });
  if (bufferOfRes) {
    return;
  }
  if (!fetchResponse.body) {
    uwsResponse.end();
    return;
  }
  return forwardResponseBodyToUWSResponse(uwsResponse, fetchResponse, signal);
}

// ../../node_modules/@whatwg-node/server/esm/createServerAdapter.js
async function handleWaitUntils(waitUntilPromises) {
  await Promise.allSettled(waitUntilPromises);
}
var isRequestAccessible = function(serverContext) {
  try {
    return !!serverContext?.request;
  } catch {
    return false;
  }
};
var createServerAdapter = function(serverAdapterBaseObject, options) {
  const fetchAPI = {
    ...exports_node_ponyfill,
    ...options?.fetchAPI
  };
  const givenHandleRequest = typeof serverAdapterBaseObject === "function" ? serverAdapterBaseObject : serverAdapterBaseObject.handle;
  const onRequestHooks = [];
  const onResponseHooks = [];
  if (options?.plugins != null) {
    for (const plugin of options.plugins) {
      if (plugin.onRequest) {
        onRequestHooks.push(plugin.onRequest);
      }
      if (plugin.onResponse) {
        onResponseHooks.push(plugin.onResponse);
      }
    }
  }
  const handleRequest = onRequestHooks.length > 0 || onResponseHooks.length > 0 ? function handleRequest(request, serverContext) {
    let requestHandler = givenHandleRequest;
    let response;
    if (onRequestHooks.length === 0) {
      return handleEarlyResponse();
    }
    let url = new Proxy(EMPTY_OBJECT, {
      get(_target, prop, _receiver) {
        url = new fetchAPI.URL(request.url, "http://localhost");
        return Reflect.get(url, prop, url);
      }
    });
    const onRequestHooksIteration$ = iterateAsyncVoid(onRequestHooks, (onRequestHook, stopEarly) => onRequestHook({
      request,
      setRequest(newRequest) {
        request = newRequest;
      },
      serverContext,
      fetchAPI,
      url,
      requestHandler,
      setRequestHandler(newRequestHandler) {
        requestHandler = newRequestHandler;
      },
      endResponse(newResponse) {
        response = newResponse;
        if (newResponse) {
          stopEarly();
        }
      }
    }));
    function handleResponse(response2) {
      if (onResponseHooks.length === 0) {
        return response2;
      }
      const onResponseHookPayload = {
        request,
        response: response2,
        serverContext,
        setResponse(newResponse) {
          response2 = newResponse;
        },
        fetchAPI
      };
      const onResponseHooksIteration$ = iterateAsyncVoid(onResponseHooks, (onResponseHook) => onResponseHook(onResponseHookPayload));
      if (isPromise4(onResponseHooksIteration$)) {
        return onResponseHooksIteration$.then(() => response2);
      }
      return response2;
    }
    function handleEarlyResponse() {
      if (!response) {
        const response$ = requestHandler(request, serverContext);
        if (isPromise4(response$)) {
          return response$.then(handleResponse);
        }
        return handleResponse(response$);
      }
      return handleResponse(response);
    }
    if (isPromise4(onRequestHooksIteration$)) {
      return onRequestHooksIteration$.then(handleEarlyResponse);
    }
    return handleEarlyResponse();
  } : givenHandleRequest;
  function handleNodeRequest(nodeRequest, ...ctx) {
    const serverContext = ctx.length > 1 ? completeAssign(...ctx) : ctx[0] || {};
    const request = normalizeNodeRequest(nodeRequest, fetchAPI.Request);
    return handleRequest(request, serverContext);
  }
  function handleNodeRequestAndResponse(nodeRequest, nodeResponseOrContainer, ...ctx) {
    const nodeResponse = nodeResponseOrContainer.raw || nodeResponseOrContainer;
    nodeRequestResponseMap.set(nodeRequest, nodeResponse);
    return handleNodeRequest(nodeRequest, ...ctx);
  }
  function requestListener(nodeRequest, nodeResponse, ...ctx) {
    const waitUntilPromises = [];
    const defaultServerContext = {
      req: nodeRequest,
      res: nodeResponse,
      waitUntil(cb) {
        waitUntilPromises.push(cb.catch((err) => console.error(err)));
      }
    };
    let response$;
    try {
      response$ = handleNodeRequestAndResponse(nodeRequest, nodeResponse, defaultServerContext, ...ctx);
    } catch (err) {
      response$ = handleErrorFromRequestHandler(err, fetchAPI.Response);
    }
    if (isPromise4(response$)) {
      return response$.catch((e) => handleErrorFromRequestHandler(e, fetchAPI.Response)).then((response) => sendNodeResponse(response, nodeResponse, nodeRequest)).catch((err) => {
        console.error(`Unexpected error while handling request: ${err.message || err}`);
      });
    }
    try {
      return sendNodeResponse(response$, nodeResponse, nodeRequest);
    } catch (err) {
      console.error(`Unexpected error while handling request: ${err.message || err}`);
    }
  }
  function handleUWS(res, req, ...ctx) {
    const waitUntilPromises = [];
    const defaultServerContext = {
      res,
      req,
      waitUntil(cb) {
        waitUntilPromises.push(cb.catch((err) => console.error(err)));
      }
    };
    const filteredCtxParts = ctx.filter((partCtx) => partCtx != null);
    const serverContext = filteredCtxParts.length > 0 ? completeAssign(defaultServerContext, ...ctx) : defaultServerContext;
    const signal = new ServerAdapterRequestAbortSignal;
    const originalResEnd = res.end.bind(res);
    let resEnded = false;
    res.end = function(data) {
      resEnded = true;
      return originalResEnd(data);
    };
    const originalOnAborted = res.onAborted.bind(res);
    originalOnAborted(function() {
      signal.sendAbort();
    });
    res.onAborted = function(cb) {
      signal.addEventListener("abort", cb);
    };
    const request = getRequestFromUWSRequest({
      req,
      res,
      fetchAPI,
      signal
    });
    let response$;
    try {
      response$ = handleRequest(request, serverContext);
    } catch (err) {
      response$ = handleErrorFromRequestHandler(err, fetchAPI.Response);
    }
    if (isPromise4(response$)) {
      return response$.catch((e) => handleErrorFromRequestHandler(e, fetchAPI.Response)).then((response) => {
        if (!signal.aborted && !resEnded) {
          return sendResponseToUwsOpts(res, response, signal);
        }
      }).catch((err) => {
        console.error(`Unexpected error while handling request: \n${err.stack || err.message || err}`);
      });
    }
    try {
      if (!signal.aborted && !resEnded) {
        return sendResponseToUwsOpts(res, response$, signal);
      }
    } catch (err) {
      console.error(`Unexpected error while handling request: \n${err.stack || err.message || err}`);
    }
  }
  function handleEvent(event, ...ctx) {
    if (!event.respondWith || !event.request) {
      throw new TypeError(`Expected FetchEvent, got ${event}`);
    }
    const filteredCtxParts = ctx.filter((partCtx) => partCtx != null);
    const serverContext = filteredCtxParts.length > 0 ? completeAssign({}, event, ...filteredCtxParts) : isolateObject(event);
    const response$ = handleRequest(event.request, serverContext);
    event.respondWith(response$);
  }
  function handleRequestWithWaitUntil(request, ...ctx) {
    const filteredCtxParts = ctx.filter((partCtx) => partCtx != null);
    let waitUntilPromises;
    const serverContext = filteredCtxParts.length > 1 ? completeAssign({}, ...filteredCtxParts) : isolateObject(filteredCtxParts[0], filteredCtxParts[0] == null || filteredCtxParts[0].waitUntil == null ? waitUntilPromises = [] : undefined);
    const response$ = handleRequest(request, serverContext);
    if (waitUntilPromises?.length) {
      return handleWaitUntils(waitUntilPromises).then(() => response$);
    }
    return response$;
  }
  const fetchFn = (input, ...maybeCtx) => {
    if (typeof input === "string" || "href" in input) {
      const [initOrCtx, ...restOfCtx] = maybeCtx;
      if (isRequestInit(initOrCtx)) {
        const request2 = new fetchAPI.Request(input, initOrCtx);
        const res$2 = handleRequestWithWaitUntil(request2, ...restOfCtx);
        return handleAbortSignalAndPromiseResponse(res$2, initOrCtx?.signal);
      }
      const request = new fetchAPI.Request(input);
      return handleRequestWithWaitUntil(request, ...maybeCtx);
    }
    const res$ = handleRequestWithWaitUntil(input, ...maybeCtx);
    return handleAbortSignalAndPromiseResponse(res$, input._signal);
  };
  const genericRequestHandler = (input, ...maybeCtx) => {
    const [initOrCtxOrRes, ...restOfCtx] = maybeCtx;
    if (isNodeRequest(input)) {
      if (!isServerResponse(initOrCtxOrRes)) {
        throw new TypeError(`Expected ServerResponse, got ${initOrCtxOrRes}`);
      }
      return requestListener(input, initOrCtxOrRes, ...restOfCtx);
    }
    if (isUWSResponse(input)) {
      return handleUWS(input, initOrCtxOrRes, ...restOfCtx);
    }
    if (isServerResponse(initOrCtxOrRes)) {
      throw new TypeError("Got Node response without Node request");
    }
    if (isRequestAccessible(input)) {
      if (isFetchEvent(input)) {
        return handleEvent(input, ...maybeCtx);
      }
      return handleRequestWithWaitUntil(input.request, input, ...maybeCtx);
    }
    return fetchFn(input, ...maybeCtx);
  };
  const adapterObj = {
    handleRequest: handleRequestWithWaitUntil,
    fetch: fetchFn,
    handleNodeRequest,
    handleNodeRequestAndResponse,
    requestListener,
    handleEvent,
    handleUWS,
    handle: genericRequestHandler
  };
  const serverAdapter = new Proxy(genericRequestHandler, {
    has: (_, prop) => {
      return prop in adapterObj || prop in genericRequestHandler || serverAdapterBaseObject && prop in serverAdapterBaseObject;
    },
    get: (_, prop) => {
      const adapterProp = adapterObj[prop];
      if (adapterProp) {
        if (adapterProp.bind) {
          return adapterProp.bind(adapterObj);
        }
        return adapterProp;
      }
      const handleProp = genericRequestHandler[prop];
      if (handleProp) {
        if (handleProp.bind) {
          return handleProp.bind(genericRequestHandler);
        }
        return handleProp;
      }
      if (serverAdapterBaseObject) {
        const serverAdapterBaseObjectProp = serverAdapterBaseObject[prop];
        if (serverAdapterBaseObjectProp) {
          if (serverAdapterBaseObjectProp.bind) {
            return function(...args) {
              const returnedVal = serverAdapterBaseObject[prop](...args);
              if (returnedVal === serverAdapterBaseObject) {
                return serverAdapter;
              }
              return returnedVal;
            };
          }
          return serverAdapterBaseObjectProp;
        }
      }
    },
    apply(_, __, args) {
      return genericRequestHandler(...args);
    }
  });
  return serverAdapter;
};
var EMPTY_OBJECT = {};

// ../../node_modules/@whatwg-node/server/esm/plugins/useCors.js
function getCORSHeadersByRequestAndOptions(request, corsOptions) {
  const currentOrigin = request.headers.get("origin");
  if (corsOptions === false || currentOrigin == null) {
    return null;
  }
  const headers = {};
  if (corsOptions.origin == null || corsOptions.origin.length === 0 || corsOptions.origin.includes("*")) {
    headers["Access-Control-Allow-Origin"] = currentOrigin;
    headers["Vary"] = "Origin";
  } else if (typeof corsOptions.origin === "string") {
    headers["Access-Control-Allow-Origin"] = corsOptions.origin;
  } else if (Array.isArray(corsOptions.origin)) {
    if (corsOptions.origin.length === 1) {
      headers["Access-Control-Allow-Origin"] = corsOptions.origin[0];
    } else if (corsOptions.origin.includes(currentOrigin)) {
      headers["Access-Control-Allow-Origin"] = currentOrigin;
      headers["Vary"] = "Origin";
    } else {
      headers["Access-Control-Allow-Origin"] = "null";
    }
  }
  if (corsOptions.methods?.length) {
    headers["Access-Control-Allow-Methods"] = corsOptions.methods.join(", ");
  } else {
    const requestMethod = request.headers.get("access-control-request-method");
    if (requestMethod) {
      headers["Access-Control-Allow-Methods"] = requestMethod;
    }
  }
  if (corsOptions.allowedHeaders?.length) {
    headers["Access-Control-Allow-Headers"] = corsOptions.allowedHeaders.join(", ");
  } else {
    const requestHeaders = request.headers.get("access-control-request-headers");
    if (requestHeaders) {
      headers["Access-Control-Allow-Headers"] = requestHeaders;
      if (headers["Vary"]) {
        headers["Vary"] += ", Access-Control-Request-Headers";
      } else {
        headers["Vary"] = "Access-Control-Request-Headers";
      }
    }
  }
  if (corsOptions.credentials != null) {
    if (corsOptions.credentials === true) {
      headers["Access-Control-Allow-Credentials"] = "true";
    }
  } else if (headers["Access-Control-Allow-Origin"] !== "*") {
    headers["Access-Control-Allow-Credentials"] = "true";
  }
  if (corsOptions.exposedHeaders) {
    headers["Access-Control-Expose-Headers"] = corsOptions.exposedHeaders.join(", ");
  }
  if (corsOptions.maxAge) {
    headers["Access-Control-Max-Age"] = corsOptions.maxAge.toString();
  }
  return headers;
}
async function getCORSResponseHeaders(request, corsOptionsFactory, serverContext) {
  const corsOptions = await corsOptionsFactory(request, serverContext);
  return getCORSHeadersByRequestAndOptions(request, corsOptions);
}
function useCORS(options) {
  let corsOptionsFactory = () => ({});
  if (options != null) {
    if (typeof options === "function") {
      corsOptionsFactory = options;
    } else if (typeof options === "object") {
      const corsOptions = {
        ...options
      };
      corsOptionsFactory = () => corsOptions;
    } else if (options === false) {
      corsOptionsFactory = () => false;
    }
  }
  return {
    onRequest({ request, fetchAPI, endResponse: endResponse2 }) {
      if (request.method.toUpperCase() === "OPTIONS") {
        const response = new fetchAPI.Response(null, {
          status: 204,
          headers: {
            "Content-Length": "0"
          }
        });
        endResponse2(response);
      }
    },
    async onResponse({ request, serverContext, response }) {
      const headers = await getCORSResponseHeaders(request, corsOptionsFactory, serverContext);
      if (headers != null) {
        for (const headerName in headers) {
          response.headers.set(headerName, headers[headerName]);
        }
      }
    }
  };
}

// ../../node_modules/@whatwg-node/server/esm/plugins/useErrorHandling.js
function createDefaultErrorHandler(ResponseCtor = $Response) {
  return function defaultErrorHandler(e) {
    if (e.details || e.status || e.headers || e.name === "HTTPError") {
      return new ResponseCtor(typeof e.details === "object" ? JSON.stringify(e.details) : e.message, {
        status: e.status,
        headers: e.headers || {}
      });
    }
    console.error(e);
    return createDefaultErrorResponse(ResponseCtor);
  };
}
var createDefaultErrorResponse = function(ResponseCtor) {
  if (ResponseCtor.error) {
    return ResponseCtor.error();
  }
  return new ResponseCtor(null, { status: 500 });
};
function useErrorHandling(onError) {
  return {
    onRequest({ requestHandler, setRequestHandler, fetchAPI }) {
      const errorHandler = onError || createDefaultErrorHandler(fetchAPI.Response);
      setRequestHandler(function handlerWithErrorHandling(request, serverContext) {
        try {
          const response$ = requestHandler(request, serverContext);
          if (isPromise4(response$)) {
            return response$.catch((e) => errorHandler(e, request, serverContext) || createDefaultErrorResponse(fetchAPI.Response));
          }
          return response$;
        } catch (e) {
          return errorHandler(e, request, serverContext) || createDefaultErrorResponse(fetchAPI.Response);
        }
      });
    }
  };
}

// ../../node_modules/graphql-yoga/esm/plugins/request-parser/utils.js
function handleURLSearchParams(searchParams) {
  const operationName = searchParams.get("operationName") || undefined;
  const query = searchParams.get("query") || undefined;
  const variablesStr = searchParams.get("variables") || undefined;
  const extensionsStr = searchParams.get("extensions") || undefined;
  return {
    operationName,
    query,
    variables: variablesStr ? JSON.parse(variablesStr) : undefined,
    extensions: extensionsStr ? JSON.parse(extensionsStr) : undefined
  };
}
function parseURLSearchParams(requestBody) {
  const searchParams = new $URLSearchParams(requestBody);
  return handleURLSearchParams(searchParams);
}
function isContentTypeMatch(request, expectedContentType) {
  let contentType = request.headers.get("content-type");
  contentType = contentType?.split(",")[0] || null;
  return contentType === expectedContentType || !!contentType?.startsWith(`${expectedContentType};`);
}

// ../../node_modules/graphql-yoga/esm/plugins/request-parser/get.js
function isGETRequest(request) {
  return request.method === "GET";
}
function parseGETRequest(request) {
  const [, queryString = ""] = request.url.split("?");
  const searchParams = new $URLSearchParams(queryString);
  return handleURLSearchParams(searchParams);
}

// ../../node_modules/graphql-yoga/esm/plugins/request-parser/post-form-url-encoded.js
function isPOSTFormUrlEncodedRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "application/x-www-form-urlencoded");
}
async function parsePOSTFormUrlEncodedRequest(request) {
  const requestBody = await request.text();
  return parseURLSearchParams(requestBody);
}

// ../../node_modules/graphql-yoga/esm/plugins/request-parser/post-graphql-string.js
function isPOSTGraphQLStringRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "application/graphql");
}
async function parsePOSTGraphQLStringRequest(request) {
  const requestBody = await request.text();
  return {
    query: requestBody
  };
}

// ../../node_modules/graphql-yoga/esm/plugins/request-parser/post-json.js
function isPOSTJsonRequest(request) {
  return request.method === "POST" && (isContentTypeMatch(request, "application/json") || isContentTypeMatch(request, "application/graphql+json"));
}
async function parsePOSTJsonRequest(request) {
  let requestBody;
  try {
    requestBody = await request.json();
  } catch (err) {
    const extensions = {
      http: {
        spec: true,
        status: 400
      }
    };
    if (err instanceof Error) {
      extensions.originalError = {
        name: err.name,
        message: err.message
      };
    }
    throw createGraphQLError("POST body sent invalid JSON.", {
      extensions
    });
  }
  if (requestBody == null) {
    throw createGraphQLError(`POST body is expected to be object but received ${requestBody}`, {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  const requestBodyTypeof = typeof requestBody;
  if (requestBodyTypeof !== "object") {
    throw createGraphQLError(`POST body is expected to be object but received ${requestBodyTypeof}`, {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  return requestBody;
}

// ../../node_modules/dset/dist/index.mjs
function dset(obj, keys, val) {
  keys.split && (keys = keys.split("."));
  var i = 0, l = keys.length, t = obj, x, k;
  while (i < l) {
    k = "" + keys[i++];
    if (k === "__proto__" || k === "constructor" || k === "prototype")
      break;
    t = t[k] = i === l ? val : typeof (x = t[k]) === typeof keys ? x : keys[i] * 0 !== 0 || !!~("" + keys[i]).indexOf(".") ? {} : [];
  }
}

// ../../node_modules/graphql-yoga/esm/plugins/request-parser/post-multipart.js
function isPOSTMultipartRequest(request) {
  return request.method === "POST" && isContentTypeMatch(request, "multipart/form-data");
}
async function parsePOSTMultipartRequest(request) {
  let requestBody;
  try {
    requestBody = await request.formData();
  } catch (e) {
    if (e instanceof Error && e.message.startsWith("File size limit exceeded: ")) {
      throw createGraphQLError(e.message, {
        extensions: {
          http: {
            status: 413
          }
        }
      });
    }
    throw e;
  }
  const operationsStr = requestBody.get("operations");
  if (!operationsStr) {
    throw createGraphQLError('Missing multipart form field "operations"');
  }
  if (typeof operationsStr !== "string") {
    throw createGraphQLError('Multipart form field "operations" must be a string');
  }
  let operations;
  try {
    operations = JSON.parse(operationsStr);
  } catch (err) {
    throw createGraphQLError('Multipart form field "operations" must be a valid JSON string');
  }
  const mapStr = requestBody.get("map");
  if (mapStr != null) {
    if (typeof mapStr !== "string") {
      throw createGraphQLError('Multipart form field "map" must be a string');
    }
    let map;
    try {
      map = JSON.parse(mapStr);
    } catch (err) {
      throw createGraphQLError('Multipart form field "map" must be a valid JSON string');
    }
    for (const fileIndex in map) {
      const file = requestBody.get(fileIndex);
      const keys = map[fileIndex];
      for (const key of keys) {
        dset(operations, key, file);
      }
    }
  }
  return operations;
}

// ../../node_modules/graphql-yoga/esm/plugins/request-validation/use-check-graphql-query-params.js
function assertInvalidParams(params) {
  if (params == null || typeof params !== "object") {
    throw createGraphQLError('Invalid "params" in the request body', {
      extensions: {
        http: {
          spec: true,
          status: 400
        }
      }
    });
  }
  for (const paramKey in params) {
    if (params[paramKey] == null) {
      continue;
    }
    if (!expectedParameters.has(paramKey)) {
      throw createGraphQLError(`Unexpected parameter "${paramKey}" in the request body.`, {
        extensions: {
          http: {
            status: 400
          }
        }
      });
    }
  }
}
function checkGraphQLQueryParams(params) {
  if (!isObject2(params)) {
    throw createGraphQLError(`Expected params to be an object but given ${extendedTypeof(params)}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  assertInvalidParams(params);
  if (params.query == null) {
    throw createGraphQLError("Must provide query string.", {
      extensions: {
        http: {
          spec: true,
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const queryType = extendedTypeof(params.query);
  if (queryType !== "string") {
    throw createGraphQLError(`Expected "query" param to be a string, but given ${queryType}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const variablesParamType = extendedTypeof(params.variables);
  if (!["object", "null", "undefined"].includes(variablesParamType)) {
    throw createGraphQLError(`Expected "variables" param to be empty or an object, but given ${variablesParamType}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  const extensionsParamType = extendedTypeof(params.extensions);
  if (!["object", "null", "undefined"].includes(extensionsParamType)) {
    throw createGraphQLError(`Expected "extensions" param to be empty or an object, but given ${extensionsParamType}.`, {
      extensions: {
        http: {
          status: 400,
          headers: {
            Allow: "GET, POST"
          }
        }
      }
    });
  }
  return params;
}
function useCheckGraphQLQueryParams() {
  return {
    onParams({ params }) {
      checkGraphQLQueryParams(params);
    }
  };
}
var extendedTypeof = function(val) {
  if (val === null) {
    return "null";
  }
  if (Array.isArray(val)) {
    return "array";
  }
  return typeof val;
};
var isObject2 = function(val) {
  return extendedTypeof(val) === "object";
};
var expectedParameters = new Set(["query", "variables", "operationName", "extensions"]);

// ../../node_modules/graphql-yoga/esm/plugins/request-validation/use-check-method-for-graphql.js
function isValidMethodForGraphQL(method) {
  return method === "GET" || method === "POST";
}
function useCheckMethodForGraphQL() {
  return {
    onRequestParse({ request }) {
      if (!isValidMethodForGraphQL(request.method)) {
        throw createGraphQLError("GraphQL only supports GET and POST requests.", {
          extensions: {
            http: {
              status: 405,
              headers: {
                Allow: "GET, POST"
              }
            }
          }
        });
      }
    }
  };
}

// ../../node_modules/graphql-yoga/esm/plugins/request-validation/use-http-validation-error.js
function useHTTPValidationError() {
  return {
    onValidate() {
      return ({ valid, result }) => {
        if (!valid) {
          for (const error of result) {
            error.extensions.http = {
              ...error.extensions.http,
              spec: error.extensions.http?.spec ?? true,
              status: error.extensions.http?.status ?? 400
            };
          }
        }
      };
    }
  };
}

// ../../node_modules/graphql-yoga/esm/plugins/request-validation/use-limit-batching.js
function useLimitBatching(limit) {
  return {
    onRequestParse() {
      return {
        onRequestParseDone({ requestParserResult }) {
          if (Array.isArray(requestParserResult)) {
            if (!limit) {
              throw createGraphQLError(`Batching is not supported.`, {
                extensions: {
                  http: {
                    status: 400
                  }
                }
              });
            }
            if (requestParserResult.length > limit) {
              throw createGraphQLError(`Batching is limited to ${limit} operations per request.`, {
                extensions: {
                  http: {
                    status: 413
                  }
                }
              });
            }
          }
        }
      };
    }
  };
}

// ../../node_modules/graphql-yoga/esm/plugins/request-validation/use-prevent-mutation-via-get.js
function assertMutationViaGet(method, document, operationName) {
  const operation = document ? getOperationAST(document, operationName) ?? undefined : undefined;
  if (!operation) {
    throw createGraphQLError("Could not determine what operation to execute.", {
      extensions: {
        http: {
          status: 400
        }
      }
    });
  }
  if (operation.operation === "mutation" && method === "GET") {
    throw createGraphQLError("Can only perform a mutation operation from a POST request.", {
      extensions: {
        http: {
          status: 405,
          headers: {
            Allow: "POST"
          }
        }
      }
    });
  }
}
function usePreventMutationViaGET() {
  return {
    onParse() {
      return ({ result, context: {
        request,
        params: { operationName } = {}
      } }) => {
        if (!request) {
          return;
        }
        if (result instanceof Error) {
          if (result instanceof GraphQLError) {
            result.extensions.http = {
              spec: true,
              status: 400
            };
          }
          throw result;
        }
        assertMutationViaGet(request.method, result, operationName);
      };
    }
  };
}

// ../../node_modules/graphql-yoga/esm/plugins/use-health-check.js
function useHealthCheck({ id = Date.now().toString(), logger = console, endpoint = "/health" } = {}) {
  return {
    onRequest({ endResponse: endResponse2, fetchAPI, request }) {
      if (request.url.endsWith(endpoint)) {
        logger.debug("Responding Health Check");
        const response = new fetchAPI.Response(null, {
          status: 200,
          headers: {
            "x-yoga-id": id
          }
        });
        endResponse2(response);
      }
    }
  };
}

// ../../node_modules/lru-cache/dist/esm/index.js
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = new Set;
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type2, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type2, code, fn) : console.error(`[${code}] ${type2}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
if (typeof AC === "undefined") {
  AS = class AbortSignal2 {
    onabort;
    _onabort = [];
    reason;
    aborted = false;
    addEventListener(_, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController2 {
    constructor() {
      warnACPolyfill();
    }
    signal = new AS;
    abort(reason) {
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      this.signal.onabort?.(reason);
    }
  };
  let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var TYPE = Symbol("type");
var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;

class ZeroArray extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
}

class Stack {
  heap;
  length;
  static #constructing = false;
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    Stack.#constructing = true;
    const s = new Stack(max, HeapCls);
    Stack.#constructing = false;
    return s;
  }
  constructor(max, HeapCls) {
    if (!Stack.#constructing) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  push(n) {
    this.heap[this.length++] = n;
  }
  pop() {
    return this.heap[--this.length];
  }
}

class LRUCache {
  #max;
  #maxSize;
  #dispose;
  #disposeAfter;
  #fetchMethod;
  #memoMethod;
  ttl;
  ttlResolution;
  ttlAutopurge;
  updateAgeOnGet;
  updateAgeOnHas;
  allowStale;
  noDisposeOnSet;
  noUpdateTTL;
  maxEntrySize;
  sizeCalculation;
  noDeleteOnFetchRejection;
  noDeleteOnStaleGet;
  allowStaleOnFetchAbort;
  allowStaleOnFetchRejection;
  ignoreFetchAbort;
  #size;
  #calculatedSize;
  #keyMap;
  #keyList;
  #valList;
  #next;
  #prev;
  #head;
  #tail;
  #free;
  #disposed;
  #sizes;
  #starts;
  #ttls;
  #hasDispose;
  #hasFetchMethod;
  #hasDisposeAfter;
  static unsafeExposeInternals(c) {
    return {
      starts: c.#starts,
      ttls: c.#ttls,
      sizes: c.#sizes,
      keyMap: c.#keyMap,
      keyList: c.#keyList,
      valList: c.#valList,
      next: c.#next,
      prev: c.#prev,
      get head() {
        return c.#head;
      },
      get tail() {
        return c.#tail;
      },
      free: c.#free,
      isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
      backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
      moveToTail: (index) => c.#moveToTail(index),
      indexes: (options) => c.#indexes(options),
      rindexes: (options) => c.#rindexes(options),
      isStale: (index) => c.#isStale(index)
    };
  }
  get max() {
    return this.#max;
  }
  get maxSize() {
    return this.#maxSize;
  }
  get calculatedSize() {
    return this.#calculatedSize;
  }
  get size() {
    return this.#size;
  }
  get fetchMethod() {
    return this.#fetchMethod;
  }
  get memoMethod() {
    return this.#memoMethod;
  }
  get dispose() {
    return this.#dispose;
  }
  get disposeAfter() {
    return this.#disposeAfter;
  }
  constructor(options) {
    const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    this.#max = max;
    this.#maxSize = maxSize;
    this.maxEntrySize = maxEntrySize || this.#maxSize;
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!this.#maxSize && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (memoMethod !== undefined && typeof memoMethod !== "function") {
      throw new TypeError("memoMethod must be a function if defined");
    }
    this.#memoMethod = memoMethod;
    if (fetchMethod !== undefined && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    this.#fetchMethod = fetchMethod;
    this.#hasFetchMethod = !!fetchMethod;
    this.#keyMap = new Map;
    this.#keyList = new Array(max).fill(undefined);
    this.#valList = new Array(max).fill(undefined);
    this.#next = new UintArray(max);
    this.#prev = new UintArray(max);
    this.#head = 0;
    this.#tail = 0;
    this.#free = Stack.create(max);
    this.#size = 0;
    this.#calculatedSize = 0;
    if (typeof dispose === "function") {
      this.#dispose = dispose;
    }
    if (typeof disposeAfter === "function") {
      this.#disposeAfter = disposeAfter;
      this.#disposed = [];
    } else {
      this.#disposeAfter = undefined;
      this.#disposed = undefined;
    }
    this.#hasDispose = !!this.#dispose;
    this.#hasDisposeAfter = !!this.#disposeAfter;
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (this.#maxSize !== 0) {
        if (!isPosInt(this.#maxSize)) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      this.#initializeSizeTracking();
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      this.#initializeTTLTracking();
    }
    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
      }
    }
  }
  getRemainingTTL(key) {
    return this.#keyMap.has(key) ? Infinity : 0;
  }
  #initializeTTLTracking() {
    const ttls = new ZeroArray(this.#max);
    const starts = new ZeroArray(this.#max);
    this.#ttls = ttls;
    this.#starts = starts;
    this.#setItemTTL = (index, ttl, start = perf.now()) => {
      starts[index] = ttl !== 0 ? start : 0;
      ttls[index] = ttl;
      if (ttl !== 0 && this.ttlAutopurge) {
        const t = setTimeout(() => {
          if (this.#isStale(index)) {
            this.#delete(this.#keyList[index], "expire");
          }
        }, ttl + 1);
        if (t.unref) {
          t.unref();
        }
      }
    };
    this.#updateItemAge = (index) => {
      starts[index] = ttls[index] !== 0 ? perf.now() : 0;
    };
    this.#statusTTL = (status, index) => {
      if (ttls[index]) {
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start)
          return;
        status.ttl = ttl;
        status.start = start;
        status.now = cachedNow || getNow();
        const age = status.now - start;
        status.remainingTTL = ttl - age;
      }
    };
    let cachedNow = 0;
    const getNow = () => {
      const n = perf.now();
      if (this.ttlResolution > 0) {
        cachedNow = n;
        const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
        if (t.unref) {
          t.unref();
        }
      }
      return n;
    };
    this.getRemainingTTL = (key) => {
      const index = this.#keyMap.get(key);
      if (index === undefined) {
        return 0;
      }
      const ttl = ttls[index];
      const start = starts[index];
      if (!ttl || !start) {
        return Infinity;
      }
      const age = (cachedNow || getNow()) - start;
      return ttl - age;
    };
    this.#isStale = (index) => {
      const s = starts[index];
      const t = ttls[index];
      return !!t && !!s && (cachedNow || getNow()) - s > t;
    };
  }
  #updateItemAge = () => {
  };
  #statusTTL = () => {
  };
  #setItemTTL = () => {
  };
  #isStale = () => false;
  #initializeSizeTracking() {
    const sizes = new ZeroArray(this.#max);
    this.#calculatedSize = 0;
    this.#sizes = sizes;
    this.#removeItemSize = (index) => {
      this.#calculatedSize -= sizes[index];
      sizes[index] = 0;
    };
    this.#requireSize = (k, v, size, sizeCalculation) => {
      if (this.#isBackgroundFetch(v)) {
        return 0;
      }
      if (!isPosInt(size)) {
        if (sizeCalculation) {
          if (typeof sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation must be a function");
          }
          size = sizeCalculation(v, k);
          if (!isPosInt(size)) {
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
          }
        } else {
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        }
      }
      return size;
    };
    this.#addItemSize = (index, size, status) => {
      sizes[index] = size;
      if (this.#maxSize) {
        const maxSize = this.#maxSize - sizes[index];
        while (this.#calculatedSize > maxSize) {
          this.#evict(true);
        }
      }
      this.#calculatedSize += sizes[index];
      if (status) {
        status.entrySize = size;
        status.totalCalculatedSize = this.#calculatedSize;
      }
    };
  }
  #removeItemSize = (_i) => {
  };
  #addItemSize = (_i, _s, _st) => {
  };
  #requireSize = (_k, _v, size, sizeCalculation) => {
    if (size || sizeCalculation) {
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    }
    return 0;
  };
  *#indexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#tail;; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#head) {
          break;
        } else {
          i = this.#prev[i];
        }
      }
    }
  }
  *#rindexes({ allowStale = this.allowStale } = {}) {
    if (this.#size) {
      for (let i = this.#head;; ) {
        if (!this.#isValidIndex(i)) {
          break;
        }
        if (allowStale || !this.#isStale(i)) {
          yield i;
        }
        if (i === this.#tail) {
          break;
        } else {
          i = this.#next[i];
        }
      }
    }
  }
  #isValidIndex(index) {
    return index !== undefined && this.#keyMap.get(this.#keyList[index]) === index;
  }
  *entries() {
    for (const i of this.#indexes()) {
      if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  *rentries() {
    for (const i of this.#rindexes()) {
      if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield [this.#keyList[i], this.#valList[i]];
      }
    }
  }
  *keys() {
    for (const i of this.#indexes()) {
      const k = this.#keyList[i];
      if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  *rkeys() {
    for (const i of this.#rindexes()) {
      const k = this.#keyList[i];
      if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield k;
      }
    }
  }
  *values() {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  *rvalues() {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
        yield this.#valList[i];
      }
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  [Symbol.toStringTag] = "LRUCache";
  find(fn, getOptions = {}) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        continue;
      if (fn(value, this.#keyList[i], this)) {
        return this.get(this.#keyList[i], getOptions);
      }
    }
  }
  forEach(fn, thisp = this) {
    for (const i of this.#indexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  rforEach(fn, thisp = this) {
    for (const i of this.#rindexes()) {
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined)
        continue;
      fn.call(thisp, value, this.#keyList[i], this);
    }
  }
  purgeStale() {
    let deleted = false;
    for (const i of this.#rindexes({ allowStale: true })) {
      if (this.#isStale(i)) {
        this.#delete(this.#keyList[i], "expire");
        deleted = true;
      }
    }
    return deleted;
  }
  info(key) {
    const i = this.#keyMap.get(key);
    if (i === undefined)
      return;
    const v = this.#valList[i];
    const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    if (value === undefined)
      return;
    const entry = { value };
    if (this.#ttls && this.#starts) {
      const ttl = this.#ttls[i];
      const start = this.#starts[i];
      if (ttl && start) {
        const remain = ttl - (perf.now() - start);
        entry.ttl = remain;
        entry.start = Date.now();
      }
    }
    if (this.#sizes) {
      entry.size = this.#sizes[i];
    }
    return entry;
  }
  dump() {
    const arr = [];
    for (const i of this.#indexes({ allowStale: true })) {
      const key = this.#keyList[i];
      const v = this.#valList[i];
      const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === undefined || key === undefined)
        continue;
      const entry = { value };
      if (this.#ttls && this.#starts) {
        entry.ttl = this.#ttls[i];
        const age = perf.now() - this.#starts[i];
        entry.start = Math.floor(Date.now() - age);
      }
      if (this.#sizes) {
        entry.size = this.#sizes[i];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  set(k, v, setOptions = {}) {
    if (v === undefined) {
      this.delete(k);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      this.#delete(k, "set");
      return this;
    }
    let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
    if (index === undefined) {
      index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
      this.#keyList[index] = k;
      this.#valList[index] = v;
      this.#keyMap.set(k, index);
      this.#next[this.#tail] = index;
      this.#prev[index] = this.#tail;
      this.#tail = index;
      this.#size++;
      this.#addItemSize(index, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
    } else {
      this.#moveToTail(index);
      const oldVal = this.#valList[index];
      if (v !== oldVal) {
        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s } = oldVal;
          if (s !== undefined && !noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(s, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([s, k, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (this.#hasDispose) {
            this.#dispose?.(oldVal, k, "set");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([oldVal, k, "set"]);
          }
        }
        this.#removeItemSize(index);
        this.#addItemSize(index, size, status);
        this.#valList[index] = v;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== undefined)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && !this.#ttls) {
      this.#initializeTTLTracking();
    }
    if (this.#ttls) {
      if (!noUpdateTTL) {
        this.#setItemTTL(index, ttl, start);
      }
      if (status)
        this.#statusTTL(status, index);
    }
    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return this;
  }
  pop() {
    try {
      while (this.#size) {
        const val = this.#valList[this.#head];
        this.#evict(true);
        if (this.#isBackgroundFetch(val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== undefined) {
          return val;
        }
      }
    } finally {
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  }
  #evict(free) {
    const head = this.#head;
    const k = this.#keyList[head];
    const v = this.#valList[head];
    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
      v.__abortController.abort(new Error("evicted"));
    } else if (this.#hasDispose || this.#hasDisposeAfter) {
      if (this.#hasDispose) {
        this.#dispose?.(v, k, "evict");
      }
      if (this.#hasDisposeAfter) {
        this.#disposed?.push([v, k, "evict"]);
      }
    }
    this.#removeItemSize(head);
    if (free) {
      this.#keyList[head] = undefined;
      this.#valList[head] = undefined;
      this.#free.push(head);
    }
    if (this.#size === 1) {
      this.#head = this.#tail = 0;
      this.#free.length = 0;
    } else {
      this.#head = this.#next[head];
    }
    this.#keyMap.delete(k);
    this.#size--;
    return head;
  }
  has(k, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index = this.#keyMap.get(k);
    if (index !== undefined) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === undefined) {
        return false;
      }
      if (!this.#isStale(index)) {
        if (updateAgeOnHas) {
          this.#updateItemAge(index);
        }
        if (status) {
          status.has = "hit";
          this.#statusTTL(status, index);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        this.#statusTTL(status, index);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  peek(k, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index = this.#keyMap.get(k);
    if (index === undefined || !allowStale && this.#isStale(index)) {
      return;
    }
    const v = this.#valList[index];
    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
  }
  #backgroundFetch(k, index, options, context) {
    const v = index === undefined ? undefined : this.#valList[index];
    if (this.#isBackgroundFetch(v)) {
      return v;
    }
    const ac = new AC;
    const { signal } = options;
    signal?.addEventListener("abort", () => ac.abort(signal.reason), {
      signal: ac.signal
    });
    const fetchOpts = {
      signal: ac.signal,
      options,
      context
    };
    const cb = (v2, updateCache = false) => {
      const { aborted } = ac.signal;
      const ignoreAbort = options.ignoreFetchAbort && v2 !== undefined;
      if (options.status) {
        if (aborted && !updateCache) {
          options.status.fetchAborted = true;
          options.status.fetchError = ac.signal.reason;
          if (ignoreAbort)
            options.status.fetchAbortIgnored = true;
        } else {
          options.status.fetchResolved = true;
        }
      }
      if (aborted && !ignoreAbort && !updateCache) {
        return fetchFail(ac.signal.reason);
      }
      const bf2 = p;
      if (this.#valList[index] === p) {
        if (v2 === undefined) {
          if (bf2.__staleWhileFetching) {
            this.#valList[index] = bf2.__staleWhileFetching;
          } else {
            this.#delete(k, "fetch");
          }
        } else {
          if (options.status)
            options.status.fetchUpdated = true;
          this.set(k, v2, fetchOpts.options);
        }
      }
      return v2;
    };
    const eb = (er) => {
      if (options.status) {
        options.status.fetchRejected = true;
        options.status.fetchError = er;
      }
      return fetchFail(er);
    };
    const fetchFail = (er) => {
      const { aborted } = ac.signal;
      const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
      const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
      const noDelete = allowStale || options.noDeleteOnFetchRejection;
      const bf2 = p;
      if (this.#valList[index] === p) {
        const del = !noDelete || bf2.__staleWhileFetching === undefined;
        if (del) {
          this.#delete(k, "fetch");
        } else if (!allowStaleAborted) {
          this.#valList[index] = bf2.__staleWhileFetching;
        }
      }
      if (allowStale) {
        if (options.status && bf2.__staleWhileFetching !== undefined) {
          options.status.returnedStale = true;
        }
        return bf2.__staleWhileFetching;
      } else if (bf2.__returned === bf2) {
        throw er;
      }
    };
    const pcall = (res, rej) => {
      const fmp = this.#fetchMethod?.(k, v, fetchOpts);
      if (fmp && fmp instanceof Promise) {
        fmp.then((v2) => res(v2 === undefined ? undefined : v2), rej);
      }
      ac.signal.addEventListener("abort", () => {
        if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
          res(undefined);
          if (options.allowStaleOnFetchAbort) {
            res = (v2) => cb(v2, true);
          }
        }
      });
    };
    if (options.status)
      options.status.fetchDispatched = true;
    const p = new Promise(pcall).then(cb, eb);
    const bf = Object.assign(p, {
      __abortController: ac,
      __staleWhileFetching: v,
      __returned: undefined
    });
    if (index === undefined) {
      this.set(k, bf, { ...fetchOpts.options, status: undefined });
      index = this.#keyMap.get(k);
    } else {
      this.#valList[index] = bf;
    }
    return bf;
  }
  #isBackgroundFetch(p) {
    if (!this.#hasFetchMethod)
      return false;
    const b = p;
    return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
  }
  async fetch(k, fetchOptions = {}) {
    const {
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!this.#hasFetchMethod) {
      if (status)
        status.fetch = "get";
      return this.get(k, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index = this.#keyMap.get(k);
    if (index === undefined) {
      if (status)
        status.fetch = "miss";
      const p = this.#backgroundFetch(k, index, options, context);
      return p.__returned = p;
    } else {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        const stale = allowStale && v.__staleWhileFetching !== undefined;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale = this.#isStale(index);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        if (status)
          this.#statusTTL(status, index);
        return v;
      }
      const p = this.#backgroundFetch(k, index, options, context);
      const hasStale = p.__staleWhileFetching !== undefined;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  async forceFetch(k, fetchOptions = {}) {
    const v = await this.fetch(k, fetchOptions);
    if (v === undefined)
      throw new Error("fetch() returned undefined");
    return v;
  }
  memo(k, memoOptions = {}) {
    const memoMethod = this.#memoMethod;
    if (!memoMethod) {
      throw new Error("no memoMethod provided to constructor");
    }
    const { context, forceRefresh, ...options } = memoOptions;
    const v = this.get(k, options);
    if (!forceRefresh && v !== undefined)
      return v;
    const vv = memoMethod(k, v, {
      options,
      context
    });
    this.set(k, vv, options);
    return vv;
  }
  get(k, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index = this.#keyMap.get(k);
    if (index !== undefined) {
      const value = this.#valList[index];
      const fetching = this.#isBackgroundFetch(value);
      if (status)
        this.#statusTTL(status, index);
      if (this.#isStale(index)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            this.#delete(k, "expire");
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : undefined;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== undefined) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : undefined;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        this.#moveToTail(index);
        if (updateAgeOnGet) {
          this.#updateItemAge(index);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  #connect(p, n) {
    this.#prev[n] = p;
    this.#next[p] = n;
  }
  #moveToTail(index) {
    if (index !== this.#tail) {
      if (index === this.#head) {
        this.#head = this.#next[index];
      } else {
        this.#connect(this.#prev[index], this.#next[index]);
      }
      this.#connect(this.#tail, index);
      this.#tail = index;
    }
  }
  delete(k) {
    return this.#delete(k, "delete");
  }
  #delete(k, reason) {
    let deleted = false;
    if (this.#size !== 0) {
      const index = this.#keyMap.get(k);
      if (index !== undefined) {
        deleted = true;
        if (this.#size === 1) {
          this.#clear(reason);
        } else {
          this.#removeItemSize(index);
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v, k, reason);
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, reason]);
            }
          }
          this.#keyMap.delete(k);
          this.#keyList[index] = undefined;
          this.#valList[index] = undefined;
          if (index === this.#tail) {
            this.#tail = this.#prev[index];
          } else if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            const pi = this.#prev[index];
            this.#next[pi] = this.#next[index];
            const ni = this.#next[index];
            this.#prev[ni] = this.#prev[index];
          }
          this.#size--;
          this.#free.push(index);
        }
      }
    }
    if (this.#hasDisposeAfter && this.#disposed?.length) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
    return deleted;
  }
  clear() {
    return this.#clear("delete");
  }
  #clear(reason) {
    for (const index of this.#rindexes({ allowStale: true })) {
      const v = this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("deleted"));
      } else {
        const k = this.#keyList[index];
        if (this.#hasDispose) {
          this.#dispose?.(v, k, reason);
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, reason]);
        }
      }
    }
    this.#keyMap.clear();
    this.#valList.fill(undefined);
    this.#keyList.fill(undefined);
    if (this.#ttls && this.#starts) {
      this.#ttls.fill(0);
      this.#starts.fill(0);
    }
    if (this.#sizes) {
      this.#sizes.fill(0);
    }
    this.#head = 0;
    this.#tail = 0;
    this.#free.length = 0;
    this.#calculatedSize = 0;
    this.#size = 0;
    if (this.#hasDisposeAfter && this.#disposed) {
      const dt = this.#disposed;
      let task;
      while (task = dt?.shift()) {
        this.#disposeAfter?.(...task);
      }
    }
  }
}

// ../../node_modules/graphql-yoga/esm/utils/create-lru-cache.js
function createLRUCache({ max = DEFAULT_MAX, ttl = DEFAULT_TTL } = {}) {
  return new LRUCache({ max, ttl });
}
var DEFAULT_MAX = 1024;
var DEFAULT_TTL = 3600000;

// ../../node_modules/graphql-yoga/esm/plugins/use-parser-and-validation-cache.js
function useParserAndValidationCache({ documentCache = createLRUCache(), errorCache = createLRUCache(), validationCache = true }) {
  const validationCacheByRules = createLRUCache();
  return {
    onParse({ params, setParsedDocument }) {
      const strDocument = params.source.toString();
      const document = documentCache.get(strDocument);
      if (document) {
        setParsedDocument(document);
        return;
      }
      const parserError = errorCache.get(strDocument);
      if (parserError) {
        throw parserError;
      }
      return ({ result }) => {
        if (result != null) {
          if (result instanceof Error) {
            errorCache.set(strDocument, result);
          } else {
            documentCache.set(strDocument, result);
          }
        }
      };
    },
    onValidate({
      params: { schema: schema5, documentAST, rules },
      setResult
    }) {
      if (schema5 == null) {
        return;
      }
      if (validationCache !== false) {
        const rulesKey = rules?.map((rule) => rule.name).join(",") || "";
        let validationCacheBySchema = validationCacheByRules.get(rulesKey);
        if (!validationCacheBySchema) {
          validationCacheBySchema = new WeakMap;
          validationCacheByRules.set(rulesKey, validationCacheBySchema);
        }
        let validationCacheByDocument = validationCacheBySchema.get(schema5);
        if (!validationCacheByDocument) {
          validationCacheByDocument = new WeakMap;
          validationCacheBySchema.set(schema5, validationCacheByDocument);
        }
        const cachedResult = validationCacheByDocument.get(documentAST);
        if (cachedResult) {
          setResult(cachedResult);
          return;
        }
        return ({ result }) => {
          if (result != null) {
            validationCacheByDocument?.set(documentAST, result);
          }
        };
      }
    }
  };
}

// ../../node_modules/graphql-yoga/esm/plugins/use-request-parser.js
function useRequestParser(options) {
  const matchFn = options.match || DEFAULT_MATCHER;
  return {
    onRequestParse({ request, setRequestParser }) {
      if (matchFn(request)) {
        setRequestParser(options.parse);
      }
    }
  };
}
var DEFAULT_MATCHER = () => true;

// ../../node_modules/graphql-yoga/esm/plugins/result-processor/accept.js
function getMediaTypesForRequestInOrder(request) {
  const accepts = (request.headers.get("accept") || "*/*").replace(/\s/g, "").toLowerCase().split(",");
  const mediaTypes = [];
  for (const accept of accepts) {
    const [mediaType, ...params] = accept.split(";");
    const charset = params?.find((param) => param.includes("charset=")) || "charset=utf-8";
    if (charset !== "charset=utf-8") {
      continue;
    }
    mediaTypes.push(mediaType);
  }
  return mediaTypes.reverse();
}
function isMatchingMediaType(askedMediaType, processorMediaType) {
  const [askedPre, askedSuf] = askedMediaType.split("/");
  const [pre, suf] = processorMediaType.split("/");
  if ((pre === "*" || pre === askedPre) && (suf === "*" || suf === askedSuf)) {
    return true;
  }
  return false;
}

// ../../node_modules/graphql-yoga/esm/plugins/result-processor/stringify.js
function jsonStringifyResultWithoutInternals(result) {
  if (Array.isArray(result)) {
    return `[${result.map((r) => {
      const sanitizedResult2 = omitInternalsFromResultErrors(r);
      const stringifier2 = r.stringify || JSON.stringify;
      return stringifier2(sanitizedResult2);
    }).join(",")}]`;
  }
  const sanitizedResult = omitInternalsFromResultErrors(result);
  const stringifier = result.stringify || JSON.stringify;
  return stringifier(sanitizedResult);
}
function omitInternalsFromResultErrors(result) {
  if (result.errors?.length || result.extensions?.http) {
    const newResult = { ...result };
    newResult.errors &&= newResult.errors.map(omitInternalsFromError);
    if (newResult.extensions) {
      const { http, ...extensions } = result.extensions;
      newResult.extensions = Object.keys(extensions).length ? extensions : undefined;
    }
    return newResult;
  }
  return result;
}
var omitInternalsFromError = function(err) {
  if (isGraphQLError(err)) {
    const serializedError = "toJSON" in err && typeof err.toJSON === "function" ? err.toJSON() : Object(err);
    const { http, unexpected, ...extensions } = serializedError.extensions || {};
    return createGraphQLError(err.message, {
      nodes: err.nodes,
      source: err.source,
      positions: err.positions,
      path: err.path,
      originalError: omitInternalsFromError(err.originalError || undefined),
      extensions: Object.keys(extensions).length ? extensions : undefined
    });
  }
  return err;
};

// ../../node_modules/graphql-yoga/esm/plugins/result-processor/multipart.js
function processMultipartResult(result, fetchAPI) {
  const headersInit = {
    Connection: "keep-alive",
    "Content-Type": 'multipart/mixed; boundary="-"',
    "Transfer-Encoding": "chunked"
  };
  const responseInit = getResponseInitByRespectingErrors(result, headersInit);
  let iterator;
  const textEncoder = new fetchAPI.TextEncoder;
  const readableStream = new fetchAPI.ReadableStream({
    start(controller) {
      if (isAsyncIterable3(result)) {
        iterator = result[Symbol.asyncIterator]();
      } else {
        let finished = false;
        iterator = {
          next: () => {
            if (finished) {
              return Promise.resolve({ done: true, value: null });
            }
            finished = true;
            return Promise.resolve({ done: false, value: result });
          }
        };
      }
      controller.enqueue(textEncoder.encode(`---`));
    },
    async pull(controller) {
      const { done, value } = await iterator.next();
      if (value != null) {
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(textEncoder.encode("Content-Type: application/json; charset=utf-8"));
        controller.enqueue(textEncoder.encode("\r\n"));
        const chunk = jsonStringifyResultWithoutInternals(value);
        const encodedChunk = textEncoder.encode(chunk);
        controller.enqueue(textEncoder.encode("Content-Length: " + encodedChunk.byteLength));
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(encodedChunk);
        controller.enqueue(textEncoder.encode("\r\n"));
        controller.enqueue(textEncoder.encode("---"));
      }
      if (done) {
        controller.enqueue(textEncoder.encode("--\r\n"));
        controller.close();
      }
    },
    async cancel(e) {
      await iterator.return?.(e);
    }
  });
  return new fetchAPI.Response(readableStream, responseInit);
}

// ../../node_modules/graphql-yoga/esm/plugins/result-processor/regular.js
function processRegularResult(executionResult, fetchAPI, acceptedHeader) {
  if (isAsyncIterable(executionResult)) {
    return new fetchAPI.Response(null, {
      status: 406,
      statusText: "Not Acceptable",
      headers: {
        accept: "application/json; charset=utf-8, application/graphql-response+json; charset=utf-8"
      }
    });
  }
  const headersInit = {
    "Content-Type": acceptedHeader + "; charset=utf-8"
  };
  const responseInit = getResponseInitByRespectingErrors(executionResult, headersInit, acceptedHeader === "application/json" && !Array.isArray(executionResult) && areGraphQLErrors(executionResult.errors) && executionResult.errors.some((err) => !err.extensions.originalError || isGraphQLError(err.extensions.originalError)));
  const responseBody = jsonStringifyResultWithoutInternals(executionResult);
  return new fetchAPI.Response(responseBody, responseInit);
}

// ../../node_modules/graphql-yoga/esm/plugins/result-processor/sse.js
function getSSEProcessor() {
  return function processSSEResult(result, fetchAPI) {
    let pingIntervalMs = 12000;
    if (globalThis.process?.env?.NODE_ENV === "test") {
      pingIntervalMs = 300;
    }
    const headersInit = {
      "Content-Type": "text/event-stream",
      Connection: "keep-alive",
      "Cache-Control": "no-cache",
      "Content-Encoding": "none"
    };
    const responseInit = getResponseInitByRespectingErrors(result, headersInit, true);
    let iterator;
    let pingInterval;
    const textEncoder = new fetchAPI.TextEncoder;
    const readableStream = new fetchAPI.ReadableStream({
      start(controller) {
        controller.enqueue(textEncoder.encode(":\n\n"));
        pingInterval = setInterval(() => {
          if (!controller.desiredSize) {
            clearInterval(pingInterval);
            return;
          }
          controller.enqueue(textEncoder.encode(":\n\n"));
        }, pingIntervalMs);
        if (isAsyncIterable3(result)) {
          iterator = result[Symbol.asyncIterator]();
        } else {
          let finished = false;
          iterator = {
            next: () => {
              if (finished) {
                return Promise.resolve({ done: true, value: null });
              }
              finished = true;
              return Promise.resolve({ done: false, value: result });
            }
          };
        }
      },
      async pull(controller) {
        const { done, value } = await iterator.next();
        if (value != null) {
          controller.enqueue(textEncoder.encode(`event: next\n`));
          const chunk = jsonStringifyResultWithoutInternals(value);
          controller.enqueue(textEncoder.encode(`data: ${chunk}\n\n`));
        }
        if (done) {
          controller.enqueue(textEncoder.encode(`event: complete\n\n`));
          clearInterval(pingInterval);
          controller.close();
        }
      },
      async cancel(e) {
        clearInterval(pingInterval);
        await iterator.return?.(e);
      }
    });
    return new fetchAPI.Response(readableStream, responseInit);
  };
}

// ../../node_modules/graphql-yoga/esm/plugins/use-result-processor.js
var getSSEProcessorConfig = function() {
  return {
    mediaTypes: ["text/event-stream"],
    asyncIterables: true,
    processResult: getSSEProcessor()
  };
};
function useResultProcessors() {
  const isSubscriptionRequestMap = new WeakMap;
  const sse2 = getSSEProcessorConfig();
  const defaultList = [sse2, multipart2, regular2];
  const subscriptionList = [sse2, regular2];
  return {
    onSubscribe({ args: { contextValue } }) {
      if (contextValue.request) {
        isSubscriptionRequestMap.set(contextValue.request, true);
      }
    },
    onResultProcess({ request, result, acceptableMediaTypes, setResultProcessor }) {
      const isSubscriptionRequest = isSubscriptionRequestMap.get(request);
      const processorConfigList = isSubscriptionRequest ? subscriptionList : defaultList;
      const requestMediaTypes = getMediaTypesForRequestInOrder(request);
      const isAsyncIterableResult = isAsyncIterable3(result);
      for (const resultProcessorConfig of processorConfigList) {
        for (const requestMediaType of requestMediaTypes) {
          if (isAsyncIterableResult && !resultProcessorConfig.asyncIterables) {
            continue;
          }
          for (const processorMediaType of resultProcessorConfig.mediaTypes) {
            acceptableMediaTypes.push(processorMediaType);
            if (isMatchingMediaType(processorMediaType, requestMediaType)) {
              setResultProcessor(resultProcessorConfig.processResult, processorMediaType);
            }
          }
        }
      }
    }
  };
}
var multipart2 = {
  mediaTypes: ["multipart/mixed"],
  asyncIterables: true,
  processResult: processMultipartResult
};
var regular2 = {
  mediaTypes: ["application/graphql-response+json", "application/json"],
  asyncIterables: false,
  processResult: processRegularResult
};

// ../../node_modules/graphql-yoga/esm/landing-page-html.js
var landing_page_html_default = `<!doctype html><html lang=en><head><meta charset=utf-8><title>Welcome to GraphQL Yoga</title><link rel=icon href=https://raw.githubusercontent.com/dotansimha/graphql-yoga/main/website/public/favicon.ico><style>body,html{padding:0;margin:0;height:100%;font-family:Inter,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen,Ubuntu,Cantarell,'Fira Sans','Droid Sans','Helvetica Neue',sans-serif;color:#fff;background-color:#000}main>section.hero{display:flex;height:90vh;justify-content:center;align-items:center;flex-direction:column}.logo{display:flex;align-items:center}.buttons{margin-top:24px}h1{font-size:80px}h2{color:#888;max-width:50%;margin-top:0;text-align:center}a{color:#fff;text-decoration:none;margin-left:10px;margin-right:10px;font-weight:700;transition:color .3s ease;padding:4px;overflow:visible}a.graphiql:hover{color:rgba(255,0,255,.7)}a.docs:hover{color:rgba(28,200,238,.7)}a.tutorial:hover{color:rgba(125,85,245,.7)}svg{margin-right:24px}.not-what-your-looking-for{margin-top:5vh}.not-what-your-looking-for>*{margin-left:auto;margin-right:auto}.not-what-your-looking-for>p{text-align:center}.not-what-your-looking-for>h2{color:#464646}.not-what-your-looking-for>p{max-width:600px;line-height:1.3em}.not-what-your-looking-for>pre{max-width:300px}</style></head><body id=body><main><section class=hero><div class=logo><div><svg xmlns=http://www.w3.org/2000/svg viewBox="-0.41 0.445 472.812 499.811" height=150><defs><linearGradient id=paint0_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint1_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint2_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint3_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint4_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><linearGradient id=paint5_linear_1677_11483 x1=16 y1=14 x2=87.2132 y2=44.5982 gradientUnits=userSpaceOnUse><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><filter id=filter0_f_1677_11483 x=23 y=-25 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><filter id=filter1_f_1677_11483 x=-24 y=19 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><linearGradient id=paint6_linear_1677_11483 x1=30 y1=28 x2=66.1645 y2=44.4363 gradientUnits=userSpaceOnUse gradientTransform="matrix(8.139854, 0, 0, 8.139854, -130.346407, -113.25101)"><stop stop-color=#7433FF /><stop offset=1 stop-color=#FFA3FD /></linearGradient><filter id=filter2_f_1677_11483 x=-12 y=-44 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter><filter id=filter3_f_1677_11483 x=13 y=19 width=100 height=100 filterUnits=userSpaceOnUse color-interpolation-filters=sRGB><feFlood flood-opacity=0 result=BackgroundImageFix /><feBlend mode=normal in=SourceGraphic in2=BackgroundImageFix result=shape /><feGaussianBlur stdDeviation=12 result=effect1_foregroundBlur_1677_11483 /></filter></defs><mask id=mask0_1677_11483 style=mask-type:alpha maskUnits=userSpaceOnUse x=16 y=14 width=58 height=62><path d="M21 25.3501C21.7279 25.3501 22.4195 25.5056 23.0433 25.7853L42.1439 14.8C43.0439 14.3 44.1439 14 45.1439 14C46.2439 14 47.2439 14.3 48.1439 14.8L64.5439 24.3C63.3439 25.1 62.4439 26.3 61.8439 27.7L45.9438 18.5C45.6439 18.3 45.344 18.3 45.0441 18.3C44.7441 18.3 44.4439 18.4 44.1439 18.5L25.8225 29.0251C25.9382 29.4471 26 29.8914 26 30.3501C26 33.1115 23.7614 35.3501 21 35.3501C18.2386 35.3501 16 33.1115 16 30.3501C16 27.5887 18.2386 25.3501 21 25.3501Z" fill=url(#paint3_linear_1677_11483) /><path d="M67.2438 35.0329C65.3487 34.3219 64 32.4934 64 30.35C64 27.5886 66.2386 25.35 69 25.35C71.7614 25.35 74 27.5886 74 30.35C74 32.1825 73.0142 33.7848 71.5439 34.6554V55.2C71.5439 57.4 70.3439 59.4 68.5439 60.5L52.1439 69.9C52.1439 68.4 51.6438 66.9 50.7438 65.8L66.3439 56.8C66.9439 56.5 67.2438 55.9 67.2438 55.2V35.0329Z" fill=url(#paint4_linear_1677_11483) /><path d="M49.8439 69.1055C49.9458 69.5034 50 69.9204 50 70.3501C50 73.1115 47.7614 75.3501 45 75.3501C42.5102 75.3501 40.4454 73.5302 40.0633 71.1481L21.8439 60.6C19.9439 59.5 18.8439 57.5 18.8439 55.3V36.8C19.5439 37 20.3439 37.2 21.0439 37.2C21.7439 37.2 22.4439 37.1 23.0439 36.9V55.3C23.0439 56 23.4438 56.6 23.9438 56.9L41.3263 66.9583C42.2398 65.9694 43.5476 65.3501 45 65.3501C47.3291 65.3501 49.2862 66.9426 49.8419 69.0981L49.8436 69.0997L49.8439 69.1055Z" fill=url(#paint5_linear_1677_11483) /></mask><mask id=mask1_1677_11483 style=mask-type:alpha maskUnits=userSpaceOnUse x=30 y=28 width=30 height=30><path fill-rule=evenodd clip-rule=evenodd d="M49.3945 32.3945C49.3945 34.7088 47.5796 38.5469 45 38.5469C42.4271 38.5469 40.6055 34.7112 40.6055 32.3945C40.6055 29.9714 42.5769 28 45 28C47.4231 28 49.3945 29.9714 49.3945 32.3945ZM35.332 49.0433V48.2148C35.332 42.8117 37.8535 41.0004 39.8796 39.545L39.8801 39.5447C40.3928 39.1767 40.8604 38.8404 41.2488 38.4742C42.3293 39.6642 43.626 40.3047 45 40.3047C46.3752 40.3047 47.6725 39.6642 48.7529 38.4754C49.1408 38.841 49.6078 39.1773 50.1199 39.5447L50.1204 39.545C52.1465 41.0004 54.668 42.8117 54.668 48.2148V49.0433L53.8406 49.092C49.9848 49.3185 46.8646 46.9002 45 43.5777C43.1159 46.935 39.9847 49.318 36.1594 49.092L35.332 49.0433ZM58.1463 51.0747L58.1463 51.0746C57.0179 50.891 50.0128 49.7507 45.0007 55.693C40.0116 49.7553 33.1965 50.8592 31.9095 51.0677L31.9095 51.0677C31.7906 51.087 31.7189 51.0986 31.7002 51.0963C31.7005 51.0969 31.7011 51.1045 31.7023 51.1187C31.726 51.4003 31.9682 54.2745 34.0566 56.2422L30 58H60L55.8956 56.2422C57.8537 54.4764 58.1396 52.2685 58.2508 51.4092V51.4091C58.2697 51.2628 58.2836 51.1556 58.2998 51.0963C58.2881 51.0977 58.2356 51.0892 58.1463 51.0747ZM40.4836 50.104C42.3956 49.3212 43.6746 48.1737 45 46.61C46.332 48.1841 47.6159 49.3259 49.5164 50.104C49.5356 50.1425 49.5557 50.1805 49.5756 50.2182C49.5793 50.2253 49.583 50.2323 49.5867 50.2393C48.0911 50.8127 46.4264 51.825 45.0047 53.1444C43.5906 51.8221 41.9673 50.8196 40.4256 50.2153C40.4455 50.1784 40.4648 50.1415 40.4836 50.104Z" fill=black /></mask><path d="M 40.59 93.095 C 46.517 93.095 52.14 94.365 57.22 96.635 L 212.7 7.22 C 220.025 3.149 228.978 0.706 237.12 0.706 C 246.073 0.706 254.213 3.149 261.54 7.22 L 395.032 84.547 C 385.264 91.059 377.939 100.827 373.055 112.224 L 243.631 37.338 C 241.19 35.71 238.747 35.71 236.305 35.71 C 233.863 35.71 231.42 36.523 228.978 37.338 L 79.84 123.009 C 80.786 126.443 81.29 130.058 81.29 133.793 C 81.29 156.269 63.065 174.493 40.59 174.493 C 18.116 174.493 -0.109 156.269 -0.109 133.793 C -0.109 111.32 18.116 93.095 40.59 93.095 Z" fill=url(#paint0_linear_1677_11483) /><path d="M 417.01 171.913 C 401.585 166.126 390.603 151.238 390.603 133.793 C 390.603 111.32 408.83 93.095 431.303 93.095 C 453.777 93.095 472.001 111.32 472.001 133.793 C 472.001 148.706 463.976 161.755 452.011 168.835 L 452.011 336.07 C 452.011 353.977 442.243 370.258 427.591 379.21 L 294.098 455.726 C 294.098 443.516 290.029 431.306 282.703 422.353 L 409.683 349.093 C 414.568 346.651 417.01 341.767 417.01 336.07 L 417.01 171.913 Z" fill=url(#paint1_linear_1677_11483) /><path d="M 275.376 449.253 C 276.206 452.495 276.646 455.889 276.646 459.389 C 276.646 481.863 258.422 500.087 235.947 500.087 C 215.679 500.087 198.87 485.272 195.761 465.883 L 47.46 380.025 C 31.995 371.071 23.041 354.792 23.041 336.884 L 23.041 186.296 C 28.738 187.923 35.25 189.553 40.948 189.553 C 46.646 189.553 52.345 188.738 57.228 187.111 L 57.228 336.884 C 57.228 342.582 60.485 347.465 64.554 349.908 L 206.042 431.777 C 213.481 423.728 224.127 418.689 235.947 418.689 C 254.905 418.689 270.833 431.656 275.36 449.196 L 275.376 449.214 L 275.376 449.253 Z" fill=url(#paint2_linear_1677_11483) /><g mask=url(#mask0_1677_11483) transform="matrix(8.139854, 0, 0, 8.139854, -130.346375, -113.251038)"><g filter=url(#filter0_f_1677_11483)><circle cx=73 cy=25 r=26 fill=#ED2E7E /></g><g filter=url(#filter1_f_1677_11483)><circle cx=26 cy=69 r=26 fill=#1CC8EE /></g></g><path fill-rule=evenodd clip-rule=evenodd d="M 271.713 150.431 C 271.713 169.275 256.948 200.517 235.947 200.517 C 215.003 200.517 200.172 169.292 200.172 150.431 C 200.172 130.708 216.225 114.666 235.947 114.666 C 255.67 114.666 271.713 130.708 271.713 150.431 Z M 157.251 285.952 L 157.251 279.212 C 157.251 235.233 177.771 220.485 194.27 208.641 C 198.447 205.644 202.247 202.901 205.414 199.923 C 214.204 209.608 224.763 214.826 235.947 214.826 C 247.138 214.826 257.697 209.608 266.496 199.931 C 269.653 202.911 273.456 205.644 277.622 208.641 C 294.114 220.485 314.642 235.233 314.642 279.212 L 314.642 285.952 L 307.912 286.351 C 276.525 288.191 251.128 268.509 235.947 241.468 C 220.611 268.795 195.126 288.191 163.981 286.351 L 157.251 285.952 Z M 342.953 302.492 C 333.771 300.994 276.751 291.715 235.955 340.082 C 195.345 291.749 139.865 300.734 129.389 302.436 C 128.428 302.59 127.841 302.688 127.687 302.665 C 127.687 302.673 127.695 302.729 127.702 302.85 C 127.897 305.138 129.867 328.532 146.872 344.55 L 113.849 358.862 L 358.044 358.862 L 324.639 344.55 C 340.576 330.177 342.905 312.202 343.807 305.212 C 343.962 304.022 344.077 303.153 344.206 302.665 C 344.108 302.68 343.686 302.606 342.953 302.492 Z M 199.188 294.59 C 214.751 288.215 225.161 278.879 235.947 266.15 C 246.788 278.96 257.241 288.255 272.707 294.59 C 272.869 294.898 273.031 295.207 273.196 295.518 C 273.219 295.574 273.252 295.631 273.285 295.688 C 261.107 300.361 247.555 308.598 235.989 319.334 C 224.477 308.573 211.258 300.417 198.715 295.493 C 198.87 295.191 199.033 294.891 199.188 294.59 Z" fill=url(#paint6_linear_1677_11483) /><g mask=url(#mask1_1677_11483) transform="matrix(8.139854, 0, 0, 8.139854, -130.346375, -113.251038)"><g filter=url(#filter2_f_1677_11483)><circle cx=38 cy=6 r=26 fill=#ED2E7E /></g><g filter=url(#filter3_f_1677_11483)><circle cx=63 cy=69 r=26 fill=#1CC8EE /></g></g></svg></div><h1>GraphQL Yoga</h1></div><h2>The batteries-included cross-platform GraphQL Server.</h2><div class=buttons><a href=https://www.the-guild.dev/graphql/yoga-server/docs class=docs>Read the Docs</a> <a href=https://www.the-guild.dev/graphql/yoga-server/tutorial/basic class=tutorial>Start the Tutorial </a><a href=__GRAPHIQL_LINK__ class=graphiql>Visit GraphiQL</a></div></section><section class=not-what-your-looking-for><h2>Not the page you are looking for? \uD83D\uDC40</h2><p>This page is shown be default whenever a 404 is hit.<br>You can disable this by behavior via the <code>landingPage</code> option.</p><pre>
          <code>
import { createYoga } from 'graphql-yoga';

const yoga = createYoga({
  landingPage: false
})
          </code>
        </pre><p>If you expected this page to be the GraphQL route, you need to configure Yoga. Currently, the GraphQL route is configured to be on <code>__GRAPHIQL_LINK__</code>.</p><pre>
          <code>
import { createYoga } from 'graphql-yoga';

const yoga = createYoga({
  graphqlEndpoint: '__REQUEST_PATH__',
})
          </code>
        </pre></section></main></body></html>`;

// ../../node_modules/graphql-yoga/esm/plugins/use-unhandled-route.js
function useUnhandledRoute(args) {
  let urlPattern;
  function getUrlPattern({ URLPattern }) {
    urlPattern ||= new URLPattern({
      pathname: args.graphqlEndpoint
    });
    return urlPattern;
  }
  return {
    onRequest({ request, fetchAPI, endResponse: endResponse2, url }) {
      if (!request.url.endsWith(args.graphqlEndpoint) && url.pathname !== args.graphqlEndpoint && !getUrlPattern(fetchAPI).test(url)) {
        if (args.showLandingPage === true && request.method === "GET" && !!request.headers?.get("accept")?.includes("text/html")) {
          endResponse2(new fetchAPI.Response(landing_page_html_default.replace(/__GRAPHIQL_LINK__/g, args.graphqlEndpoint).replace(/__REQUEST_PATH__/g, url.pathname), {
            status: 200,
            statusText: "OK",
            headers: {
              "Content-Type": "text/html"
            }
          }));
          return;
        }
        endResponse2(new fetchAPI.Response("", {
          status: 404,
          statusText: "Not Found"
        }));
      }
    }
  };
}

// ../../node_modules/graphql-yoga/esm/process-request.js
async function processResult({ request, result, fetchAPI, onResultProcessHooks }) {
  let resultProcessor;
  const acceptableMediaTypes = [];
  let acceptedMediaType = "*/*";
  for (const onResultProcessHook of onResultProcessHooks) {
    await onResultProcessHook({
      request,
      acceptableMediaTypes,
      result,
      setResult(newResult) {
        result = newResult;
      },
      resultProcessor,
      setResultProcessor(newResultProcessor, newAcceptedMimeType) {
        resultProcessor = newResultProcessor;
        acceptedMediaType = newAcceptedMimeType;
      }
    });
  }
  if (!resultProcessor) {
    return new fetchAPI.Response(null, {
      status: 406,
      statusText: "Not Acceptable",
      headers: {
        accept: acceptableMediaTypes.join("; charset=utf-8, ")
      }
    });
  }
  return resultProcessor(result, fetchAPI, acceptedMediaType);
}
async function processRequest({ params, enveloped }) {
  const document = enveloped.parse(params.query);
  const errors4 = enveloped.validate(enveloped.schema, document);
  if (errors4.length > 0) {
    return { errors: errors4 };
  }
  const contextValue = await enveloped.contextFactory();
  const executionArgs = {
    schema: enveloped.schema,
    document,
    contextValue,
    variableValues: params.variables,
    operationName: params.operationName
  };
  const operation = getOperationAST(document, params.operationName);
  const executeFn = operation?.operation === "subscription" ? enveloped.subscribe : enveloped.execute;
  return executeFn(executionArgs);
}

// ../../node_modules/graphql-yoga/esm/utils/mask-error.js
var maskError = (error7, message, isDev2 = globalThis.process?.env?.NODE_ENV === "development") => {
  if (isGraphQLError(error7)) {
    if (error7.originalError) {
      if (error7.originalError.name === "GraphQLError") {
        return error7;
      }
      const extensions = {
        ...error7.extensions,
        unexpected: true
      };
      if (isDev2) {
        extensions.originalError = {
          message: error7.originalError.message,
          stack: error7.originalError.stack
        };
      }
      return createGraphQLError(message, {
        nodes: error7.nodes,
        source: error7.source,
        positions: error7.positions,
        path: error7.path,
        extensions
      });
    }
    return error7;
  }
  return createGraphQLError(message, {
    extensions: {
      unexpected: true,
      originalError: isDev2 ? error7 instanceof Error ? {
        message: error7.message,
        stack: error7.stack
      } : error7 : undefined
    }
  });
};

// ../../node_modules/graphql-yoga/esm/server.js
function createYoga(options) {
  const server2 = new YogaServer(options);
  return createServerAdapter(server2, {
    fetchAPI: server2.fetchAPI,
    plugins: server2["plugins"]
  });
}

class YogaServer {
  constructor(options) {
    this.handle = async (request, serverContext) => {
      let url = new Proxy({}, {
        get: (_target, prop, _receiver) => {
          url = new this.fetchAPI.URL(request.url, "http://localhost");
          return Reflect.get(url, prop, url);
        }
      });
      let requestParser;
      const onRequestParseDoneList = [];
      for (const onRequestParse of this.onRequestParseHooks) {
        const onRequestParseResult = await onRequestParse({
          request,
          url,
          requestParser,
          serverContext,
          setRequestParser(parser2) {
            requestParser = parser2;
          }
        });
        if (onRequestParseResult?.onRequestParseDone != null) {
          onRequestParseDoneList.push(onRequestParseResult.onRequestParseDone);
        }
      }
      this.logger.debug(`Parsing request to extract GraphQL parameters`);
      if (!requestParser) {
        return new this.fetchAPI.Response(null, {
          status: 415,
          statusText: "Unsupported Media Type"
        });
      }
      let requestParserResult = await requestParser(request);
      for (const onRequestParseDone of onRequestParseDoneList) {
        await onRequestParseDone({
          requestParserResult,
          setRequestParserResult(newParams) {
            requestParserResult = newParams;
          }
        });
      }
      const result = await (Array.isArray(requestParserResult) ? Promise.all(requestParserResult.map((params) => this.getResultForParams({
        params,
        request
      }, serverContext))) : this.getResultForParams({
        params: requestParserResult,
        request
      }, serverContext));
      return processResult({
        request,
        result,
        fetchAPI: this.fetchAPI,
        onResultProcessHooks: this.onResultProcessHooks
      });
    };
    this.id = options?.id ?? "yoga";
    this.fetchAPI = {
      ...exports_node_ponyfill
    };
    if (options?.fetchAPI) {
      for (const key in options.fetchAPI) {
        if (options.fetchAPI[key]) {
          this.fetchAPI[key] = options.fetchAPI[key];
        }
      }
    }
    const logger2 = options?.logging == null ? true : options.logging;
    this.logger = typeof logger2 === "boolean" ? logger2 === true ? createLogger() : createLogger("silent") : typeof logger2 === "string" ? createLogger(logger2) : logger2;
    const maskErrorFn = typeof options?.maskedErrors === "object" && options.maskedErrors.maskError || maskError;
    const maskedErrorSet = new WeakSet;
    this.maskedErrorsOpts = options?.maskedErrors === false ? null : {
      errorMessage: "Unexpected error.",
      ...typeof options?.maskedErrors === "object" ? options.maskedErrors : {},
      maskError: (error8, message) => {
        if (maskedErrorSet.has(error8)) {
          return error8;
        }
        const newError = maskErrorFn(error8, message, this.maskedErrorsOpts?.isDev);
        if (newError !== error8) {
          this.logger.error(error8);
        }
        maskedErrorSet.add(newError);
        return newError;
      }
    };
    const maskedErrors = this.maskedErrorsOpts == null ? null : this.maskedErrorsOpts;
    let batchingLimit = 0;
    if (options?.batching) {
      if (typeof options.batching === "boolean") {
        batchingLimit = 10;
      } else {
        batchingLimit = options.batching.limit ?? 10;
      }
    }
    this.graphqlEndpoint = options?.graphqlEndpoint || "/graphql";
    const graphqlEndpoint = this.graphqlEndpoint;
    this.plugins = [
      useEngine({
        parse,
        validate: validate2,
        execute: normalizedExecutor,
        subscribe: normalizedExecutor,
        specifiedRules
      }),
      !!options?.schema && useSchema(options.schema),
      options?.context != null && useExtendContext((initialContext) => {
        if (options?.context) {
          if (typeof options.context === "function") {
            return options.context(initialContext);
          }
          return options.context;
        }
        return {};
      }),
      useHealthCheck({
        id: this.id,
        logger: this.logger,
        endpoint: options?.healthCheckEndpoint
      }),
      options?.cors !== false && useCORS(options?.cors),
      options?.graphiql !== false && useGraphiQL({
        graphqlEndpoint,
        options: options?.graphiql,
        render: options?.renderGraphiQL,
        logger: this.logger
      }),
      useRequestParser({
        match: isGETRequest,
        parse: parseGETRequest
      }),
      useRequestParser({
        match: isPOSTJsonRequest,
        parse: parsePOSTJsonRequest
      }),
      options?.multipart !== false && useRequestParser({
        match: isPOSTMultipartRequest,
        parse: parsePOSTMultipartRequest
      }),
      useRequestParser({
        match: isPOSTGraphQLStringRequest,
        parse: parsePOSTGraphQLStringRequest
      }),
      useRequestParser({
        match: isPOSTFormUrlEncodedRequest,
        parse: parsePOSTFormUrlEncodedRequest
      }),
      useResultProcessors(),
      useErrorHandling((error8, request) => {
        const errors4 = handleError(error8, this.maskedErrorsOpts, this.logger);
        const result = {
          errors: errors4
        };
        return processResult({
          request,
          result,
          fetchAPI: this.fetchAPI,
          onResultProcessHooks: this.onResultProcessHooks
        });
      }),
      ...options?.plugins ?? [],
      {
        onPluginInit({ addPlugin }) {
          if (options?.parserAndValidationCache !== false) {
            addPlugin(useParserAndValidationCache(!options?.parserAndValidationCache || options?.parserAndValidationCache === true ? {} : options?.parserAndValidationCache));
          }
          addPlugin(useLimitBatching(batchingLimit));
          addPlugin(useCheckGraphQLQueryParams());
          addPlugin(useUnhandledRoute({
            graphqlEndpoint,
            showLandingPage: options?.landingPage ?? true
          }));
          addPlugin(useCheckMethodForGraphQL());
          addPlugin(usePreventMutationViaGET());
          if (maskedErrors) {
            addPlugin(useMaskedErrors(maskedErrors));
          }
          addPlugin(useHTTPValidationError());
        }
      }
    ];
    this.getEnveloped = envelop({
      plugins: this.plugins
    });
    this.plugins = this.getEnveloped._plugins;
    this.onRequestParseHooks = [];
    this.onParamsHooks = [];
    this.onResultProcessHooks = [];
    for (const plugin of this.plugins) {
      if (plugin) {
        if (plugin.onYogaInit) {
          plugin.onYogaInit({
            yoga: this
          });
        }
        if (plugin.onRequestParse) {
          this.onRequestParseHooks.push(plugin.onRequestParse);
        }
        if (plugin.onParams) {
          this.onParamsHooks.push(plugin.onParams);
        }
        if (plugin.onResultProcess) {
          this.onResultProcessHooks.push(plugin.onResultProcess);
        }
      }
    }
  }
  async getResultForParams({ params, request }, ...args) {
    try {
      let result;
      for (const onParamsHook of this.onParamsHooks) {
        await onParamsHook({
          params,
          request,
          setParams(newParams) {
            params = newParams;
          },
          setResult(newResult) {
            result = newResult;
          },
          fetchAPI: this.fetchAPI
        });
      }
      if (result == null) {
        const serverContext = args[0];
        const initialContext = {
          ...serverContext,
          request,
          params
        };
        const enveloped = this.getEnveloped(initialContext);
        this.logger.debug(`Processing GraphQL Parameters`);
        result = await processRequest({
          params,
          enveloped
        });
        this.logger.debug(`Processing GraphQL Parameters done.`);
      }
      return result;
    } catch (error8) {
      const errors4 = handleError(error8, this.maskedErrorsOpts, this.logger);
      const result = {
        errors: errors4
      };
      return result;
    }
  }
}

// src/env.ts
var envsToCheck = {
  PATH_TO_BUILDS: [true, false],
  NODE_ENV: [false, false],
  PORT: [false, false]
};
var env = {};
console.log("\x1B[2mEnvironment variables:\x1B[0m");
for (const [envKey, [required, sensitive]] of Object.entries(envsToCheck)) {
  const envValue = process.env[envKey];
  if (required && !envValue) {
    throw `\x1B[31mEnvironment variable ${envKey} is required but not set.\x1B[0m`;
  }
  if (sensitive) {
    console.log(`\x1B[2m  ${envKey}: ${envValue ? `***${envValue.slice(-15)}` : undefined}\x1B[0m`);
  } else {
    console.log(`\x1B[2m  ${envKey}: ${envValue}\x1B[0m`);
  }
  env[envKey] = envValue;
  delete process.env[envKey];
}

// ../../node_modules/@graphql-codegen/plugin-helpers/esm/federation.js
var merge2 = __toESM(require_merge(), 1);
function removeFederation(schema5) {
  return mapSchema(schema5, {
    [MapperKind.QUERY]: (queryType) => {
      const queryTypeConfig = queryType.toConfig();
      delete queryTypeConfig.fields._entities;
      delete queryTypeConfig.fields._service;
      return new GraphQLObjectType(queryTypeConfig);
    },
    [MapperKind.UNION_TYPE]: (unionType) => {
      const unionTypeName = unionType.name;
      if (unionTypeName === "_Entity" || unionTypeName === "_Any") {
        return null;
      }
      return unionType;
    },
    [MapperKind.OBJECT_TYPE]: (objectType) => {
      if (objectType.name === "_Service") {
        return null;
      }
      return objectType;
    }
  });
}
var federationSpec = parse(`
  scalar _FieldSet

  directive @external on FIELD_DEFINITION
  directive @requires(fields: _FieldSet!) on FIELD_DEFINITION
  directive @provides(fields: _FieldSet!) on FIELD_DEFINITION
  directive @key(fields: _FieldSet!) on OBJECT | INTERFACE
`);
// ../../node_modules/@graphql-codegen/plugin-helpers/esm/getCachedDocumentNodeFromSchema.js
var getCachedDocumentNodeFromSchema = memoize1(getDocumentNodeFromSchema);
// ../../node_modules/@graphql-codegen/plugin-helpers/esm/oldVisit.js
function oldVisit(root, { enter: enterVisitors, leave: leaveVisitors, ...newVisitor }) {
  if (typeof enterVisitors === "object") {
    for (const key in enterVisitors) {
      newVisitor[key] ||= {};
      newVisitor[key].enter = enterVisitors[key];
    }
  }
  if (typeof leaveVisitors === "object") {
    for (const key in leaveVisitors) {
      newVisitor[key] ||= {};
      newVisitor[key].leave = leaveVisitors[key];
    }
  }
  return visit(root, newVisitor);
}
// ../../node_modules/@graphql-codegen/plugin-helpers/esm/profiler.js
function createNoopProfiler() {
  return {
    run(fn) {
      return Promise.resolve().then(() => fn());
    },
    collect() {
      return [];
    }
  };
}
// ../../node_modules/@graphql-codegen/plugin-helpers/esm/resolve-external-module-and-fn.js
var changeCaseAll = __toESM(require_dist22(), 1);
import {createRequire} from "module";
import {cwd} from "process";
function resolveExternalModuleAndFn(pointer) {
  if (typeof pointer === "function") {
    return pointer;
  }
  let [moduleName, functionName] = pointer.split("#");
  if (moduleName === "change-case") {
    moduleName = "change-case-all";
  }
  let loadedModule;
  if (moduleName === "change-case-all") {
    loadedModule = changeCaseAll;
  } else {
    const cwdRequire = createRequire(cwd() + "/index.js");
    loadedModule = cwdRequire(moduleName);
    if (!(functionName in loadedModule) && typeof loadedModule !== "function") {
      throw new Error(`${functionName} couldn't be found in module ${moduleName}!`);
    }
  }
  return loadedModule[functionName] || loadedModule;
}
// ../../node_modules/@graphql-codegen/plugin-helpers/esm/types.js
function isComplexPluginOutput(obj) {
  return typeof obj === "object" && Object.prototype.hasOwnProperty.call(obj, "content");
}
// ../../node_modules/@graphql-codegen/core/esm/execute-plugin.js
async function executePlugin(options, plugin) {
  if (!plugin?.plugin || typeof plugin.plugin !== "function") {
    throw new Error(`Invalid Custom Plugin "${options.name}" \n
        Plugin ${options.name} does not export a valid JS object with "plugin" function.

        Make sure your custom plugin is written in the following form:

        module.exports = {
          plugin: (schema, documents, config) => {
            return 'my-custom-plugin-content';
          },
        };
        `);
  }
  const outputSchema = options.schemaAst || buildASTSchema(options.schema, options.config);
  const documents = options.documents || [];
  const pluginContext = options.pluginContext || {};
  const profiler2 = options.profiler ?? createNoopProfiler();
  if (plugin.validate && typeof plugin.validate === "function") {
    try {
      await profiler2.run(async () => plugin.validate(outputSchema, documents, options.config, options.outputFilename, options.allPlugins, pluginContext), `Plugin ${options.name} validate`);
    } catch (e) {
      throw new Error(`Plugin "${options.name}" validation failed: \n
            ${e.message}
          `);
    }
  }
  return profiler2.run(() => Promise.resolve(plugin.plugin(outputSchema, documents, typeof options.config === "object" ? { ...options.config } : options.config, {
    outputFile: options.outputFilename,
    allPlugins: options.allPlugins,
    pluginContext
  })), `Plugin ${options.name} execution`);
}

// ../../node_modules/@graphql-codegen/core/esm/utils.js
function isObjectMap(obj) {
  return obj && typeof obj === "object" && !Array.isArray(obj);
}
function prioritize(...values4) {
  const picked = values4.find((val) => typeof val === "boolean");
  if (typeof picked !== "boolean") {
    return values4[values4.length - 1];
  }
  return picked;
}
function pickFlag(flag, config) {
  return isObjectMap(config) ? config[flag] : undefined;
}
function shouldValidateDuplicateDocuments(skipDocumentsValidationOption) {
  if (skipDocumentsValidationOption === true) {
    return false;
  }
  if (typeof skipDocumentsValidationOption === "object" && skipDocumentsValidationOption.skipDuplicateValidation) {
    return false;
  }
  return true;
}
function shouldValidateDocumentsAgainstSchema(skipDocumentsValidationOption) {
  if (skipDocumentsValidationOption === true) {
    return false;
  }
  if (typeof skipDocumentsValidationOption === "object" && skipDocumentsValidationOption.skipValidationAgainstSchema) {
    return false;
  }
  return true;
}
function getSkipDocumentsValidationOption(options) {
  if (options.skipDocumentsValidation) {
    return options.skipDocumentsValidation;
  }
  const flagFromConfig = pickFlag("skipDocumentsValidation", options.config);
  if (flagFromConfig) {
    return flagFromConfig;
  }
  return false;
}
function hasFederationSpec(schemaOrAST) {
  if (isSchema(schemaOrAST)) {
    return federationDirectives.some((directive) => schemaOrAST.getDirective(directive));
  }
  if (isDocumentNode(schemaOrAST)) {
    return schemaOrAST.definitions.some((def) => def.kind === Kind.DIRECTIVE_DEFINITION && federationDirectives.includes(def.name.value));
  }
  return false;
}
function extractHashFromSchema(schema5) {
  schema5.extensions ||= {};
  return schema5.extensions["hash"] ?? null;
}
var federationDirectives = ["key", "requires", "provides", "external"];

// ../../node_modules/@graphql-codegen/core/esm/transform-document.js
async function transformDocuments(options) {
  const documentTransforms = options.documentTransforms || [];
  let documents = options.documents;
  if (documentTransforms.length === 0 || options.documents.length === 0) {
    return documents;
  }
  const profiler2 = options.profiler ?? createNoopProfiler();
  for (const documentTransform of documentTransforms) {
    const config = typeof documentTransform.config === "object" ? {
      ...options.config,
      ...documentTransform.config
    } : {};
    const { transform } = documentTransform.transformObject;
    if (transform && typeof transform === "function") {
      const name = documentTransform.name;
      try {
        await profiler2.run(async () => {
          documents = await transform({
            documents,
            schema: options.schema,
            config,
            pluginContext: options.pluginContext
          });
        }, `DocumentTransform "${name}" execution`);
      } catch (e) {
        throw new Error(`DocumentTransform "${name}" failed: \n
            ${e.message}
          `);
      }
    } else {
      throw new Error(`Missing 'transform' function in "${documentTransform.name}"`);
    }
  }
  return documents;
}

// ../../node_modules/@graphql-codegen/core/esm/codegen.js
async function codegen(options) {
  const documents = options.documents || [];
  const profiler2 = options.profiler ?? createNoopProfiler();
  const skipDocumentsValidation = getSkipDocumentsValidationOption(options);
  if (documents.length > 0 && shouldValidateDuplicateDocuments(skipDocumentsValidation)) {
    await profiler2.run(async () => validateDuplicateDocuments(documents), "validateDuplicateDocuments");
  }
  const pluginPackages = Object.keys(options.pluginMap).map((key) => options.pluginMap[key]);
  const additionalTypeDefs = [];
  for (const plugin of pluginPackages) {
    const addToSchema = typeof plugin.addToSchema === "function" ? plugin.addToSchema(options.config) : plugin.addToSchema;
    if (addToSchema) {
      additionalTypeDefs.push(addToSchema);
    }
  }
  const federationInConfig = pickFlag("federation", options.config);
  const isFederation = prioritize(federationInConfig, false);
  if (isFederation && !hasFederationSpec(options.schemaAst || options.schema)) {
    additionalTypeDefs.push(federationSpec);
  }
  const mergeNeeded = !options.schemaAst || additionalTypeDefs.length > 0;
  const schemaInstance = await profiler2.run(async () => {
    return mergeNeeded ? mergeSchemas({
      schemas: options.schemaAst ? [options.schemaAst] : [],
      typeDefs: options.schemaAst ? additionalTypeDefs : [options.schema, ...additionalTypeDefs],
      convertExtensions: true,
      assumeValid: true,
      assumeValidSDL: true,
      ...options.config
    }) : options.schemaAst;
  }, "Create schema instance");
  const schemaDocumentNode = mergeNeeded || !options.schema ? getCachedDocumentNodeFromSchema(schemaInstance) : options.schema;
  const documentTransforms = Array.isArray(options.documentTransforms) ? options.documentTransforms : [];
  const transformedDocuments = await transformDocuments({
    ...options,
    documentTransforms,
    schema: schemaDocumentNode,
    schemaAst: schemaInstance,
    profiler: profiler2
  });
  if (schemaInstance && transformedDocuments.length > 0 && shouldValidateDocumentsAgainstSchema(skipDocumentsValidation)) {
    const ignored = ["NoUnusedFragments", "NoUnusedVariables", "KnownDirectives"];
    if (typeof skipDocumentsValidation === "object" && skipDocumentsValidation.ignoreRules) {
      ignored.push(...asArray(skipDocumentsValidation.ignoreRules));
    }
    const extraFragments = pickFlag("externalFragments", options.config) || [];
    const errors4 = await profiler2.run(() => {
      const fragments = extraFragments.map((f) => ({
        location: f.importFrom,
        document: { kind: Kind.DOCUMENT, definitions: [f.node] }
      }));
      const rules = specifiedRules.filter((rule) => !ignored.some((ignoredRule) => rule.name.startsWith(ignoredRule)));
      const schemaHash = extractHashFromSchema(schemaInstance);
      if (!schemaHash || !options.cache || transformedDocuments.some((d) => typeof d.hash !== "string")) {
        return Promise.resolve(validateGraphQlDocuments(schemaInstance, [...transformedDocuments.flatMap((d) => d.document), ...fragments.flatMap((f) => f.document)], rules));
      }
      const cacheKey = [schemaHash].concat(transformedDocuments.map((doc) => doc.hash)).concat(JSON.stringify(fragments)).join(",");
      return options.cache("documents-validation", cacheKey, () => Promise.resolve(validateGraphQlDocuments(schemaInstance, [...transformedDocuments.flatMap((d) => d.document), ...fragments.flatMap((f) => f.document)], rules)));
    }, "Validate documents against schema");
    if (errors4.length > 0) {
      throw new Error(`GraphQL Document Validation failed with ${errors4.length} errors;
  ${errors4.map((error8, index) => `Error ${index}: ${error8.stack}`).join("\n\n")}`);
    }
  }
  const prepend = new Set;
  const append = new Set;
  const output = await Promise.all(options.plugins.map(async (plugin) => {
    const name = Object.keys(plugin)[0];
    const pluginPackage = options.pluginMap[name];
    const pluginConfig = plugin[name] || {};
    const execConfig = typeof pluginConfig === "object" ? { ...options.config, ...pluginConfig } : pluginConfig;
    const result = await profiler2.run(() => executePlugin({
      name,
      config: execConfig,
      parentConfig: options.config,
      schema: schemaDocumentNode,
      schemaAst: schemaInstance,
      documents: transformedDocuments,
      outputFilename: options.filename,
      allPlugins: options.plugins,
      skipDocumentsValidation: options.skipDocumentsValidation,
      pluginContext: options.pluginContext,
      profiler: profiler2
    }, pluginPackage), `Plugin ${name}`);
    if (typeof result === "string") {
      return result || "";
    }
    if (isComplexPluginOutput(result)) {
      if (result.append && result.append.length > 0) {
        for (const item of result.append) {
          if (item) {
            append.add(item);
          }
        }
      }
      if (result.prepend && result.prepend.length > 0) {
        for (const item of result.prepend) {
          if (item) {
            prepend.add(item);
          }
        }
      }
      return result.content || "";
    }
    return "";
  }));
  return [...sortPrependValues(Array.from(prepend.values())), ...output, ...Array.from(append.values())].filter(Boolean).join("\n");
}
var resolveCompareValue = function(a) {
  if (a.startsWith("/*") || a.startsWith("//") || a.startsWith(" *") || a.startsWith(" */") || a.startsWith("*/")) {
    return 0;
  }
  if (a.startsWith("package")) {
    return 1;
  }
  if (a.startsWith("import")) {
    return 2;
  }
  return 3;
};
function sortPrependValues(values4) {
  return values4.sort((a, b) => {
    const aV = resolveCompareValue(a);
    const bV = resolveCompareValue(b);
    if (aV < bV) {
      return -1;
    }
    if (aV > bV) {
      return 1;
    }
    return 0;
  });
}
var validateDuplicateDocuments = function(files) {
  const definitionMap = {};
  function addDefinition(file, node, deduplicatedDefinitions) {
    if (typeof node.name !== "undefined") {
      definitionMap[node.kind] ||= {};
      definitionMap[node.kind][node.name.value] ||= {
        paths: new Set,
        contents: new Set
      };
      const definitionKindMap = definitionMap[node.kind];
      const length = definitionKindMap[node.name.value].contents.size;
      definitionKindMap[node.name.value].paths.add(file.location);
      definitionKindMap[node.name.value].contents.add(print(node));
      if (length === definitionKindMap[node.name.value].contents.size) {
        return null;
      }
    }
    return deduplicatedDefinitions.add(node);
  }
  for (const file of files) {
    const deduplicatedDefinitions = new Set;
    visit(file.document, {
      OperationDefinition(node) {
        addDefinition(file, node, deduplicatedDefinitions);
      },
      FragmentDefinition(node) {
        addDefinition(file, node, deduplicatedDefinitions);
      }
    });
    file.document.definitions = Array.from(deduplicatedDefinitions);
  }
  const kinds31 = Object.keys(definitionMap);
  for (const kind of kinds31) {
    const definitionKindMap = definitionMap[kind];
    const names = Object.keys(definitionKindMap);
    if (names.length) {
      const duplicated = names.filter((name) => definitionKindMap[name].contents.size > 1);
      if (!duplicated.length) {
        continue;
      }
      const list = duplicated.map((name) => `
        * ${name} found in:
          ${[...definitionKindMap[name].paths].map((filepath) => {
        return `
              - ${filepath}
            `.trimEnd();
      }).join("")}
    `.trimEnd()).join("");
      const definitionKindName = kind.replace("Definition", "").toLowerCase();
      throw new Error(`Not all ${definitionKindName}s have an unique name: ${duplicated.join(", ")}: \n
          ${list}
        `);
    }
  }
};
// ../../node_modules/@graphql-codegen/typescript/esm/index.js
var exports_esm = {};
__export(exports_esm, {
  plugin: () => {
    {
      return plugin;
    }
  },
  includeIntrospectionTypesDefinitions: () => {
    {
      return includeIntrospectionTypesDefinitions;
    }
  },
  TypeScriptOperationVariablesToObject: () => {
    {
      return TypeScriptOperationVariablesToObject;
    }
  },
  TsVisitor: () => {
    {
      return TsVisitor;
    }
  },
  TsIntrospectionVisitor: () => {
    {
      return TsIntrospectionVisitor;
    }
  },
  MAKE_OPTIONAL_SIGNATURE: () => {
    {
      return MAKE_OPTIONAL_SIGNATURE;
    }
  },
  MAKE_MAYBE_SIGNATURE: () => {
    {
      return MAKE_MAYBE_SIGNATURE;
    }
  },
  MAKE_INCREMENTAL_SIGNATURE: () => {
    {
      return MAKE_INCREMENTAL_SIGNATURE;
    }
  },
  MAKE_EMPTY_SIGNATURE: () => {
    {
      return MAKE_EMPTY_SIGNATURE;
    }
  },
  EXACT_SIGNATURE: () => {
    {
      return EXACT_SIGNATURE;
    }
  }
});

// ../../node_modules/@graphql-codegen/schema-ast/esm/index.js
function transformSchemaAST(schema6, config) {
  schema6 = config.federation ? removeFederation(schema6) : schema6;
  if (config.includeIntrospectionTypes) {
    const introspectionAST = parse(`
      extend type Query {
        __schema: __Schema!
        __type(name: String!): __Type
      }
    `);
    schema6 = extendSchema(schema6, introspectionAST);
  }
  let ast8 = getCachedDocumentNodeFromSchema(schema6);
  ast8 = config.disableDescriptions ? visit(ast8, {
    leave: (node) => ({
      ...node,
      description: undefined
    })
  }) : ast8;
  schema6 = config.disableDescriptions ? buildASTSchema(ast8) : schema6;
  return {
    schema: schema6,
    ast: ast8
  };
}

// ../../node_modules/@graphql-codegen/typescript/esm/introspection-visitor.js
var import_auto_bind8 = __toESM(require_auto_bind(), 1);

// ../../node_modules/@graphql-codegen/visitor-plugin-common/esm/avoid-optionals.js
function normalizeAvoidOptionals(avoidOptionals) {
  if (typeof avoidOptionals === "boolean") {
    return {
      object: avoidOptionals,
      inputValue: avoidOptionals,
      field: avoidOptionals,
      defaultValue: avoidOptionals,
      resolvers: avoidOptionals
    };
  }
  return {
    ...DEFAULT_AVOID_OPTIONALS,
    ...avoidOptionals
  };
}
var DEFAULT_AVOID_OPTIONALS = {
  object: false,
  inputValue: false,
  field: false,
  defaultValue: false,
  resolvers: false
};
// ../../node_modules/@graphql-codegen/visitor-plugin-common/esm/base-documents-visitor.js
var import_auto_bind3 = __toESM(require_auto_bind(), 1);
var import_change_case_all2 = __toESM(require_dist22(), 1);

// ../../node_modules/@graphql-codegen/visitor-plugin-common/esm/base-visitor.js
var import_auto_bind = __toESM(require_auto_bind(), 1);

// ../../node_modules/@graphql-codegen/visitor-plugin-common/esm/naming.js
var import_change_case_all = __toESM(require_dist22(), 1);

// ../../node_modules/@graphql-codegen/visitor-plugin-common/esm/mappers.js
var prepareLegacy = function(mapper) {
  const isScoped = mapper.includes("\\#");
  if (mapper.includes("\\#")) {
    mapper = mapper.replace("\\#", "");
  }
  const items = mapper.split("#");
  const isNamespace = items.length === 3;
  const isDefault = items[1].trim() === "default" || items[1].startsWith("default ");
  const hasAlias = items[1].includes(" as ");
  const source2 = isScoped ? `#${items[0]}` : items[0];
  items[0] = source2;
  return {
    items,
    isDefault,
    isNamespace,
    hasAlias
  };
};
var prepare = function(mapper) {
  const isScoped = mapper.includes("\\#");
  if (mapper.includes("\\#")) {
    mapper = mapper.replace("\\#", "");
  }
  let [source2, path] = mapper.split("#");
  const isNamespace = path.includes(".");
  const isDefault = path.trim() === "default" || path.startsWith("default ");
  const hasAlias = path.includes(" as ");
  source2 = isScoped ? `#${source2}` : source2;
  return {
    items: isNamespace ? [source2, ...path.split(".")] : [source2, path],
    isDefault,
    isNamespace,
    hasAlias
  };
};
var isLegacyMode = function(mapper) {
  if (mapper.includes("\\#")) {
    mapper = mapper.replace("\\#", "");
  }
  return mapper.split("#").length === 3;
};
function parseMapper(mapper, gqlTypeName = null, suffix) {
  if (isExternalMapper(mapper)) {
    let handleAlias = function(isDefault2 = false) {
      const [importedType, aliasType] = items[1].split(/\s+as\s+/);
      const type3 = maybeSuffix(aliasType);
      return {
        importElement: isDefault2 ? type3 : `${importedType} as ${type3}`,
        type: type3
      };
    }, maybeSuffix = function(type3) {
      if (suffix) {
        return addSuffix(type3, suffix);
      }
      return type3;
    }, handle = function() {
      switch (mapperKind) {
        case MapperKind2.Namespace: {
          const [, ns, identifier] = items;
          return {
            type: `${ns}.${identifier}`,
            importElement: ns
          };
        }
        case MapperKind2.Default: {
          if (hasAlias) {
            return handleAlias(true);
          }
          const type3 = maybeSuffix(String(gqlTypeName));
          return {
            importElement: type3,
            type: type3
          };
        }
        case MapperKind2.Regular: {
          if (hasAlias) {
            return handleAlias();
          }
          const identifier = items[1];
          const type3 = maybeSuffix(identifier);
          return {
            type: type3,
            importElement: suffix ? `${identifier} as ${type3}` : type3
          };
        }
      }
    };
    const { isNamespace, isDefault, hasAlias, items } = isLegacyMode(mapper) ? prepareLegacy(mapper) : prepare(mapper);
    const mapperKind = isNamespace ? MapperKind2.Namespace : isDefault ? MapperKind2.Default : MapperKind2.Regular;
    const { type: type2, importElement } = handle();
    return {
      default: isDefault,
      isExternal: true,
      source: items[0],
      type: type2,
      import: importElement.replace(/<(.*?)>/g, "")
    };
  }
  return {
    isExternal: false,
    type: mapper
  };
}
var addSuffix = function(element, suffix) {
  const generic = element.indexOf("<");
  if (generic === -1) {
    return `${element}${suffix}`;
  }
  return `${element.slice(0, generic)}${suffix}${element.slice(generic)}`;
};
function isExternalMapper(value) {
  return value.includes("#");
}
function transformDirectiveArgumentAndInputFieldMappings(rawDirectiveArgumentAndInputFieldMappings, directiveArgumentAndInputFieldMappingTypeSuffix) {
  const result = {};
  for (const directive of Object.keys(rawDirectiveArgumentAndInputFieldMappings)) {
    const mapperDef = rawDirectiveArgumentAndInputFieldMappings[directive];
    const parsedMapper = parseMapper(mapperDef, directive, directiveArgumentAndInputFieldMappingTypeSuffix);
    result[directive] = parsedMapper;
  }
  return result;
}
var MapperKind2;
(function(MapperKind3) {
  MapperKind3[MapperKind3["Namespace"] = 0] = "Namespace";
  MapperKind3[MapperKind3["Default"] = 1] = "Default";
  MapperKind3[MapperKind3["Regular"] = 2] = "Regular";
})(MapperKind2 || (MapperKind2 = {}));

// ../../node_modules/@graphql-codegen/visitor-plugin-common/esm/scalars.js
var DEFAULT_SCALARS = {
  ID: {
    input: "string",
    output: "string"
  },
  String: {
    input: "string",
    output: "string"
  },
  Boolean: {
    input: "boolean",
    output: "boolean"
  },
  Int: {
    input: "number",
    output: "number"
  },
  Float: {
    input: "number",
    output: "number"
  }
};

// ../../node_modules/@graphql-codegen/visitor-plugin-common/esm/utils.js
function wrapWithSingleQuotes(value, skipNumericCheck = false) {
  if (skipNumericCheck) {
    if (typeof value === "number") {
      return String(value);
    }
    return `'${value}'`;
  }
  if (typeof value === "number" || typeof value === "string" && !Number.isNaN(parseInt(value)) && parseFloat(value).toString() === value) {
    return String(value);
  }
  return `'${value}'`;
}
function indent3(str, count = 1) {
  return new Array(count).fill("  ").join("") + str;
}
function transformComment(comment, indentLevel = 0, disabled = false) {
  if (!comment || comment === "" || disabled) {
    return "";
  }
  if (isStringValueNode(comment)) {
    comment = comment.value;
  }
  comment = comment.split("*/").join("*\\/");
  let lines = comment.split("\n");
  if (lines.length === 1) {
    return indent3(`/** ${lines[0]} */\n`, indentLevel);
  }
  lines = ["/**", ...lines.map((line) => ` * ${line}`), " */\n"];
  return stripTrailingSpaces(lines.map((line) => indent3(line, indentLevel)).join("\n"));
}
function getBaseTypeNode(typeNode) {
  if (typeNode.kind === Kind.LIST_TYPE || typeNode.kind === Kind.NON_NULL_TYPE) {
    return getBaseTypeNode(typeNode.type);
  }
  return typeNode;
}
function convertNameParts(str, func, removeUnderscore = false) {
  if (removeUnderscore) {
    return func(str);
  }
  return str.split("_").map((s) => func(s)).join("_");
}
function buildScalarsFromConfig(schema6, config, defaultScalarsMapping = DEFAULT_SCALARS, defaultScalarType = "any") {
  return buildScalars(schema6, config.scalars, defaultScalarsMapping, config.strictScalars ? null : config.defaultScalarType || defaultScalarType);
}
function buildScalars(schema6, scalarsMapping, defaultScalarsMapping = DEFAULT_SCALARS, defaultScalarType = "any") {
  const result = {};
  function normalizeScalarType(type2) {
    if (typeof type2 === "string") {
      return {
        input: type2,
        output: type2
      };
    }
    return {
      input: type2.input,
      output: type2.output
    };
  }
  for (const name of Object.keys(defaultScalarsMapping)) {
    result[name] = {
      input: parseMapper(defaultScalarsMapping[name].input),
      output: parseMapper(defaultScalarsMapping[name].output)
    };
  }
  if (schema6) {
    const typeMap = schema6.getTypeMap();
    Object.keys(typeMap).map((typeName) => typeMap[typeName]).filter((type2) => isScalarType(type2)).map((scalarType) => {
      const { name } = scalarType;
      if (typeof scalarsMapping === "string") {
        const inputMapper = parseMapper(scalarsMapping + "#" + name, name);
        if (inputMapper.isExternal) {
          inputMapper.type += "['input']";
        }
        const outputMapper = parseMapper(scalarsMapping + "#" + name, name);
        if (outputMapper.isExternal) {
          outputMapper.type += "['output']";
        }
        result[name] = {
          input: inputMapper,
          output: outputMapper
        };
      } else if (scalarsMapping?.[name]) {
        const mappedScalar = scalarsMapping[name];
        if (typeof mappedScalar === "string") {
          const normalizedScalar = normalizeScalarType(scalarsMapping[name]);
          result[name] = {
            input: parseMapper(normalizedScalar.input, name),
            output: parseMapper(normalizedScalar.output, name)
          };
        } else if (typeof mappedScalar === "object" && mappedScalar.input && mappedScalar.output) {
          result[name] = {
            input: parseMapper(mappedScalar.input, name),
            output: parseMapper(mappedScalar.output, name)
          };
        } else {
          result[name] = {
            input: {
              isExternal: false,
              type: JSON.stringify(mappedScalar)
            },
            output: {
              isExternal: false,
              type: JSON.stringify(mappedScalar)
            }
          };
        }
      } else if (scalarType.extensions?.codegenScalarType) {
        result[name] = {
          input: {
            isExternal: false,
            type: scalarType.extensions.codegenScalarType
          },
          output: {
            isExternal: false,
            type: scalarType.extensions.codegenScalarType
          }
        };
      } else if (!defaultScalarsMapping[name]) {
        if (defaultScalarType === null) {
          throw new Error(`Unknown scalar type ${name}. Please override it using the "scalars" configuration field!`);
        }
        result[name] = {
          input: {
            isExternal: false,
            type: defaultScalarType
          },
          output: {
            isExternal: false,
            type: defaultScalarType
          }
        };
      }
    });
  } else if (scalarsMapping) {
    if (typeof scalarsMapping === "string") {
      throw new Error("Cannot use string scalars mapping when building without a schema");
    }
    for (const name of Object.keys(scalarsMapping)) {
      if (typeof scalarsMapping[name] === "string") {
        const normalizedScalar = normalizeScalarType(scalarsMapping[name]);
        result[name] = {
          input: parseMapper(normalizedScalar.input, name),
          output: parseMapper(normalizedScalar.output, name)
        };
      } else {
        const normalizedScalar = normalizeScalarType(scalarsMapping[name]);
        result[name] = {
          input: {
            isExternal: false,
            type: JSON.stringify(normalizedScalar.input)
          },
          output: {
            isExternal: false,
            type: JSON.stringify(normalizedScalar.output)
          }
        };
      }
    }
  }
  return result;
}
var isStringValueNode = function(node) {
  return node && typeof node === "object" && node.kind === Kind.STRING;
};
var stripTrailingSpaces = function(str) {
  return str.replace(/ +\n/g, "\n");
};
function isOneOfInputObjectType(namedType) {
  if (!namedType) {
    return false;
  }
  let isOneOfType = isOneOfTypeCache.get(namedType);
  if (isOneOfType !== undefined) {
    return isOneOfType;
  }
  isOneOfType = isInputObjectType(namedType) && (namedType.isOneOf || namedType.astNode?.directives?.some((d) => d.name.value === "oneOf"));
  isOneOfTypeCache.set(namedType, isOneOfType);
  return isOneOfType;
}
var getConfigValue = (value, defaultValue) => {
  if (value === null || value === undefined) {
    return defaultValue;
  }
  return value;
};

class DeclarationBlock {
  constructor(_config) {
    this._config = _config;
    this._decorator = null;
    this._export = false;
    this._name = null;
    this._kind = null;
    this._methodName = null;
    this._content = null;
    this._block = null;
    this._nameGenerics = null;
    this._comment = null;
    this._ignoreBlockWrapper = false;
    this._config = {
      blockWrapper: "",
      blockTransformer: (block3) => block3,
      enumNameValueSeparator: ":",
      ...this._config
    };
  }
  withDecorator(decorator) {
    this._decorator = decorator;
    return this;
  }
  export(exp = true) {
    if (!this._config.ignoreExport) {
      this._export = exp;
    }
    return this;
  }
  asKind(kind) {
    this._kind = kind;
    return this;
  }
  withComment(comment, disabled = false) {
    const nonEmptyComment = !!(isStringValueNode(comment) ? comment.value : comment);
    if (nonEmptyComment && !disabled) {
      this._comment = transformComment(comment, 0);
    }
    return this;
  }
  withMethodCall(methodName, ignoreBlockWrapper = false) {
    this._methodName = methodName;
    this._ignoreBlockWrapper = ignoreBlockWrapper;
    return this;
  }
  withBlock(block3) {
    this._block = block3;
    return this;
  }
  withContent(content) {
    this._content = content;
    return this;
  }
  withName(name, generics = null) {
    this._name = name;
    this._nameGenerics = generics;
    return this;
  }
  get string() {
    let result = "";
    if (this._decorator) {
      result += this._decorator + "\n";
    }
    if (this._export) {
      result += "export ";
    }
    if (this._kind) {
      let extra = "";
      let name = "";
      if (["type", "const", "var", "let"].includes(this._kind)) {
        extra = "= ";
      }
      if (this._name) {
        name = this._name + (this._nameGenerics || "") + " ";
      }
      result += this._kind + " " + name + extra;
    }
    if (this._block) {
      if (this._content) {
        result += this._content;
      }
      const blockWrapper = this._ignoreBlockWrapper ? "" : this._config.blockWrapper;
      const before = "{" + blockWrapper;
      const after = blockWrapper + "}";
      const block3 = [before, this._block, after].filter((val) => !!val).join("\n");
      if (this._methodName) {
        result += `${this._methodName}(${this._config.blockTransformer(block3)})`;
      } else {
        result += this._config.blockTransformer(block3);
      }
    } else if (this._content) {
      result += this._content;
    } else if (this._kind) {
      result += this._config.blockTransformer("{}");
    }
    return stripTrailingSpaces((this._comment || "") + result + (this._kind === "interface" || this._kind === "enum" || this._kind === "namespace" || this._kind === "function" ? "" : ";") + "\n");
  }
}
var isOneOfTypeCache = new WeakMap;

// ../../node_modules/@graphql-codegen/visitor-plugin-common/esm/naming.js
var getKind = function(node) {
  if (typeof node === "string") {
    return "typeNames";
  }
  if (["EnumValueDefinition", "EnumValue"].includes(node.kind)) {
    return "enumValues";
  }
  return "typeNames";
};
var getName = function(node) {
  if (node == null) {
    return;
  }
  if (typeof node === "string") {
    return node;
  }
  switch (node.kind) {
    case "OperationDefinition":
    case "Variable":
    case "Argument":
    case "FragmentSpread":
    case "FragmentDefinition":
    case "ObjectField":
    case "Directive":
    case "NamedType":
    case "ScalarTypeDefinition":
    case "ObjectTypeDefinition":
    case "FieldDefinition":
    case "InputValueDefinition":
    case "InterfaceTypeDefinition":
    case "UnionTypeDefinition":
    case "EnumTypeDefinition":
    case "EnumValueDefinition":
    case "InputObjectTypeDefinition":
    case "DirectiveDefinition": {
      return getName(node.name);
    }
    case "Name": {
      return node.value;
    }
    case "Field": {
      return getName(node.alias || node.name);
    }
    case "VariableDefinition": {
      return getName(node.variable);
    }
  }
  return;
};
function convertFactory(config) {
  function resolveConventionName(type2) {
    if (!config.namingConvention) {
      return (str, opts = {}) => {
        return convertNameParts(str, import_change_case_all.pascalCase, getConfigValue(opts?.transformUnderscore, false));
      };
    }
    if (typeof config.namingConvention === "string") {
      if (config.namingConvention === "keep") {
        return (str) => str;
      }
      return (str, opts = {}) => {
        return convertNameParts(str, resolveExternalModuleAndFn(config.namingConvention), getConfigValue(opts?.transformUnderscore, false));
      };
    }
    if (typeof config.namingConvention === "function") {
      return (str, opts = {}) => {
        return convertNameParts(str, config.namingConvention, getConfigValue(opts?.transformUnderscore, false));
      };
    }
    if (typeof config.namingConvention === "object" && config.namingConvention[type2] === "keep") {
      return (str) => str;
    }
    if (typeof config.namingConvention === "object") {
      if (!config.namingConvention[type2]) {
        return (str, opts = {}) => {
          const transformUnderscore = config.namingConvention.transformUnderscore || opts?.transformUnderscore;
          return convertNameParts(str, import_change_case_all.pascalCase, getConfigValue(transformUnderscore, false));
        };
      }
      return (str, opts = {}) => {
        return convertNameParts(str, resolveExternalModuleAndFn(config.namingConvention[type2]), getConfigValue(opts?.transformUnderscore, true));
      };
    }
    return config.namingConvention[type2];
  }
  return (node, opts) => {
    const prefix = opts?.prefix;
    const suffix = opts?.suffix;
    const kind = getKind(node);
    const str = [prefix || "", getName(node), suffix || ""].join("");
    return resolveConventionName(kind)(str, opts);
  };
}

// ../../node_modules/@graphql-codegen/visitor-plugin-common/esm/base-visitor.js
class BaseVisitor {
  constructor(rawConfig, additionalConfig) {
    this._declarationBlockConfig = {};
    this._parsedConfig = {
      convert: convertFactory(rawConfig),
      typesPrefix: rawConfig.typesPrefix || "",
      typesSuffix: rawConfig.typesSuffix || "",
      externalFragments: rawConfig.externalFragments || [],
      fragmentImports: rawConfig.fragmentImports || [],
      addTypename: !rawConfig.skipTypename,
      nonOptionalTypename: !!rawConfig.nonOptionalTypename,
      useTypeImports: !!rawConfig.useTypeImports,
      dedupeFragments: !!rawConfig.dedupeFragments,
      allowEnumStringTypes: !!rawConfig.allowEnumStringTypes,
      inlineFragmentTypes: rawConfig.inlineFragmentTypes ?? "inline",
      emitLegacyCommonJSImports: rawConfig.emitLegacyCommonJSImports === undefined ? true : !!rawConfig.emitLegacyCommonJSImports,
      extractAllFieldsToTypes: rawConfig.extractAllFieldsToTypes ?? false,
      printFieldsOnNewLines: rawConfig.printFieldsOnNewLines ?? false,
      ...additionalConfig || {}
    };
    this.scalars = {};
    for (const key of Object.keys(this.config.scalars || {})) {
      this.scalars[key] = {
        input: this.config.scalars[key]?.input?.type,
        output: this.config.scalars[key]?.output?.type
      };
    }
    import_auto_bind.default(this);
  }
  getVisitorKindContextFromAncestors(ancestors) {
    if (!ancestors) {
      return [];
    }
    return ancestors.map((t) => t.kind).filter(Boolean);
  }
  get config() {
    return this._parsedConfig;
  }
  convertName(node, options) {
    const useTypesPrefix = typeof options?.useTypesPrefix === "boolean" ? options.useTypesPrefix : true;
    const useTypesSuffix = typeof options?.useTypesSuffix === "boolean" ? options.useTypesSuffix : true;
    let convertedName = "";
    if (useTypesPrefix) {
      convertedName += this.config.typesPrefix;
    }
    convertedName += this.config.convert(node, options);
    if (useTypesSuffix) {
      convertedName += this.config.typesSuffix;
    }
    return convertedName;
  }
  getOperationSuffix(node, operationType) {
    const { omitOperationSuffix = false, dedupeOperationSuffix = false } = this.config;
    const operationName = typeof node === "string" ? node : node.name ? node.name.value : "";
    return omitOperationSuffix ? "" : dedupeOperationSuffix && operationName.toLowerCase().endsWith(operationType.toLowerCase()) ? "" : operationType;
  }
  getFragmentSuffix(node) {
    return this.getOperationSuffix(node, "Fragment");
  }
  getFragmentName(node) {
    return this.convertName(node, {
      suffix: this.getFragmentSuffix(node),
      useTypesPrefix: false
    });
  }
  getFragmentVariableName(node) {
    const { omitOperationSuffix = false, dedupeOperationSuffix = false, fragmentVariableSuffix = "FragmentDoc", fragmentVariablePrefix = "" } = this.config;
    const fragmentName = typeof node === "string" ? node : node.name.value;
    const suffix = omitOperationSuffix ? "" : dedupeOperationSuffix && fragmentName.toLowerCase().endsWith("fragment") && fragmentVariableSuffix.toLowerCase().startsWith("fragment") ? fragmentVariableSuffix.substring("fragment".length) : fragmentVariableSuffix;
    return this.convertName(node, {
      prefix: fragmentVariablePrefix,
      suffix,
      useTypesPrefix: false
    });
  }
  getPunctuation(_declarationKind) {
    return "";
  }
}

// ../../node_modules/@graphql-codegen/visitor-plugin-common/esm/variables-to-object.js
var import_auto_bind2 = __toESM(require_auto_bind(), 1);
class OperationVariablesToObject {
  constructor(_scalars, _convertName, _namespacedImportName = null, _enumNames = [], _enumPrefix = true, _enumSuffix = true, _enumValues = {}, _applyCoercion = false, _directiveArgumentAndInputFieldMappings = {}) {
    this._scalars = _scalars;
    this._convertName = _convertName;
    this._namespacedImportName = _namespacedImportName;
    this._enumNames = _enumNames;
    this._enumPrefix = _enumPrefix;
    this._enumSuffix = _enumSuffix;
    this._enumValues = _enumValues;
    this._applyCoercion = _applyCoercion;
    this._directiveArgumentAndInputFieldMappings = _directiveArgumentAndInputFieldMappings;
    import_auto_bind2.default(this);
  }
  getName(node) {
    if (node.name) {
      if (typeof node.name === "string") {
        return node.name;
      }
      return node.name.value;
    }
    if (node.variable) {
      return node.variable.name.value;
    }
    return null;
  }
  transform(variablesNode) {
    if (!variablesNode || variablesNode.length === 0) {
      return null;
    }
    return variablesNode.map((variable) => indent3(this.transformVariable(variable))).join(`${this.getPunctuation()}\n`) + this.getPunctuation();
  }
  getScalar(name) {
    const prefix = this._namespacedImportName ? `${this._namespacedImportName}.` : "";
    return `${prefix}Scalars['${name}']['input']`;
  }
  getDirectiveMapping(name) {
    return `DirectiveArgumentAndInputFieldMappings['${name}']`;
  }
  getDirectiveOverrideType(directives24) {
    if (!this._directiveArgumentAndInputFieldMappings)
      return null;
    const type2 = directives24.map((directive) => {
      const directiveName = directive.name.value;
      if (this._directiveArgumentAndInputFieldMappings[directiveName]) {
        return this.getDirectiveMapping(directiveName);
      }
      return null;
    }).reverse().find((a) => !!a);
    return type2 || null;
  }
  transformVariable(variable) {
    let typeValue = null;
    const prefix = this._namespacedImportName ? `${this._namespacedImportName}.` : "";
    if (typeof variable.type === "string") {
      typeValue = variable.type;
    } else {
      const baseType = getBaseTypeNode(variable.type);
      const overrideType = variable.directives ? this.getDirectiveOverrideType(variable.directives) : null;
      const typeName = baseType.name.value;
      if (overrideType) {
        typeValue = overrideType;
      } else if (this._scalars[typeName]) {
        typeValue = this.getScalar(typeName);
      } else if (this._enumValues[typeName]?.sourceFile) {
        typeValue = this._enumValues[typeName].typeIdentifier || this._enumValues[typeName].sourceIdentifier;
      } else {
        typeValue = `${prefix}${this._convertName(baseType, {
          useTypesPrefix: this._enumNames.includes(typeName) ? this._enumPrefix : true,
          useTypesSuffix: this._enumNames.includes(typeName) ? this._enumSuffix : true
        })}`;
      }
    }
    const fieldName = this.getName(variable);
    const fieldType = this.wrapAstTypeWithModifiers(typeValue, variable.type, this._applyCoercion);
    const hasDefaultValue = variable.defaultValue != null && typeof variable.defaultValue !== "undefined";
    const isNonNullType2 = variable.type.kind === Kind.NON_NULL_TYPE;
    const formattedFieldString = this.formatFieldString(fieldName, isNonNullType2, hasDefaultValue);
    const formattedTypeString = this.formatTypeString(fieldType, isNonNullType2, hasDefaultValue);
    return `${formattedFieldString}: ${formattedTypeString}`;
  }
  wrapAstTypeWithModifiers(_baseType, _typeNode, _applyCoercion) {
    throw new Error(`You must override "wrapAstTypeWithModifiers" of OperationVariablesToObject!`);
  }
  formatFieldString(fieldName, _isNonNullType, _hasDefaultValue) {
    return fieldName;
  }
  formatTypeString(fieldType, isNonNullType2, hasDefaultValue) {
    const prefix = this._namespacedImportName ? `${this._namespacedImportName}.` : "";
    if (hasDefaultValue) {
      return `${prefix}Maybe<${fieldType}>`;
    }
    return fieldType;
  }
  getPunctuation() {
    return ",";
  }
}
// ../../node_modules/@graphql-codegen/visitor-plugin-common/esm/base-resolvers-visitor.js
var import_auto_bind4 = __toESM(require_auto_bind(), 1);

// ../../node_modules/@graphql-codegen/visitor-plugin-common/esm/enum-values.js
var escapeString = function(str) {
  return str.replace(/\\/g, "\\\\").replace(/\n/g, "\\n").replace(/'/g, "\\'");
};
function parseEnumValues({ schema: schema6, mapOrStr = {}, ignoreEnumValuesFromSchema }) {
  const allTypes = schema6.getTypeMap();
  const allEnums = Object.keys(allTypes).filter((t) => isEnumType(allTypes[t]));
  if (typeof mapOrStr === "object") {
    if (!ignoreEnumValuesFromSchema) {
      for (const enumTypeName of allEnums) {
        const enumType = schema6.getType(enumTypeName);
        for (const { name, value } of enumType.getValues()) {
          if (value !== name) {
            mapOrStr[enumTypeName] ||= {};
            if (typeof mapOrStr[enumTypeName] !== "string" && !mapOrStr[enumTypeName][name]) {
              mapOrStr[enumTypeName][name] = typeof value === "string" ? escapeString(value) : value;
            }
          }
        }
      }
    }
    const invalidMappings = Object.keys(mapOrStr).filter((gqlName) => !allEnums.includes(gqlName));
    if (invalidMappings.length > 0) {
      throw new Error(`Invalid 'enumValues' mapping! \n
        The following types does not exist in your GraphQL schema: ${invalidMappings.join(", ")}`);
    }
    return Object.keys(mapOrStr).reduce((prev, gqlIdentifier) => {
      const pointer = mapOrStr[gqlIdentifier];
      if (typeof pointer === "string") {
        const mapper = parseMapper(pointer, gqlIdentifier);
        return {
          ...prev,
          [gqlIdentifier]: {
            isDefault: mapper.isExternal && mapper.default,
            typeIdentifier: gqlIdentifier,
            sourceFile: mapper.isExternal ? mapper.source : null,
            sourceIdentifier: mapper.type,
            importIdentifier: mapper.isExternal ? mapper.import : null,
            mappedValues: null
          }
        };
      }
      if (typeof pointer === "object") {
        return {
          ...prev,
          [gqlIdentifier]: {
            isDefault: false,
            typeIdentifier: gqlIdentifier,
            sourceFile: null,
            sourceIdentifier: null,
            importIdentifier: null,
            mappedValues: pointer
          }
        };
      }
      throw new Error(`Invalid "enumValues" configuration \n
        Enum "${gqlIdentifier}": expected string or object (with enum values mapping)`);
    }, {});
  }
  if (typeof mapOrStr === "string") {
    return allEnums.filter((enumName) => !enumName.startsWith("__")).reduce((prev, enumName) => {
      return {
        ...prev,
        [enumName]: {
          isDefault: false,
          typeIdentifier: enumName,
          sourceFile: mapOrStr,
          sourceIdentifier: enumName,
          importIdentifier: enumName,
          mappedValues: null
        }
      };
    }, {});
  }
  return {};
}
// ../../node_modules/@graphql-codegen/visitor-plugin-common/esm/declaration-kinds.js
function normalizeDeclarationKind(declarationKind) {
  if (typeof declarationKind === "string") {
    return {
      directive: declarationKind,
      scalar: declarationKind,
      input: declarationKind,
      type: declarationKind,
      interface: declarationKind,
      arguments: declarationKind
    };
  }
  return {
    ...DEFAULT_DECLARATION_KINDS,
    ...declarationKind
  };
}
var DEFAULT_DECLARATION_KINDS = {
  directive: "type",
  scalar: "type",
  input: "type",
  type: "type",
  interface: "type",
  arguments: "type"
};

// ../../node_modules/@graphql-codegen/visitor-plugin-common/esm/base-types-visitor.js
class BaseTypesVisitor extends BaseVisitor {
  constructor(_schema, rawConfig, additionalConfig, defaultScalars = DEFAULT_SCALARS) {
    super(rawConfig, {
      enumPrefix: getConfigValue(rawConfig.enumPrefix, true),
      enumSuffix: getConfigValue(rawConfig.enumSuffix, true),
      onlyEnums: getConfigValue(rawConfig.onlyEnums, false),
      onlyOperationTypes: getConfigValue(rawConfig.onlyOperationTypes, false),
      addUnderscoreToArgsType: getConfigValue(rawConfig.addUnderscoreToArgsType, false),
      enumValues: parseEnumValues({
        schema: _schema,
        mapOrStr: rawConfig.enumValues,
        ignoreEnumValuesFromSchema: rawConfig.ignoreEnumValuesFromSchema
      }),
      declarationKind: normalizeDeclarationKind(rawConfig.declarationKind),
      scalars: buildScalarsFromConfig(_schema, rawConfig, defaultScalars),
      fieldWrapperValue: getConfigValue(rawConfig.fieldWrapperValue, "T"),
      wrapFieldDefinitions: getConfigValue(rawConfig.wrapFieldDefinitions, false),
      entireFieldWrapperValue: getConfigValue(rawConfig.entireFieldWrapperValue, "T"),
      wrapEntireDefinitions: getConfigValue(rawConfig.wrapEntireFieldDefinitions, false),
      ignoreEnumValuesFromSchema: getConfigValue(rawConfig.ignoreEnumValuesFromSchema, false),
      directiveArgumentAndInputFieldMappings: transformDirectiveArgumentAndInputFieldMappings(rawConfig.directiveArgumentAndInputFieldMappings ?? {}, rawConfig.directiveArgumentAndInputFieldMappingTypeSuffix),
      ...additionalConfig
    });
    this._schema = _schema;
    this._argumentsTransformer = new OperationVariablesToObject(this.scalars, this.convertName);
  }
  getExportPrefix() {
    return "export ";
  }
  getFieldWrapperValue() {
    if (this.config.fieldWrapperValue) {
      return `${this.getExportPrefix()}type FieldWrapper<T> = ${this.config.fieldWrapperValue};`;
    }
    return "";
  }
  getEntireFieldWrapperValue() {
    if (this.config.entireFieldWrapperValue) {
      return `${this.getExportPrefix()}type EntireFieldWrapper<T> = ${this.config.entireFieldWrapperValue};`;
    }
    return "";
  }
  getScalarsImports() {
    return Object.keys(this.config.scalars).reduce((res, enumName) => {
      const mappedValue = this.config.scalars[enumName];
      if (mappedValue.input.isExternal) {
        res.push(this._buildTypeImport(mappedValue.input.import, mappedValue.input.source, mappedValue.input.default));
      }
      if (mappedValue.output.isExternal) {
        res.push(this._buildTypeImport(mappedValue.output.import, mappedValue.output.source, mappedValue.output.default));
      }
      return res;
    }, []);
  }
  getDirectiveArgumentAndInputFieldMappingsImports() {
    return Object.keys(this.config.directiveArgumentAndInputFieldMappings).map((directive) => {
      const mappedValue = this.config.directiveArgumentAndInputFieldMappings[directive];
      if (mappedValue.isExternal) {
        return this._buildTypeImport(mappedValue.import, mappedValue.source, mappedValue.default);
      }
      return null;
    }).filter((a) => a);
  }
  get scalarsDefinition() {
    if (this.config.onlyEnums)
      return "";
    const allScalars = Object.keys(this.config.scalars).map((scalarName) => {
      const inputScalarValue = this.config.scalars[scalarName].input.type;
      const outputScalarValue = this.config.scalars[scalarName].output.type;
      const scalarType = this._schema.getType(scalarName);
      const comment = scalarType?.astNode && scalarType.description ? transformComment(scalarType.description, 1) : "";
      const { scalar: scalar2 } = this._parsedConfig.declarationKind;
      return comment + indent3(`${scalarName}: { input: ${inputScalarValue}${this.getPunctuation(scalar2)} output: ${outputScalarValue}${this.getPunctuation(scalar2)} }`);
    });
    return new DeclarationBlock(this._declarationBlockConfig).export().asKind(this._parsedConfig.declarationKind.scalar).withName("Scalars").withComment("All built-in and custom scalars, mapped to their actual values").withBlock(allScalars.join("\n")).string;
  }
  get directiveArgumentAndInputFieldMappingsDefinition() {
    const directiveEntries = Object.entries(this.config.directiveArgumentAndInputFieldMappings);
    if (directiveEntries.length === 0) {
      return "";
    }
    const allDirectives = [];
    for (const [directiveName, parsedMapper] of directiveEntries) {
      const directiveType = this._schema.getDirective(directiveName);
      const comment = directiveType?.astNode && directiveType.description ? transformComment(directiveType.description, 1) : "";
      const { directive } = this._parsedConfig.declarationKind;
      allDirectives.push(comment + indent3(`${directiveName}: ${parsedMapper.type}${this.getPunctuation(directive)}`));
    }
    return new DeclarationBlock(this._declarationBlockConfig).export().asKind(this._parsedConfig.declarationKind.directive).withName("DirectiveArgumentAndInputFieldMappings").withComment("Type overrides using directives").withBlock(allDirectives.join("\n")).string;
  }
  setDeclarationBlockConfig(config) {
    this._declarationBlockConfig = config;
  }
  setArgumentsTransformer(argumentsTransfomer) {
    this._argumentsTransformer = argumentsTransfomer;
  }
  NonNullType(node) {
    const asString = node.type;
    return asString;
  }
  getInputObjectDeclarationBlock(node) {
    return new DeclarationBlock(this._declarationBlockConfig).export().asKind(this._parsedConfig.declarationKind.input).withName(this.convertName(node)).withComment(node.description).withBlock(node.fields.join("\n"));
  }
  getInputObjectOneOfDeclarationBlock(node) {
    const declarationKind = node.fields.length === 1 ? this._parsedConfig.declarationKind.input : "type";
    return new DeclarationBlock(this._declarationBlockConfig).export().asKind(declarationKind).withName(this.convertName(node)).withComment(node.description).withContent(`\n` + node.fields.join("\n  |"));
  }
  InputObjectTypeDefinition(node) {
    if (this.config.onlyEnums)
      return "";
    if (isOneOfInputObjectType(this._schema.getType(node.name))) {
      return this.getInputObjectOneOfDeclarationBlock(node).string;
    }
    return this.getInputObjectDeclarationBlock(node).string;
  }
  InputValueDefinition(node) {
    if (this.config.onlyEnums)
      return "";
    const comment = transformComment(node.description, 1);
    const { input } = this._parsedConfig.declarationKind;
    let type2 = node.type;
    if (node.directives && this.config.directiveArgumentAndInputFieldMappings) {
      type2 = this._getDirectiveOverrideType(node.directives) || type2;
    }
    return comment + indent3(`${node.name}: ${type2}${this.getPunctuation(input)}`);
  }
  Name(node) {
    return node.value;
  }
  FieldDefinition(node) {
    if (this.config.onlyEnums)
      return "";
    const typeString = node.type;
    const { type: type2 } = this._parsedConfig.declarationKind;
    const comment = this.getNodeComment(node);
    return comment + indent3(`${node.name}: ${typeString}${this.getPunctuation(type2)}`);
  }
  UnionTypeDefinition(node, key, parent) {
    if (this.config.onlyOperationTypes || this.config.onlyEnums)
      return "";
    const originalNode = parent[key];
    const possibleTypes = originalNode.types.map((t) => this.scalars[t.name.value] ? this._getScalar(t.name.value, "output") : this.convertName(t)).join(" | ");
    return new DeclarationBlock(this._declarationBlockConfig).export().asKind("type").withName(this.convertName(node)).withComment(node.description).withContent(possibleTypes).string;
  }
  mergeInterfaces(interfaces, hasOtherFields) {
    return interfaces.join(" & ") + (interfaces.length && hasOtherFields ? " & " : "");
  }
  appendInterfacesAndFieldsToBlock(block3, interfaces, fields5) {
    block3.withContent(this.mergeInterfaces(interfaces, fields5.length > 0));
    block3.withBlock(this.mergeAllFields(fields5, interfaces.length > 0));
  }
  getObjectTypeDeclarationBlock(node, originalNode) {
    const optionalTypename = this.config.nonOptionalTypename ? "__typename" : "__typename?";
    const { type: type2, interface: interfacesType } = this._parsedConfig.declarationKind;
    const allFields = [
      ...this.config.addTypename ? [
        indent3(`${this.config.immutableTypes ? "readonly " : ""}${optionalTypename}: '${node.name}'${this.getPunctuation(type2)}`)
      ] : [],
      ...node.fields
    ];
    const interfacesNames = originalNode.interfaces ? originalNode.interfaces.map((i) => this.convertName(i)) : [];
    const declarationBlock = new DeclarationBlock(this._declarationBlockConfig).export().asKind(type2).withName(this.convertName(node)).withComment(node.description);
    if (type2 === "interface" || type2 === "class") {
      if (interfacesNames.length > 0) {
        const keyword = interfacesType === "interface" && type2 === "class" ? "implements" : "extends";
        declarationBlock.withContent(`${keyword} ` + interfacesNames.join(", ") + (allFields.length > 0 ? " " : " {}"));
      }
      declarationBlock.withBlock(this.mergeAllFields(allFields, false));
    } else {
      this.appendInterfacesAndFieldsToBlock(declarationBlock, interfacesNames, allFields);
    }
    return declarationBlock;
  }
  mergeAllFields(allFields, _hasInterfaces) {
    return allFields.join("\n");
  }
  ObjectTypeDefinition(node, key, parent) {
    if (this.config.onlyOperationTypes || this.config.onlyEnums)
      return "";
    const originalNode = parent[key];
    return [this.getObjectTypeDeclarationBlock(node, originalNode).string, this.buildArgumentsBlock(originalNode)].filter((f) => f).join("\n\n");
  }
  getInterfaceTypeDeclarationBlock(node, _originalNode) {
    const declarationBlock = new DeclarationBlock(this._declarationBlockConfig).export().asKind(this._parsedConfig.declarationKind.interface).withName(this.convertName(node)).withComment(node.description);
    return declarationBlock.withBlock(node.fields.join("\n"));
  }
  InterfaceTypeDefinition(node, key, parent) {
    if (this.config.onlyOperationTypes || this.config.onlyEnums)
      return "";
    const originalNode = parent[key];
    return [this.getInterfaceTypeDeclarationBlock(node, originalNode).string, this.buildArgumentsBlock(originalNode)].filter((f) => f).join("\n\n");
  }
  ScalarTypeDefinition(_node) {
    return "";
  }
  _buildTypeImport(identifier, source2, asDefault = false) {
    const { useTypeImports } = this.config;
    if (asDefault) {
      if (useTypeImports) {
        return `import type { default as ${identifier} } from '${source2}';`;
      }
      return `import ${identifier} from '${source2}';`;
    }
    return `import${useTypeImports ? " type" : ""} { ${identifier} } from '${source2}';`;
  }
  handleEnumValueMapper(typeIdentifier, importIdentifier, sourceIdentifier, sourceFile) {
    if (importIdentifier !== sourceIdentifier) {
      return [
        this._buildTypeImport(importIdentifier || sourceIdentifier, sourceFile),
        `import ${typeIdentifier} = ${sourceIdentifier};`
      ];
    }
    if (sourceIdentifier !== typeIdentifier) {
      return [this._buildTypeImport(`${sourceIdentifier} as ${typeIdentifier}`, sourceFile)];
    }
    return [this._buildTypeImport(importIdentifier || sourceIdentifier, sourceFile)];
  }
  getEnumsImports() {
    return Object.keys(this.config.enumValues).flatMap((enumName) => {
      const mappedValue = this.config.enumValues[enumName];
      if (mappedValue.sourceFile) {
        if (mappedValue.isDefault) {
          return [this._buildTypeImport(mappedValue.typeIdentifier, mappedValue.sourceFile, true)];
        }
        return this.handleEnumValueMapper(mappedValue.typeIdentifier, mappedValue.importIdentifier, mappedValue.sourceIdentifier, mappedValue.sourceFile);
      }
      return [];
    }).filter(Boolean);
  }
  EnumTypeDefinition(node) {
    const enumName = node.name;
    if (this.config.enumValues[enumName]?.sourceFile) {
      return null;
    }
    return new DeclarationBlock(this._declarationBlockConfig).export().asKind("enum").withName(this.convertName(node, {
      useTypesPrefix: this.config.enumPrefix,
      useTypesSuffix: this.config.enumSuffix
    })).withComment(node.description).withBlock(this.buildEnumValuesBlock(enumName, node.values)).string;
  }
  StringValue(node) {
    return node.value;
  }
  makeValidEnumIdentifier(identifier) {
    if (/^[0-9]/.exec(identifier)) {
      return wrapWithSingleQuotes(identifier, true);
    }
    return identifier;
  }
  buildEnumValuesBlock(typeName, values4) {
    const schemaEnumType = this._schema ? this._schema.getType(typeName) : undefined;
    return values4.map((enumOption) => {
      const optionName = this.makeValidEnumIdentifier(this.convertName(enumOption, {
        useTypesPrefix: false,
        transformUnderscore: true
      }));
      const comment = this.getNodeComment(enumOption);
      const schemaEnumValue = schemaEnumType && !this.config.ignoreEnumValuesFromSchema ? schemaEnumType.getValue(enumOption.name).value : undefined;
      let enumValue = typeof schemaEnumValue === "undefined" ? enumOption.name : schemaEnumValue;
      if (typeof this.config.enumValues[typeName]?.mappedValues?.[enumValue] !== "undefined") {
        enumValue = this.config.enumValues[typeName].mappedValues[enumValue];
      }
      return comment + indent3(`${optionName}${this._declarationBlockConfig.enumNameValueSeparator} ${wrapWithSingleQuotes(enumValue, typeof schemaEnumValue !== "undefined")}`);
    }).join(",\n");
  }
  DirectiveDefinition(_node) {
    return "";
  }
  getArgumentsObjectDeclarationBlock(node, name, field) {
    return new DeclarationBlock(this._declarationBlockConfig).export().asKind(this._parsedConfig.declarationKind.arguments).withName(this.convertName(name)).withComment(node.description).withBlock(this._argumentsTransformer.transform(field.arguments));
  }
  getArgumentsObjectTypeDefinition(node, name, field) {
    if (this.config.onlyEnums)
      return "";
    return this.getArgumentsObjectDeclarationBlock(node, name, field).string;
  }
  buildArgumentsBlock(node) {
    const fieldsWithArguments = node.fields.filter((field) => field.arguments && field.arguments.length > 0) || [];
    return fieldsWithArguments.map((field) => {
      const name = node.name.value + (this.config.addUnderscoreToArgsType ? "_" : "") + this.convertName(field, {
        useTypesPrefix: false,
        useTypesSuffix: false
      }) + "Args";
      return this.getArgumentsObjectTypeDefinition(node, name, field);
    }).join("\n\n");
  }
  _getScalar(name, type2) {
    return `Scalars['${name}']['${type2}']`;
  }
  _getDirectiveArgumentNadInputFieldMapping(name) {
    return `DirectiveArgumentAndInputFieldMappings['${name}']`;
  }
  _getDirectiveOverrideType(directives24) {
    const type2 = directives24.map((directive) => {
      const directiveName = directive.name;
      if (this.config.directiveArgumentAndInputFieldMappings[directiveName]) {
        return this._getDirectiveArgumentNadInputFieldMapping(directiveName);
      }
      return null;
    }).reverse().find((a) => !!a);
    return type2 || null;
  }
  _getTypeForNode(node, isVisitingInputType) {
    const typeAsString = node.name;
    if (this.scalars[typeAsString]) {
      return this._getScalar(typeAsString, isVisitingInputType ? "input" : "output");
    }
    if (this.config.enumValues[typeAsString]) {
      return this.config.enumValues[typeAsString].typeIdentifier;
    }
    const schemaType = this._schema.getType(node.name);
    if (schemaType && isEnumType(schemaType)) {
      return this.convertName(node, {
        useTypesPrefix: this.config.enumPrefix,
        useTypesSuffix: this.config.enumSuffix
      });
    }
    return this.convertName(node);
  }
  NamedType(node, key, parent, path, ancestors) {
    const currentVisitContext = this.getVisitorKindContextFromAncestors(ancestors);
    const isVisitingInputType = currentVisitContext.includes(Kind.INPUT_OBJECT_TYPE_DEFINITION);
    const typeToUse = this._getTypeForNode(node, isVisitingInputType);
    if (!isVisitingInputType && this.config.fieldWrapperValue && this.config.wrapFieldDefinitions) {
      return `FieldWrapper<${typeToUse}>`;
    }
    return typeToUse;
  }
  ListType(node, _key, _parent, _path, _ancestors) {
    const asString = node.type;
    return this.wrapWithListType(asString);
  }
  SchemaDefinition() {
    return null;
  }
  getNodeComment(node) {
    let commentText = node.description;
    const deprecationDirective = node.directives.find((v) => v.name === "deprecated");
    if (deprecationDirective) {
      const deprecationReason = this.getDeprecationReason(deprecationDirective);
      commentText = `${commentText ? `${commentText}\n` : ""}@deprecated ${deprecationReason}`;
    }
    const comment = transformComment(commentText, 1);
    return comment;
  }
  getDeprecationReason(directive) {
    if (directive.name === "deprecated") {
      const hasArguments = directive.arguments.length > 0;
      let reason = "Field no longer supported";
      if (hasArguments) {
        reason = directive.arguments[0].value;
      }
      return reason;
    }
  }
  wrapWithListType(str) {
    return `Array<${str}>`;
  }
}
// ../../node_modules/@graphql-codegen/visitor-plugin-common/esm/client-side-base-visitor.js
var import_auto_bind5 = __toESM(require_auto_bind(), 1);
var import_change_case_all3 = __toESM(require_dist22(), 1);
var import_dependency_graph = __toESM(require_dep_graph(), 1);

// ../../node_modules/graphql-tag/node_modules/tslib/modules/index.js
var tslib = __toESM(require_tslib13(), 1);
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources
} = tslib.default;

// ../../node_modules/graphql-tag/lib/index.js
var normalize = function(string) {
  return string.replace(/[\s,]+/g, " ").trim();
};
var cacheKeyFromLoc = function(loc) {
  return normalize(loc.source.body.substring(loc.start, loc.end));
};
var processFragments = function(ast8) {
  var seenKeys = new Set;
  var definitions = [];
  ast8.definitions.forEach(function(fragmentDefinition) {
    if (fragmentDefinition.kind === "FragmentDefinition") {
      var fragmentName = fragmentDefinition.name.value;
      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
      var sourceKeySet = fragmentSourceMap.get(fragmentName);
      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
        if (printFragmentWarnings) {
          console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
        }
      } else if (!sourceKeySet) {
        fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);
      }
      sourceKeySet.add(sourceKey);
      if (!seenKeys.has(sourceKey)) {
        seenKeys.add(sourceKey);
        definitions.push(fragmentDefinition);
      }
    } else {
      definitions.push(fragmentDefinition);
    }
  });
  return __assign(__assign({}, ast8), { definitions });
};
var stripLoc = function(doc) {
  var workSet = new Set(doc.definitions);
  workSet.forEach(function(node) {
    if (node.loc)
      delete node.loc;
    Object.keys(node).forEach(function(key) {
      var value = node[key];
      if (value && typeof value === "object") {
        workSet.add(value);
      }
    });
  });
  var loc = doc.loc;
  if (loc) {
    delete loc.startToken;
    delete loc.endToken;
  }
  return doc;
};
var parseDocument = function(source2) {
  var cacheKey = normalize(source2);
  if (!docCache.has(cacheKey)) {
    var parsed = parse(source2, {
      experimentalFragmentVariables,
      allowLegacyFragmentVariables: experimentalFragmentVariables
    });
    if (!parsed || parsed.kind !== "Document") {
      throw new Error("Not a valid GraphQL document.");
    }
    docCache.set(cacheKey, stripLoc(processFragments(parsed)));
  }
  return docCache.get(cacheKey);
};
function gql(literals) {
  var args = [];
  for (var _i = 1;_i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (typeof literals === "string") {
    literals = [literals];
  }
  var result = literals[0];
  args.forEach(function(arg, i) {
    if (arg && arg.kind === "Document") {
      result += arg.loc.source.body;
    } else {
      result += arg;
    }
    result += literals[i + 1];
  });
  return parseDocument(result);
}
function resetCaches() {
  docCache.clear();
  fragmentSourceMap.clear();
}
function disableFragmentWarnings() {
  printFragmentWarnings = false;
}
function enableExperimentalFragmentVariables() {
  experimentalFragmentVariables = true;
}
function disableExperimentalFragmentVariables() {
  experimentalFragmentVariables = false;
}
var docCache = new Map;
var fragmentSourceMap = new Map;
var printFragmentWarnings = true;
var experimentalFragmentVariables = false;
var extras = {
  gql,
  resetCaches,
  disableFragmentWarnings,
  enableExperimentalFragmentVariables,
  disableExperimentalFragmentVariables
};
(function(gql_1) {
  gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
})(gql || (gql = {}));
gql["default"] = gql;
var lib_default = gql;

// ../../node_modules/@graphql-codegen/visitor-plugin-common/esm/imports.js
var import_parse_filepath = __toESM(require_parse_filepath(), 1);

// ../../node_modules/@graphql-codegen/visitor-plugin-common/esm/client-side-base-visitor.js
lib_default.enableExperimentalFragmentVariables();
var DocumentMode;
(function(DocumentMode2) {
  DocumentMode2["graphQLTag"] = "graphQLTag";
  DocumentMode2["documentNode"] = "documentNode";
  DocumentMode2["documentNodeImportFragments"] = "documentNodeImportFragments";
  DocumentMode2["external"] = "external";
  DocumentMode2["string"] = "string";
})(DocumentMode || (DocumentMode = {}));
// ../../node_modules/@graphql-codegen/visitor-plugin-common/esm/selection-set-to-object.js
var import_auto_bind6 = __toESM(require_auto_bind(), 1);
// ../../node_modules/@graphql-codegen/typescript/esm/visitor.js
var import_auto_bind7 = __toESM(require_auto_bind(), 1);

// ../../node_modules/@graphql-codegen/typescript/esm/typescript-variables-to-object.js
class TypeScriptOperationVariablesToObject extends OperationVariablesToObject {
  constructor(_scalars, _convertName, _avoidOptionals, _immutableTypes, _namespacedImportName = null, _enumNames = [], _enumPrefix = true, _enumSuffix = true, _enumValues = {}, _applyCoercion = false, _directiveArgumentAndInputFieldMappings = {}, _maybeType = "Maybe") {
    super(_scalars, _convertName, _namespacedImportName, _enumNames, _enumPrefix, _enumSuffix, _enumValues, _applyCoercion, _directiveArgumentAndInputFieldMappings);
    this._avoidOptionals = _avoidOptionals;
    this._immutableTypes = _immutableTypes;
    this._maybeType = _maybeType;
  }
  clearOptional(str) {
    const prefix = this._namespacedImportName ? `${this._namespacedImportName}.` : "";
    const rgx = new RegExp(`^${this.wrapMaybe(`(.*?)`)}\$`, "i");
    if (str.startsWith(`${prefix}${this._maybeType}`)) {
      return str.replace(rgx, "$1");
    }
    return str;
  }
  wrapAstTypeWithModifiers(baseType, typeNode, applyCoercion = false) {
    if (typeNode.kind === Kind.NON_NULL_TYPE) {
      const type2 = this.wrapAstTypeWithModifiers(baseType, typeNode.type, applyCoercion);
      return this.clearOptional(type2);
    }
    if (typeNode.kind === Kind.LIST_TYPE) {
      const innerType = this.wrapAstTypeWithModifiers(baseType, typeNode.type, applyCoercion);
      const listInputCoercionExtension = applyCoercion ? ` | ${innerType}` : "";
      return this.wrapMaybe(`${this._immutableTypes ? "ReadonlyArray" : "Array"}<${innerType}>${listInputCoercionExtension}`);
    }
    return this.wrapMaybe(baseType);
  }
  formatFieldString(fieldName, isNonNullType2, hasDefaultValue) {
    return `${fieldName}${this.getAvoidOption(isNonNullType2, hasDefaultValue) ? "?" : ""}`;
  }
  formatTypeString(fieldType, isNonNullType2, hasDefaultValue) {
    if (!hasDefaultValue && isNonNullType2) {
      return this.clearOptional(fieldType);
    }
    return fieldType;
  }
  wrapMaybe(type2) {
    const prefix = this._namespacedImportName ? `${this._namespacedImportName}.` : "";
    return `${prefix}${this._maybeType}${type2 ? `<${type2}>` : ""}`;
  }
  getAvoidOption(isNonNullType2, hasDefaultValue) {
    const options = normalizeAvoidOptionals(this._avoidOptionals);
    return (options.object || !options.defaultValue) && hasDefaultValue || !options.object && !isNonNullType2;
  }
  getPunctuation() {
    return ";";
  }
}

// ../../node_modules/@graphql-codegen/typescript/esm/visitor.js
var EXACT_SIGNATURE = `type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };`;
var MAKE_OPTIONAL_SIGNATURE = `type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };`;
var MAKE_MAYBE_SIGNATURE = `type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };`;
var MAKE_EMPTY_SIGNATURE = `type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };`;
var MAKE_INCREMENTAL_SIGNATURE = `type Incremental<T> = T | { [P in keyof T]?: P extends ' \$fragmentName' | '__typename' ? T[P] : never };`;

class TsVisitor extends BaseTypesVisitor {
  constructor(schema6, pluginConfig, additionalConfig = {}) {
    super(schema6, pluginConfig, {
      noExport: getConfigValue(pluginConfig.noExport, false),
      avoidOptionals: normalizeAvoidOptionals(getConfigValue(pluginConfig.avoidOptionals, false)),
      maybeValue: getConfigValue(pluginConfig.maybeValue, "T | null"),
      inputMaybeValue: getConfigValue(pluginConfig.inputMaybeValue, getConfigValue(pluginConfig.maybeValue, "Maybe<T>")),
      constEnums: getConfigValue(pluginConfig.constEnums, false),
      enumsAsTypes: getConfigValue(pluginConfig.enumsAsTypes, false),
      futureProofEnums: getConfigValue(pluginConfig.futureProofEnums, false),
      futureProofUnions: getConfigValue(pluginConfig.futureProofUnions, false),
      enumsAsConst: getConfigValue(pluginConfig.enumsAsConst, false),
      numericEnums: getConfigValue(pluginConfig.numericEnums, false),
      onlyEnums: getConfigValue(pluginConfig.onlyEnums, false),
      onlyOperationTypes: getConfigValue(pluginConfig.onlyOperationTypes, false),
      immutableTypes: getConfigValue(pluginConfig.immutableTypes, false),
      useImplementingTypes: getConfigValue(pluginConfig.useImplementingTypes, false),
      entireFieldWrapperValue: getConfigValue(pluginConfig.entireFieldWrapperValue, "T"),
      wrapEntireDefinitions: getConfigValue(pluginConfig.wrapEntireFieldDefinitions, false),
      ...additionalConfig
    });
    import_auto_bind7.default(this);
    const enumNames = Object.values(schema6.getTypeMap()).filter(isEnumType).map((type2) => type2.name);
    this.setArgumentsTransformer(new TypeScriptOperationVariablesToObject(this.scalars, this.convertName, this.config.avoidOptionals, this.config.immutableTypes, null, enumNames, pluginConfig.enumPrefix, pluginConfig.enumSuffix, this.config.enumValues, false, this.config.directiveArgumentAndInputFieldMappings, "InputMaybe"));
    this.setDeclarationBlockConfig({
      enumNameValueSeparator: " =",
      ignoreExport: this.config.noExport
    });
  }
  _getTypeForNode(node, isVisitingInputType) {
    const typeAsString = node.name;
    if (this.config.useImplementingTypes) {
      const allTypesMap = this._schema.getTypeMap();
      const implementingTypes = [];
      for (const graphqlType of Object.values(allTypesMap)) {
        if (graphqlType instanceof GraphQLObjectType) {
          const allInterfaces = graphqlType.getInterfaces();
          if (allInterfaces.some((int) => typeAsString === int.name)) {
            implementingTypes.push(this.convertName(graphqlType.name));
          }
        }
      }
      if (implementingTypes.length > 0) {
        return implementingTypes.join(" | ");
      }
    }
    const typeString = super._getTypeForNode(node, isVisitingInputType);
    const schemaType = this._schema.getType(node.name);
    if (isEnumType(schemaType)) {
      const futureProofEnumUsageEnabled = this.config.futureProofEnums === true && this.config.enumsAsTypes !== true;
      if (futureProofEnumUsageEnabled && this.config.allowEnumStringTypes === true) {
        return `${typeString} | '%future added value' | ` + "`${" + typeString + "}`";
      }
      if (futureProofEnumUsageEnabled) {
        return `${typeString} | '%future added value'`;
      }
      if (this.config.allowEnumStringTypes === true) {
        return `${typeString} | ` + "`${" + typeString + "}`";
      }
    }
    return typeString;
  }
  getWrapperDefinitions() {
    if (this.config.onlyEnums)
      return [];
    const definitions = [
      this.getMaybeValue(),
      this.getInputMaybeValue(),
      this.getExactDefinition(),
      this.getMakeOptionalDefinition(),
      this.getMakeMaybeDefinition(),
      this.getMakeEmptyDefinition(),
      this.getIncrementalDefinition()
    ];
    if (this.config.wrapFieldDefinitions) {
      definitions.push(this.getFieldWrapperValue());
    }
    if (this.config.wrapEntireDefinitions) {
      definitions.push(this.getEntireFieldWrapperValue());
    }
    return definitions;
  }
  getExactDefinition() {
    if (this.config.onlyEnums)
      return "";
    return `${this.getExportPrefix()}${EXACT_SIGNATURE}`;
  }
  getMakeOptionalDefinition() {
    return `${this.getExportPrefix()}${MAKE_OPTIONAL_SIGNATURE}`;
  }
  getMakeMaybeDefinition() {
    if (this.config.onlyEnums)
      return "";
    return `${this.getExportPrefix()}${MAKE_MAYBE_SIGNATURE}`;
  }
  getMakeEmptyDefinition() {
    return `${this.getExportPrefix()}${MAKE_EMPTY_SIGNATURE}`;
  }
  getIncrementalDefinition() {
    return `${this.getExportPrefix()}${MAKE_INCREMENTAL_SIGNATURE}`;
  }
  getMaybeValue() {
    return `${this.getExportPrefix()}type Maybe<T> = ${this.config.maybeValue};`;
  }
  getInputMaybeValue() {
    return `${this.getExportPrefix()}type InputMaybe<T> = ${this.config.inputMaybeValue};`;
  }
  clearOptional(str) {
    if (str.startsWith("Maybe")) {
      return str.replace(/Maybe<(.*?)>$/, "$1");
    }
    if (str.startsWith("InputMaybe")) {
      return str.replace(/InputMaybe<(.*?)>$/, "$1");
    }
    return str;
  }
  getExportPrefix() {
    if (this.config.noExport) {
      return "";
    }
    return super.getExportPrefix();
  }
  getMaybeWrapper(ancestors) {
    const currentVisitContext = this.getVisitorKindContextFromAncestors(ancestors);
    const isInputContext = currentVisitContext.includes(Kind.INPUT_OBJECT_TYPE_DEFINITION);
    return isInputContext ? "InputMaybe" : "Maybe";
  }
  NamedType(node, key, parent, path, ancestors) {
    return `${this.getMaybeWrapper(ancestors)}<${super.NamedType(node, key, parent, path, ancestors)}>`;
  }
  ListType(node, key, parent, path, ancestors) {
    return `${this.getMaybeWrapper(ancestors)}<${super.ListType(node, key, parent, path, ancestors)}>`;
  }
  UnionTypeDefinition(node, key, parent) {
    if (this.config.onlyOperationTypes || this.config.onlyEnums)
      return "";
    let withFutureAddedValue = [];
    if (this.config.futureProofUnions) {
      withFutureAddedValue = [
        this.config.immutableTypes ? `{ readonly __typename?: "%other" }` : `{ __typename?: "%other" }`
      ];
    }
    const originalNode = parent[key];
    const possibleTypes = originalNode.types.map((t) => this.scalars[t.name.value] ? this._getScalar(t.name.value, "output") : this.convertName(t)).concat(...withFutureAddedValue).join(" | ");
    return new DeclarationBlock(this._declarationBlockConfig).export().asKind("type").withName(this.convertName(node)).withComment(node.description).withContent(possibleTypes).string;
  }
  wrapWithListType(str) {
    return `${this.config.immutableTypes ? "ReadonlyArray" : "Array"}<${str}>`;
  }
  NonNullType(node) {
    const baseValue = super.NonNullType(node);
    return this.clearOptional(baseValue);
  }
  FieldDefinition(node, key, parent) {
    const typeString = this.config.wrapEntireDefinitions ? `EntireFieldWrapper<${node.type}>` : node.type;
    const originalFieldNode = parent[key];
    const addOptionalSign = !this.config.avoidOptionals.field && originalFieldNode.type.kind !== Kind.NON_NULL_TYPE;
    const comment = this.getNodeComment(node);
    const { type: type2 } = this.config.declarationKind;
    return comment + indent3(`${this.config.immutableTypes ? "readonly " : ""}${node.name}${addOptionalSign ? "?" : ""}: ${typeString}${this.getPunctuation(type2)}`);
  }
  InputValueDefinition(node, key, parent, _path, ancestors) {
    const originalFieldNode = parent[key];
    const addOptionalSign = !this.config.avoidOptionals.inputValue && (originalFieldNode.type.kind !== Kind.NON_NULL_TYPE || !this.config.avoidOptionals.defaultValue && node.defaultValue !== undefined);
    const comment = this.getNodeComment(node);
    const declarationKind = this.config.declarationKind.type;
    let type2 = node.type;
    if (node.directives && this.config.directiveArgumentAndInputFieldMappings) {
      type2 = this._getDirectiveOverrideType(node.directives) || type2;
    }
    const readonlyPrefix = this.config.immutableTypes ? "readonly " : "";
    const buildFieldDefinition = (isOneOf2 = false) => {
      return `${readonlyPrefix}${node.name}${addOptionalSign && !isOneOf2 ? "?" : ""}: ${isOneOf2 ? this.clearOptional(type2) : type2}${this.getPunctuation(declarationKind)}`;
    };
    const realParentDef = ancestors?.[ancestors.length - 1];
    if (realParentDef) {
      const parentType = this._schema.getType(realParentDef.name.value);
      if (isOneOfInputObjectType(parentType)) {
        if (originalFieldNode.type.kind === Kind.NON_NULL_TYPE) {
          throw new Error("Fields on an input object type can not be non-nullable. It seems like the schema was not validated.");
        }
        const fieldParts = [];
        for (const fieldName of Object.keys(parentType.getFields())) {
          if (fieldName === node.name) {
            fieldParts.push(buildFieldDefinition(true));
            continue;
          }
          fieldParts.push(`${readonlyPrefix}${fieldName}?: never;`);
        }
        return comment + indent3(`{ ${fieldParts.join(" ")} }`);
      }
    }
    return comment + indent3(buildFieldDefinition());
  }
  EnumTypeDefinition(node) {
    const enumName = node.name;
    if (this.config.enumValues[enumName]?.sourceFile) {
      return `export { ${this.config.enumValues[enumName].typeIdentifier} };\n`;
    }
    const getValueFromConfig = (enumValue) => {
      if (typeof this.config.enumValues[enumName]?.mappedValues?.[enumValue] !== "undefined") {
        return this.config.enumValues[enumName].mappedValues[enumValue];
      }
      return null;
    };
    const withFutureAddedValue = [
      this.config.futureProofEnums ? [indent3("| " + wrapWithSingleQuotes("%future added value"))] : []
    ];
    const enumTypeName = this.convertName(node, {
      useTypesPrefix: this.config.enumPrefix,
      useTypesSuffix: this.config.enumSuffix
    });
    if (this.config.enumsAsTypes) {
      return new DeclarationBlock(this._declarationBlockConfig).export().asKind("type").withComment(node.description).withName(enumTypeName).withContent("\n" + node.values.map((enumOption) => {
        const name = enumOption.name;
        const enumValue = getValueFromConfig(name) ?? name;
        const comment = transformComment(enumOption.description, 1);
        return comment + indent3("| " + wrapWithSingleQuotes(enumValue));
      }).concat(...withFutureAddedValue).join("\n")).string;
    }
    if (this.config.numericEnums) {
      const block3 = new DeclarationBlock(this._declarationBlockConfig).export().withComment(node.description).withName(enumTypeName).asKind("enum").withBlock(node.values.map((enumOption, i) => {
        const valueFromConfig = getValueFromConfig(enumOption.name);
        const enumValue = valueFromConfig ?? i;
        const comment = transformComment(enumOption.description, 1);
        const optionName = this.makeValidEnumIdentifier(this.convertName(enumOption, {
          useTypesPrefix: false,
          transformUnderscore: true
        }));
        return comment + indent3(optionName) + ` = ${enumValue}`;
      }).concat(...withFutureAddedValue).join(",\n")).string;
      return block3;
    }
    if (this.config.enumsAsConst) {
      const typeName = `export type ${enumTypeName} = typeof ${enumTypeName}[keyof typeof ${enumTypeName}];`;
      const enumAsConst = new DeclarationBlock({
        ...this._declarationBlockConfig,
        blockTransformer: (block3) => {
          return block3 + " as const";
        }
      }).export().asKind("const").withName(enumTypeName).withComment(node.description).withBlock(node.values.map((enumOption) => {
        const optionName = this.makeValidEnumIdentifier(this.convertName(enumOption, {
          useTypesPrefix: false,
          transformUnderscore: true
        }));
        const comment = transformComment(enumOption.description, 1);
        const name = enumOption.name;
        const enumValue = getValueFromConfig(name) ?? name;
        return comment + indent3(`${optionName}: ${wrapWithSingleQuotes(enumValue)}`);
      }).join(",\n")).string;
      return [enumAsConst, typeName].join("\n");
    }
    return new DeclarationBlock(this._declarationBlockConfig).export().asKind(this.config.constEnums ? "const enum" : "enum").withName(enumTypeName).withComment(node.description).withBlock(this.buildEnumValuesBlock(enumName, node.values)).string;
  }
  getPunctuation(_declarationKind) {
    return ";";
  }
}

// ../../node_modules/@graphql-codegen/typescript/esm/introspection-visitor.js
class TsIntrospectionVisitor extends TsVisitor {
  constructor(schema6, pluginConfig = {}, typesToInclude) {
    super(schema6, pluginConfig);
    this.typesToInclude = [];
    this.typesToInclude = typesToInclude;
    import_auto_bind8.default(this);
  }
  DirectiveDefinition() {
    return null;
  }
  ObjectTypeDefinition(node, key, parent) {
    const name = node.name;
    if (this.typesToInclude.some((type2) => type2.name === name)) {
      return super.ObjectTypeDefinition(node, key, parent);
    }
    return null;
  }
  EnumTypeDefinition(node) {
    const name = node.name;
    if (this.typesToInclude.some((type2) => type2.name === name)) {
      return super.EnumTypeDefinition(node);
    }
    return null;
  }
}
// ../../node_modules/@graphql-codegen/typescript/esm/index.js
function includeIntrospectionTypesDefinitions(schema6, documents, config2) {
  const typeInfo = new TypeInfo(schema6);
  const usedTypes = [];
  const documentsVisitor = visitWithTypeInfo(typeInfo, {
    Field() {
      const type2 = getNamedType(typeInfo.getType());
      if (type2 && isIntrospectionType(type2) && !usedTypes.includes(type2)) {
        usedTypes.push(type2);
      }
    }
  });
  for (const doc of documents) {
    visit(doc.document, documentsVisitor);
  }
  const typesToInclude = [];
  for (const type2 of usedTypes) {
    collectTypes(type2);
  }
  const visitor8 = new TsIntrospectionVisitor(schema6, config2, typesToInclude);
  const result = oldVisit(parse(printIntrospectionSchema(schema6)), { leave: visitor8 });
  function collectTypes(type2) {
    if (typesToInclude.includes(type2)) {
      return;
    }
    typesToInclude.push(type2);
    if (isObjectType(type2)) {
      const fields5 = type2.getFields();
      for (const key of Object.keys(fields5)) {
        const field = fields5[key];
        const type3 = getNamedType(field.type);
        collectTypes(type3);
      }
    }
  }
  return result.definitions;
}
var plugin = (schema6, documents, config2) => {
  const { schema: _schema, ast: ast8 } = transformSchemaAST(schema6, config2);
  const visitor8 = new TsVisitor(_schema, config2);
  const visitorResult = oldVisit(ast8, { leave: visitor8 });
  const introspectionDefinitions = includeIntrospectionTypesDefinitions(_schema, documents, config2);
  const scalars12 = visitor8.scalarsDefinition;
  const directiveArgumentAndInputFieldMappings = visitor8.directiveArgumentAndInputFieldMappingsDefinition;
  return {
    prepend: [
      ...visitor8.getEnumsImports(),
      ...visitor8.getDirectiveArgumentAndInputFieldMappingsImports(),
      ...visitor8.getScalarsImports(),
      ...visitor8.getWrapperDefinitions()
    ].filter(Boolean),
    content: [
      scalars12,
      directiveArgumentAndInputFieldMappings,
      ...visitorResult.definitions,
      ...introspectionDefinitions
    ].filter(Boolean).join("\n")
  };
};

// ../../node_modules/@pothos/core/esm/builder.js
var _defineProperty22 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/core/esm/build-cache.js
var _defineProperty9 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/core/esm/errors.js
class PothosError extends Error {
  constructor(message) {
    super(message);
    this.name = "PothosError";
  }
}

class PothosSchemaError extends PothosError {
  constructor(message) {
    super(message);
    this.name = "PothosSchemaError";
  }
}

class PothosValidationError extends PothosError {
  constructor(message) {
    super(message);
    this.name = "PothosValidationError";
  }
}

// ../../node_modules/@pothos/core/esm/plugins/merge-plugins.js
var _defineProperty2 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/core/esm/plugins/plugin.js
var _defineProperty = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/core/esm/utils/context-cache.js
function createContextCache(create) {
  const cache = new WeakMap;
  return (context, ...args) => {
    const cacheKey = context[contextCacheSymbol] || context;
    if (cache.has(cacheKey)) {
      return cache.get(cacheKey);
    }
    const entry = create(context, ...args);
    cache.set(cacheKey, entry);
    return entry;
  };
}
var contextCacheSymbol = Symbol.for("Pothos.contextCache");

// ../../node_modules/@pothos/core/esm/plugins/plugin.js
var runCache = new WeakMap;

class BasePlugin {
  onTypeConfig(typeConfig) {
    return typeConfig;
  }
  onOutputFieldConfig(fieldConfig) {
    return fieldConfig;
  }
  onInputFieldConfig(fieldConfig) {
    return fieldConfig;
  }
  onEnumValueConfig(valueConfig) {
    return valueConfig;
  }
  beforeBuild() {
  }
  afterBuild(schema6) {
    return schema6;
  }
  wrapResolve(resolver, fieldConfig) {
    return resolver;
  }
  wrapSubscribe(subscribe3, fieldConfig) {
    return subscribe3;
  }
  wrapResolveType(resolveType, typeConfig) {
    return resolveType;
  }
  wrapIsTypeOf(isTypeOf, typeConfig) {
    return isTypeOf;
  }
  runUnique(key, cb) {
    if (!runCache.has(this.builder)) {
      runCache.set(this.builder, new Map);
    }
    if (!runCache.get(this.builder).has(key)) {
      const result = cb();
      runCache.get(this.builder).set(key, result);
      return result;
    }
    return runCache.get(this.builder).get(key);
  }
  createRequestData(context) {
    throw new PothosError("createRequestData not implemented");
  }
  requestData(context) {
    return this.requestDataMap(context);
  }
  constructor(buildCache, name) {
    _defineProperty(this, "name", undefined);
    _defineProperty(this, "builder", undefined);
    _defineProperty(this, "buildCache", undefined);
    _defineProperty(this, "options", undefined);
    _defineProperty(this, "requestDataMap", createContextCache((ctx) => this.createRequestData(ctx)));
    this.name = name;
    this.builder = buildCache.builder;
    this.buildCache = buildCache;
    this.options = buildCache.options;
  }
}

// ../../node_modules/@pothos/core/esm/plugins/merge-plugins.js
class MergedPlugins extends BasePlugin {
  onTypeConfig(typeConfig) {
    return this.plugins.reduceRight((config2, plugin3) => config2 === null ? config2 : plugin3.onTypeConfig(config2), typeConfig);
  }
  onInputFieldConfig(fieldConfig) {
    return this.plugins.reduceRight((config2, plugin3) => config2 === null ? config2 : plugin3.onInputFieldConfig(config2), fieldConfig);
  }
  onOutputFieldConfig(fieldConfig) {
    return this.plugins.reduceRight((config2, plugin3) => config2 === null ? config2 : plugin3.onOutputFieldConfig(config2), fieldConfig);
  }
  onEnumValueConfig(valueConfig) {
    return this.plugins.reduceRight((config2, plugin3) => config2 === null ? config2 : plugin3.onEnumValueConfig(config2), valueConfig);
  }
  beforeBuild() {
    for (const plugin3 of this.plugins) {
      plugin3.beforeBuild();
    }
  }
  afterBuild(schema6) {
    return this.plugins.reduceRight((nextSchema, plugin3) => plugin3.afterBuild(nextSchema), schema6);
  }
  wrapResolve(resolve, fieldConfig) {
    return this.plugins.reduceRight((nextResolve, plugin3) => plugin3.wrapResolve(nextResolve, fieldConfig), resolve);
  }
  wrapSubscribe(subscribe3, fieldConfig) {
    return this.plugins.reduceRight((nextSubscribe, plugin3) => plugin3.wrapSubscribe(nextSubscribe, fieldConfig), subscribe3);
  }
  wrapResolveType(resolveType, typeConfig) {
    return this.plugins.reduceRight((nextResolveType, plugin3) => plugin3.wrapResolveType(nextResolveType, typeConfig), resolveType);
  }
  wrapIsTypeOf(isTypeOf, typeConfig) {
    return this.plugins.reduceRight((nextResolveType, plugin3) => plugin3.wrapIsTypeOf(nextResolveType, typeConfig), isTypeOf);
  }
  constructor(buildCache, plugins) {
    super(buildCache, "PothosMergedPlugin");
    _defineProperty2(this, "plugins", undefined);
    this.plugins = plugins;
  }
}
// ../../node_modules/@pothos/core/esm/refs/builtin-scalar.js
var _defineProperty5 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/core/esm/refs/scalar.js
var _defineProperty4 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
// ../../node_modules/@pothos/core/esm/types/type-params.js
var outputShapeKey = Symbol.for("Pothos.outputShapeKey");
var parentShapeKey = Symbol.for("Pothos.parentShapeKey");
var abstractReturnShapeKey = Symbol.for("Pothos.abstractReturnShapeKey");
var inputShapeKey = Symbol.for("Pothos.inputShapeKey");
var inputFieldShapeKey = Symbol.for("Pothos.inputFieldShapeKey");
var outputFieldShapeKey = Symbol.for("Pothos.outputFieldShapeKey");
var typeBrandKey = Symbol.for("Pothos.typeBrandKey");
// ../../node_modules/@pothos/core/esm/refs/base.js
var _defineProperty3 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

class BaseTypeRef {
  toString() {
    return `${this.kind}Ref<${this.name}>`;
  }
  constructor(kind, name) {
    _defineProperty3(this, "kind", undefined);
    _defineProperty3(this, "name", undefined);
    this.kind = kind;
    this.name = name;
  }
}

// ../../node_modules/@pothos/core/esm/refs/scalar.js
var _outputShapeKey = outputShapeKey;
var _parentShapeKey = parentShapeKey;
var _inputShapeKey = inputShapeKey;

class ScalarRef extends BaseTypeRef {
  constructor(name) {
    super("Scalar", name);
    _defineProperty4(this, "kind", "Scalar");
    _defineProperty4(this, _outputShapeKey, undefined);
    _defineProperty4(this, _parentShapeKey, undefined);
    _defineProperty4(this, _inputShapeKey, undefined);
  }
}

// ../../node_modules/@pothos/core/esm/refs/builtin-scalar.js
class BuiltinScalarRef extends ScalarRef {
  constructor(type2) {
    super(type2.name);
    _defineProperty5(this, "type", undefined);
    this.type = type2;
  }
}

// ../../node_modules/@pothos/core/esm/refs/input-object.js
var _defineProperty6 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _inputShapeKey2 = inputShapeKey;

class InputObjectRef extends BaseTypeRef {
  constructor(name) {
    super("InputObject", name);
    _defineProperty6(this, "kind", "InputObject");
    _defineProperty6(this, _inputShapeKey2, undefined);
  }
}
class ImplementableInputObjectRef extends InputObjectRef {
  implement(options) {
    this.builder.inputType(this, options);
    return this;
  }
  constructor(builder, name) {
    super(name);
    _defineProperty6(this, "builder", undefined);
    this.builder = builder;
  }
}

// ../../node_modules/@pothos/core/esm/refs/input-list.js
var _defineProperty7 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _inputShapeKey3 = inputShapeKey;

class InputObjectRef2 extends BaseTypeRef {
  constructor(listType, required) {
    super("InputList", `InputList<${String(listType)}>`);
    _defineProperty7(this, "kind", "InputList");
    _defineProperty7(this, _inputShapeKey3, undefined);
    _defineProperty7(this, "listType", undefined);
    _defineProperty7(this, "required", undefined);
    this.listType = listType;
    this.required = required;
  }
}

// ../../node_modules/@pothos/core/esm/refs/list.js
var _defineProperty8 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _outputShapeKey2 = outputShapeKey;
var _parentShapeKey2 = parentShapeKey;

class ListRef extends BaseTypeRef {
  constructor(listType, nullable) {
    super("List", `List<${String(listType)}>`);
    _defineProperty8(this, "kind", "List");
    _defineProperty8(this, _outputShapeKey2, undefined);
    _defineProperty8(this, _parentShapeKey2, undefined);
    _defineProperty8(this, "listType", undefined);
    _defineProperty8(this, "nullable", undefined);
    this.listType = listType;
    this.nullable = nullable;
  }
}

// ../../node_modules/@pothos/core/esm/utils/base64.js
function encodeBase64(value) {
  const globalThis1 = getGlobalThis();
  if (typeof globalThis1.btoa === "function") {
    return globalThis1.btoa(value);
  }
  if (typeof globalThis1.Buffer === "function") {
    return globalThis1.Buffer.from(value).toString("base64");
  }
  throw new Error("Unable to locate global `btoa` or `Buffer`");
}
function decodeBase64(value) {
  const globalThis1 = getGlobalThis();
  if (typeof globalThis1.atob === "function") {
    return globalThis1.atob(value);
  }
  if (typeof globalThis1.Buffer === "function") {
    return globalThis1.Buffer.from(value, "base64").toString();
  }
  throw new Error("Unable to locate global `atob` or `Buffer`");
}
var getGlobalThis = () => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
  if (true)
    return null;
  throw new Error("Unable to locate global `this`");
};
// ../../node_modules/@pothos/core/esm/utils/enums.js
function normalizeEnumValues(values4) {
  const result = {};
  if (Array.isArray(values4)) {
    values4.forEach((key) => {
      result[String(key)] = {
        pothosOptions: {}
      };
    });
  } else {
    Object.entries(values4).forEach(([key, value]) => {
      if (value && typeof value === "object") {
        result[key] = {
          ...value,
          pothosOptions: value
        };
      } else if (typeof value === "string") {
        result[value] = {
          pothosOptions: {}
        };
      }
    });
  }
  return result;
}
function valuesFromEnum(Enum, values4) {
  const result = {};
  Object.keys(Enum).filter((key) => typeof Enum[Enum[key]] !== "number").forEach((key) => {
    result[key] = {
      value: Enum[key],
      pothosOptions: {},
      ...values4 === null || values4 === undefined ? undefined : values4[key]
    };
  });
  return result;
}
// ../../node_modules/@pothos/core/esm/utils/params.js
function typeFromParam(param, configStore, nullableOption) {
  const itemNullable = typeof nullableOption === "object" ? nullableOption.items : false;
  const nullable = typeof nullableOption === "object" ? nullableOption.list : !!nullableOption;
  if (Array.isArray(param)) {
    return {
      kind: "List",
      type: typeFromParam(param[0], configStore, itemNullable),
      nullable
    };
  }
  if (param instanceof ListRef) {
    return {
      kind: "List",
      type: typeFromParam(param.listType, configStore, param.nullable),
      nullable
    };
  }
  const ref = configStore.getOutputTypeRef(param);
  const kind = ref instanceof BaseTypeRef ? ref.kind : configStore.getTypeConfig(ref).graphqlKind;
  const name = ref instanceof BaseTypeRef ? ref.name : configStore.getTypeConfig(ref).name;
  if (kind !== "InputObject" && kind !== "List" && kind !== "InputList") {
    return {
      kind,
      ref,
      nullable
    };
  }
  throw new PothosSchemaError(`Expected input param ${name} to be an output type but got ${kind}`);
}
function unwrapInputFieldType(type2) {
  if (type2.kind === "List") {
    return unwrapInputFieldType(type2.type);
  }
  return type2.ref;
}
function inputTypeFromParam(param, configStore, requiredOption) {
  const itemRequired = typeof requiredOption === "object" ? requiredOption.items : true;
  const required = typeof requiredOption === "object" ? requiredOption.list : !!requiredOption;
  if (Array.isArray(param)) {
    return {
      kind: "List",
      type: inputTypeFromParam(param[0], configStore, itemRequired),
      required
    };
  }
  if (param instanceof InputObjectRef2) {
    return {
      kind: "List",
      type: inputTypeFromParam(param.listType, configStore, param.required),
      required
    };
  }
  const ref = configStore.getInputTypeRef(param);
  const kind = ref instanceof BaseTypeRef ? ref.kind : configStore.getTypeConfig(ref).graphqlKind;
  const name = ref instanceof BaseTypeRef ? ref.name : configStore.getTypeConfig(ref).name;
  if (kind === "InputObject" || kind === "Enum" || kind === "Scalar") {
    return {
      kind,
      ref,
      required
    };
  }
  throw new PothosSchemaError(`Expected input param ${name} to be an InputObject, Enum, or Scalar but got ${kind}`);
}

// ../../node_modules/@pothos/core/esm/utils/input.js
function resolveInputTypeConfig(type2, buildCache) {
  if (type2.kind === "List") {
    return resolveInputTypeConfig(type2.type, buildCache);
  }
  const config2 = buildCache.getTypeConfig(type2.ref);
  if (config2.kind === "Enum" || config2.kind === "Scalar" || config2.kind === "InputObject") {
    return config2;
  }
  throw new PothosSchemaError(`Unexpected config type ${config2.kind} for input ref ${String(type2.ref)}`);
}
function mapInputFields(inputs, buildCache, mapper) {
  const filterMappings = new Map;
  return filterMapped(internalMapInputFields(inputs, buildCache, mapper, new Map));
  function filterMapped(map) {
    if (filterMappings.has(map)) {
      return filterMappings.get(map);
    }
    const filtered = new Map;
    filterMappings.set(map, filtered);
    map.forEach((mapping, fieldName) => {
      if (mapping.kind === "Enum" || mapping.kind === "Scalar") {
        filtered.set(fieldName, mapping);
        return;
      }
      const hasNestedMappings = checkForMappings(mapping.fields.map);
      if (mapping.value !== null || hasNestedMappings) {
        const filteredTypeFields = filterMapped(mapping.fields.map);
        const mappingForType = {
          ...mapping,
          fields: {
            configs: mapping.fields.configs,
            map: filteredTypeFields
          }
        };
        filtered.set(fieldName, mappingForType);
      }
    });
    return filtered.size > 0 ? filtered : null;
  }
  function checkForMappings(map, hasMappings = new Map) {
    if (hasMappings.has(map)) {
      return hasMappings.get(map);
    }
    hasMappings.set(map, false);
    let result = false;
    map.forEach((mapping) => {
      if (mapping.value !== null) {
        result = true;
      } else if (mapping.kind === "InputObject" && mapping.fields.map && checkForMappings(mapping.fields.map, hasMappings)) {
        result = true;
      }
    });
    hasMappings.set(map, result);
    return result;
  }
}
var internalMapInputFields = function(inputs, buildCache, mapper, seenTypes) {
  const map = new Map;
  Object.keys(inputs).forEach((fieldName) => {
    const inputField = inputs[fieldName];
    const typeConfig = resolveInputTypeConfig(inputField.type, buildCache);
    const fieldMapping = mapper(inputField);
    if (typeConfig.kind === "Enum" || typeConfig.kind === "Scalar") {
      if (fieldMapping !== null) {
        map.set(fieldName, {
          kind: typeConfig.kind,
          isList: inputField.type.kind === "List",
          config: inputField,
          value: fieldMapping
        });
      }
      return;
    }
    const inputFieldConfigs = buildCache.getInputTypeFieldConfigs(unwrapInputFieldType(inputField.type));
    if (!seenTypes.has(typeConfig.name)) {
      const typeEntry = {
        configs: inputFieldConfigs,
        map: new Map
      };
      seenTypes.set(typeConfig.name, typeEntry);
      typeEntry.map = internalMapInputFields(inputFieldConfigs, buildCache, mapper, seenTypes);
    }
    const typeFields = seenTypes.get(typeConfig.name);
    map.set(fieldName, {
      kind: typeConfig.kind,
      isList: inputField.type.kind === "List",
      config: inputField,
      value: fieldMapping,
      fields: typeFields
    });
  });
  return map;
};
function createInputValueMapper(argMap, mapValue4) {
  return function mapObject(obj, map = argMap, ...args) {
    const mapped = {
      ...obj
    };
    map.forEach((field, fieldName) => {
      let fieldVal = obj[fieldName];
      if (fieldVal === null || fieldVal === undefined) {
        return;
      }
      if (field.kind === "InputObject" && field.fields.map) {
        fieldVal = field.isList ? fieldVal.map((val) => val && mapObject(val, field.fields.map, ...args)) : mapObject(fieldVal, field.fields.map, ...args);
        mapped[fieldName] = fieldVal;
      }
      if (field.kind !== "InputObject" || field.value !== null) {
        mapped[fieldName] = field.isList ? fieldVal.map((val) => mapValue4(val, field, ...args)) : mapValue4(fieldVal, field, ...args);
      }
    });
    return mapped;
  };
}

// ../../node_modules/@pothos/core/esm/utils/index.js
function assertNever(value) {
  throw new TypeError(`Unexpected value: ${value}`);
}
function assertArray(value) {
  if (!Array.isArray(value)) {
    throw new PothosValidationError("List resolvers must return arrays");
  }
  return true;
}
function isThenable(value) {
  return !!(value && (typeof value === "object" || typeof value === "function") && typeof value.then === "function");
}
function verifyRef(ref) {
  if (ref === undefined) {
    throw new PothosSchemaError(`Received undefined as a type ref.

This is often caused by a circular import
If this ref is imported from a file that re-exports it (like index.ts)
you may be able to resolve this by importing it directly from the file that defines it.
`);
  }
}
function verifyInterfaces(interfaces) {
  if (!interfaces || typeof interfaces === "function") {
    return;
  }
  if (!Array.isArray(interfaces)) {
    throw new PothosSchemaError("interfaces must be an array or function");
  }
  for (const iface of interfaces) {
    if (iface === undefined) {
      throw new PothosSchemaError(`Received undefined in list of interfaces.

This is often caused by a circular import
If this ref is imported from a file that re-exports it (like index.ts)
you may be able to resolve this by importing it directly from the file that defines it.

Alternatively you can define interfaces with a function that will be lazily evaluated,
which may resolver issues with circular dependencies:

Example:
builder.objectType('MyObject', {
  interface: () => [Interface1, Interface2],
  ...
});
`);
    }
  }
}
function brandWithType(val, type2) {
  if (typeof val !== "object" || val === null) {
    return;
  }
  Object.defineProperty(val, typeBrandKey, {
    enumerable: false,
    value: type2
  });
}
function getTypeBrand(val) {
  if (typeof val === "object" && val !== null && typeBrandKey in val) {
    return val[typeBrandKey];
  }
  return null;
}
function unwrapListParam(param) {
  if (Array.isArray(param)) {
    return unwrapListParam(param[0]);
  }
  if (param instanceof ListRef || param instanceof InputObjectRef2) {
    return unwrapListParam(param.listType);
  }
  return param;
}

// ../../node_modules/@pothos/core/esm/build-cache.js
class BuildCache {
  getTypeConfig(ref, kind) {
    const baseConfig = this.configStore.getTypeConfig(ref, kind);
    if (!this.typeConfigs.has(baseConfig.name)) {
      this.typeConfigs.set(baseConfig.name, this.plugin.onTypeConfig(baseConfig));
    }
    const typeConfig = this.typeConfigs.get(baseConfig.name);
    return typeConfig;
  }
  getInputTypeFieldConfigs(ref) {
    const typeConfig = this.getTypeConfig(ref, "InputObject");
    const builtType = this.types.get(typeConfig.name);
    if (!builtType) {
      throw new PothosSchemaError(`Input type ${typeConfig.name} has not been built yet`);
    }
    const fields5 = builtType.getFields();
    const fieldConfigs = {};
    Object.keys(fields5).forEach((fieldName) => {
      var _fields_fieldName_extensions;
      fieldConfigs[fieldName] = (_fields_fieldName_extensions = fields5[fieldName].extensions) === null || _fields_fieldName_extensions === undefined ? undefined : _fields_fieldName_extensions.pothosConfig;
    });
    return fieldConfigs;
  }
  getImplementers(iface) {
    if (this.implementers.has(iface.name)) {
      return this.implementers.get(iface.name);
    }
    const implementers = [
      ...this.configStore.typeConfigs.values()
    ].filter((type2) => type2.kind === "Object" && type2.interfaces.find((i) => this.configStore.getTypeConfig(i).name === iface.name));
    this.implementers.set(iface.name, implementers);
    return implementers;
  }
  buildAll() {
    this.configStore.prepareForBuild();
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Enum" || baseConfig.kind === "Scalar") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "InputObject") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.types.forEach((type2) => {
      if (type2 instanceof GraphQLInputObjectType) {
        type2.getFields();
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Interface") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Object") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Union") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.configStore.typeConfigs.forEach((baseConfig) => {
      if (baseConfig.kind === "Query" || baseConfig.kind === "Mutation" || baseConfig.kind === "Subscription") {
        this.buildTypeFromConfig(baseConfig);
      }
    });
    this.types.forEach((type2) => {
      if (type2 instanceof GraphQLObjectType || type2 instanceof GraphQLInterfaceType) {
        type2.getFields();
      } else if (type2 instanceof GraphQLUnionType) {
        type2.getTypes();
      }
    });
  }
  buildTypeFromConfig(baseConfig) {
    const config2 = this.getTypeConfig(baseConfig.name);
    const { name } = config2;
    this.typeConfigs.set(name, config2);
    switch (config2.kind) {
      case "Enum":
        this.addType(name, this.buildEnum(config2));
        break;
      case "InputObject":
        this.addType(name, this.buildInputObject(config2));
        break;
      case "Interface":
        this.addType(name, this.buildInterface(config2));
        break;
      case "Scalar":
        this.addType(name, this.buildScalar(config2));
        break;
      case "Union":
        this.addType(name, this.buildUnion(config2));
        break;
      case "Object":
      case "Query":
      case "Mutation":
      case "Subscription":
        this.addType(name, this.buildObject(config2));
        break;
      default:
        assertNever(config2);
    }
  }
  addType(ref, type2) {
    if (this.types.has(ref)) {
      throw new PothosSchemaError(`reference or name has already been used to create another type (${type2.name})`);
    }
    this.types.set(ref, type2);
  }
  buildOutputTypeParam(type2) {
    if (type2.kind === "List") {
      if (type2.nullable) {
        return new GraphQLList(this.buildOutputTypeParam(type2.type));
      }
      return new GraphQLNonNull(new GraphQLList(this.buildOutputTypeParam(type2.type)));
    }
    if (type2.nullable) {
      return this.getOutputType(type2.ref);
    }
    return new GraphQLNonNull(this.getOutputType(type2.ref));
  }
  buildInputTypeParam(type2) {
    if (type2.kind === "List") {
      if (type2.required) {
        return new GraphQLNonNull(new GraphQLList(this.buildInputTypeParam(type2.type)));
      }
      return new GraphQLList(this.buildInputTypeParam(type2.type));
    }
    if (type2.required) {
      return new GraphQLNonNull(this.getInputType(type2.ref));
    }
    return this.getInputType(type2.ref);
  }
  buildFields(fields5) {
    const built = {};
    for (const [fieldName, originalConfig] of fields5) {
      if (!this.outputFieldConfigs.has(originalConfig)) {
        this.outputFieldConfigs.set(originalConfig, this.plugin.onOutputFieldConfig(originalConfig));
      }
      const updatedConfig = this.outputFieldConfigs.get(originalConfig);
      if (!updatedConfig) {
        continue;
      }
      const config2 = {
        ...updatedConfig
      };
      const argMap = new Map;
      Object.keys(config2.args).forEach((argName) => {
        argMap.set(argName, config2.args[argName]);
      });
      const args = this.buildInputFields(argMap);
      const argConfigs = {};
      Object.keys(config2.args).forEach((argName) => {
        argConfigs[argName] = this.inputFieldConfigs.get(config2.args[argName]);
      });
      config2.args = argConfigs;
      var _config_resolve;
      const resolve = this.plugin.wrapResolve((_config_resolve = config2.resolve) !== null && _config_resolve !== undefined ? _config_resolve : defaultFieldResolver, config2);
      const subscribe3 = this.plugin.wrapSubscribe(config2.subscribe, config2);
      var _config_resolve1;
      built[fieldName] = {
        ...config2,
        type: this.buildOutputTypeParam(config2.type),
        args,
        extensions: {
          ...config2.extensions,
          pothosResolveWrapped: resolve !== ((_config_resolve1 = config2.resolve) !== null && _config_resolve1 !== undefined ? _config_resolve1 : defaultFieldResolver),
          pothosSubscribeWrapped: subscribe3 !== config2.subscribe,
          pothosOptions: config2.pothosOptions,
          pothosConfig: config2
        },
        resolve: resolve === defaultFieldResolver ? undefined : resolve,
        subscribe: subscribe3
      };
    }
    return built;
  }
  buildInputFields(fields5) {
    const built = {};
    for (const [fieldName, originalConfig] of fields5) {
      if (!this.inputFieldConfigs.has(originalConfig)) {
        this.inputFieldConfigs.set(originalConfig, this.plugin.onInputFieldConfig(originalConfig));
      }
      const config2 = this.inputFieldConfigs.get(originalConfig);
      if (config2) {
        built[fieldName] = {
          ...config2,
          type: this.buildInputTypeParam(config2.type),
          extensions: {
            ...config2.extensions,
            pothosOptions: config2.pothosOptions,
            pothosConfig: config2
          }
        };
      }
    }
    return built;
  }
  getInterfaceFields(type2) {
    const interfaceFields = type2.getInterfaces().reduce((all, iface) => ({
      ...this.getFields(iface),
      ...all
    }), {});
    const configs2 = this.configStore.getFields(type2.name, "Interface");
    const fields5 = this.buildFields(configs2);
    return {
      ...interfaceFields,
      ...fields5
    };
  }
  getObjectFields(type2) {
    const interfaceFields = type2.getInterfaces().reduce((all, iface) => ({
      ...this.getFields(iface),
      ...all
    }), {});
    const objectFields = this.buildFields(this.configStore.getFields(type2.name, "Object"));
    return {
      ...interfaceFields,
      ...objectFields
    };
  }
  getRootFields(type2) {
    return this.buildFields(this.configStore.getFields(type2.name, "Object"));
  }
  getFields(type2) {
    if (type2 instanceof GraphQLObjectType) {
      if (type2.name === "Query" || type2.name === "Mutation" || type2.name === "Subscription") {
        return this.getRootFields(type2);
      }
      return this.getObjectFields(type2);
    }
    if (type2 instanceof GraphQLInterfaceType) {
      return this.getInterfaceFields(type2);
    }
    throw new PothosSchemaError(`Type ${type2.name} does not have fields to resolve`);
  }
  getInputFields(type2) {
    return this.buildInputFields(this.configStore.getFields(type2.name, "InputObject"));
  }
  getType(ref) {
    if (ref instanceof BuiltinScalarRef) {
      return ref.type;
    }
    const typeConfig = this.configStore.getTypeConfig(ref);
    const type2 = this.types.get(typeConfig.name);
    if (!type2) {
      this.buildTypeFromConfig(typeConfig);
      return this.types.get(typeConfig.name);
    }
    return type2;
  }
  getOutputType(ref) {
    const type2 = this.getType(ref);
    if (type2 instanceof GraphQLInputObjectType) {
      throw new PothosSchemaError(`Expected ${String(ref)} to be an output type but it was defined as an InputObject`);
    }
    return type2;
  }
  getInputType(ref) {
    const type2 = this.getType(ref);
    if (!type2) {
      throw new PothosSchemaError(`Missing implementation of for type ${String(ref)}`);
    }
    if (type2 instanceof GraphQLObjectType) {
      throw new PothosSchemaError(`Expected ${ImplementableInputObjectRef} to be an input type but it was defined as a GraphQLObjectType`);
    }
    if (type2 instanceof GraphQLInterfaceType) {
      throw new PothosSchemaError(`Expected ${ImplementableInputObjectRef} to be an input type but it was defined as a GraphQLInterfaceType`);
    }
    if (type2 instanceof GraphQLUnionType) {
      throw new PothosSchemaError(`Expected ${String(ref)} to be an input type but it was defined as an GraphQLUnionType`);
    }
    return type2;
  }
  getTypeOfKind(ref, kind) {
    const type2 = this.getType(ref);
    switch (kind) {
      case "Object":
      case "Query":
      case "Mutation":
      case "Subscription":
        if (type2 instanceof GraphQLObjectType) {
          return type2;
        }
        break;
      case "Interface":
        if (type2 instanceof GraphQLInterfaceType) {
          return type2;
        }
        break;
      case "Union":
        if (type2 instanceof GraphQLUnionType) {
          return type2;
        }
        break;
      case "Enum":
        if (type2 instanceof GraphQLEnumType) {
          return type2;
        }
        break;
      case "Scalar":
        if (type2 instanceof GraphQLScalarType) {
          return type2;
        }
        break;
      case "InputObject":
        if (type2 instanceof GraphQLScalarType) {
          return type2;
        }
        break;
      default:
        break;
    }
    throw new PothosSchemaError(`Expected ${String(ref)} to be of type ${kind}`);
  }
  buildObject(config2) {
    var _config_isTypeOf;
    const type2 = new GraphQLObjectType({
      ...config2,
      extensions: {
        ...config2.extensions,
        pothosOptions: config2.pothosOptions,
        pothosConfig: config2
      },
      fields: () => this.getFields(type2),
      isTypeOf: config2.kind === "Object" ? this.plugin.wrapIsTypeOf((_config_isTypeOf = config2.isTypeOf) !== null && _config_isTypeOf !== undefined ? _config_isTypeOf : undefined, config2) : undefined,
      interfaces: config2.kind === "Object" ? () => config2.interfaces.map((iface) => this.getTypeOfKind(iface, "Interface")) : undefined
    });
    return type2;
  }
  buildInterface(config2) {
    const resolveType = (parent, context, info) => {
      const typeBrand = getTypeBrand(parent);
      if (typeBrand) {
        if (typeof typeBrand === "string") {
          return typeBrand;
        }
        return this.getTypeConfig(typeBrand).name;
      }
      var _config_resolveType;
      const resolver = (_config_resolveType = config2.resolveType) !== null && _config_resolveType !== undefined ? _config_resolveType : defaultTypeResolver;
      return resolver(parent, context, info, type2);
    };
    const type2 = new GraphQLInterfaceType({
      ...config2,
      extensions: {
        ...config2.extensions,
        pothosOptions: config2.pothosOptions,
        pothosConfig: config2
      },
      interfaces: () => config2.interfaces.map((iface) => this.getTypeOfKind(iface, "Interface")),
      fields: () => this.getFields(type2),
      resolveType: this.plugin.wrapResolveType(resolveType, config2)
    });
    return type2;
  }
  buildUnion(config2) {
    const resolveType = (parent, context, info, type2) => {
      if (typeof parent === "object" && parent !== null && typeBrandKey in parent) {
        const typeBrand = parent[typeBrandKey];
        if (typeof typeBrand === "string") {
          return typeBrand;
        }
        return this.getTypeConfig(typeBrand).name;
      }
      if (!config2.resolveType) {
        return defaultTypeResolver(parent, context, info, type2);
      }
      const resultOrPromise = config2.resolveType(parent, context, info, type2);
      const getResult = (result) => {
        if (typeof result === "string" || !result) {
          return result;
        }
        if (result instanceof GraphQLObjectType) {
          return result.name;
        }
        try {
          const typeConfig = this.configStore.getTypeConfig(result);
          return typeConfig.name;
        } catch {
        }
        return result;
      };
      return isThenable(resultOrPromise) ? resultOrPromise.then(getResult) : getResult(resultOrPromise);
    };
    return new GraphQLUnionType({
      ...config2,
      extensions: {
        ...config2.extensions,
        pothosOptions: config2.pothosOptions,
        pothosConfig: config2
      },
      types: () => config2.types.map((member) => this.getTypeOfKind(member, "Object")),
      resolveType: this.plugin.wrapResolveType(resolveType, config2)
    });
  }
  buildInputObject(config2) {
    const type2 = new GraphQLInputObjectType({
      ...config2,
      extensions: {
        ...config2.extensions,
        pothosOptions: config2.pothosOptions,
        pothosConfig: config2
      },
      fields: () => this.getInputFields(type2)
    });
    return type2;
  }
  buildScalar(config2) {
    if (config2.name === "ID") {
      return GraphQLID;
    }
    if (config2.name === "Int") {
      return GraphQLInt;
    }
    if (config2.name === "Float") {
      return GraphQLFloat;
    }
    if (config2.name === "Boolean") {
      return GraphQLBoolean;
    }
    if (config2.name === "String") {
      return GraphQLString;
    }
    return new GraphQLScalarType({
      ...config2,
      extensions: {
        ...config2.extensions,
        pothosOptions: config2.pothosOptions,
        pothosConfig: config2
      }
    });
  }
  buildEnum(config2) {
    const values4 = {};
    for (const key of Object.keys(config2.values)) {
      const original = config2.values[key];
      if (!this.enumValueConfigs.has(original)) {
        this.enumValueConfigs.set(original, this.plugin.onEnumValueConfig(original));
      }
      const valueConfig = this.enumValueConfigs.get(original);
      if (valueConfig) {
        values4[key] = this.enumValueConfigs.get(original);
      }
    }
    return new GraphQLEnumType({
      ...config2,
      values: values4,
      extensions: {
        ...config2.extensions,
        pothosOptions: config2.pothosOptions,
        pothosConfig: config2
      }
    });
  }
  constructor(builder, options) {
    _defineProperty9(this, "types", new Map);
    _defineProperty9(this, "builder", undefined);
    _defineProperty9(this, "plugin", undefined);
    _defineProperty9(this, "options", undefined);
    _defineProperty9(this, "configStore", undefined);
    _defineProperty9(this, "pluginMap", undefined);
    _defineProperty9(this, "pluginList", undefined);
    _defineProperty9(this, "implementers", new Map);
    _defineProperty9(this, "typeConfigs", new Map);
    _defineProperty9(this, "enumValueConfigs", new Map);
    _defineProperty9(this, "outputFieldConfigs", new Map);
    _defineProperty9(this, "inputFieldConfigs", new Map);
    this.builder = builder;
    this.configStore = builder.configStore;
    this.options = options;
    const plugins3 = {};
    var _builder_options_plugins;
    this.pluginList = ((_builder_options_plugins = builder.options.plugins) !== null && _builder_options_plugins !== undefined ? _builder_options_plugins : []).map((pluginName) => {
      const Plugin = this.builder.constructor.plugins[pluginName];
      if (!Plugin) {
        throw new PothosError(`No plugin named ${pluginName} was registered`);
      }
      plugins3[pluginName] = new Plugin(this, pluginName);
      return plugins3[pluginName];
    });
    this.pluginMap = plugins3;
    this.plugin = new MergedPlugins(this, this.pluginList);
  }
}

// ../../node_modules/@pothos/core/esm/config-store.js
var _defineProperty12 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/core/esm/refs/input.js
var _defineProperty10 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _inputShapeKey4 = inputShapeKey;

class InputTypeRef extends BaseTypeRef {
  constructor(kind, name) {
    super(kind, name);
    _defineProperty10(this, "kind", undefined);
    _defineProperty10(this, _inputShapeKey4, undefined);
    this.kind = kind;
  }
}

// ../../node_modules/@pothos/core/esm/refs/output.js
var _defineProperty11 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _outputShapeKey3 = outputShapeKey;
var _parentShapeKey3 = parentShapeKey;

class OutputTypeRef extends BaseTypeRef {
  constructor(kind, name) {
    super(kind, name);
    _defineProperty11(this, "kind", undefined);
    _defineProperty11(this, _outputShapeKey3, undefined);
    _defineProperty11(this, _parentShapeKey3, undefined);
    this.kind = kind;
  }
}

// ../../node_modules/@pothos/core/esm/config-store.js
class ConfigStore {
  hasConfig(typeParam) {
    if (typeof typeParam === "string") {
      return this.typeConfigs.has(typeParam);
    }
    return this.refsToName.has(typeParam);
  }
  addUnionTypes(typeName, unionTypes) {
    this.onPrepare(() => {
      const typeConfig = this.getTypeConfig(typeName);
      if (typeConfig.graphqlKind !== "Union") {
        throw new PothosSchemaError(`Can not add types to ${typeName} because it is a ${typeConfig.kind}`);
      }
      typeConfig.types = [
        ...typeConfig.types,
        ...typeof unionTypes === "function" ? unionTypes() : unionTypes
      ];
    });
  }
  addInterfaces(typeName, interfaces) {
    this.onPrepare(() => {
      const typeConfig = this.getTypeConfig(typeName);
      if (typeConfig.graphqlKind !== "Object" && typeConfig.graphqlKind !== "Interface" || typeConfig.kind === "Query" || typeConfig.kind === "Mutation" || typeConfig.kind === "Subscription") {
        throw new PothosSchemaError(`Can not add interfaces to ${typeName} because it is a ${typeConfig.kind}`);
      }
      typeConfig.interfaces = [
        ...typeConfig.interfaces,
        ...typeof interfaces === "function" ? interfaces() : interfaces
      ];
    });
  }
  addFieldRef(ref, typeParam, args, getConfig) {
    if (this.fieldRefs.has(ref)) {
      throw new PothosSchemaError(`FieldRef ${String(ref)} has already been added to config store`);
    }
    const typeRefOrName = unwrapListParam(typeParam);
    const argRefs = Object.keys(args).map((argName) => {
      const argRef = args[argName];
      argRef.fieldName = argName;
      argRef.argFor = ref;
      return argRef;
    });
    const checkArgs = () => {
      for (const arg of argRefs) {
        if (this.pendingFields.has(arg)) {
          const unresolvedArgType = this.pendingFields.get(arg);
          this.pendingFields.set(ref, unresolvedArgType);
          this.onTypeConfig(unresolvedArgType, checkArgs);
          return;
        }
      }
      this.pendingFields.delete(ref);
      this.fieldRefs.set(ref, getConfig);
    };
    if (this.hasConfig(typeRefOrName) || typeRefOrName instanceof BaseTypeRef || this.scalarsToRefs.has(typeRefOrName)) {
      checkArgs();
    } else {
      this.pendingFields.set(ref, typeRefOrName);
      this.onTypeConfig(typeRefOrName, () => {
        checkArgs();
      });
    }
  }
  createFieldConfig(ref, name, typeConfig, parentField, kind) {
    if (!this.fieldRefs.has(ref)) {
      if (this.pendingFields.has(ref)) {
        throw new PothosSchemaError(`Missing implementation for ${this.describeRef(this.pendingFields.get(ref))}`);
      }
      throw new PothosSchemaError(`Missing definition for ${String(ref)}`);
    }
    const config2 = this.fieldRefs.get(ref)(name, parentField, typeConfig);
    if (kind && config2.graphqlKind !== kind) {
      throw new PothosError(`Expected ref for field named ${name} to resolve to a ${kind} type, but got ${config2.graphqlKind}`);
    }
    return config2;
  }
  associateRefWithName(ref, name) {
    if (!this.typeConfigs.has(name)) {
      throw new PothosSchemaError(`${name} has not been implemented yet`);
    }
    this.refsToName.set(ref, name);
    if (this.pendingRefResolutions.has(ref)) {
      const cbs = this.pendingRefResolutions.get(ref);
      this.pendingRefResolutions.delete(ref);
      cbs.forEach((cb) => void cb(this.typeConfigs.get(name)));
    }
  }
  addTypeConfig(config2, ref) {
    const { name } = config2;
    if (this.typeConfigs.has(name)) {
      throw new PothosSchemaError(`Duplicate typename: Another type with name ${name} already exists.`);
    }
    this.typeConfigs.set(config2.name, config2);
    if (ref) {
      this.associateRefWithName(ref, name);
    }
    if (this.pendingRefResolutions.has(name)) {
      const cbs = this.pendingRefResolutions.get(name);
      this.pendingRefResolutions.delete(name);
      cbs.forEach((cb) => void cb(config2));
    }
  }
  getTypeConfig(ref, kind) {
    let config2;
    if (typeof ref === "string") {
      if (!this.typeConfigs.has(ref)) {
        throw new PothosSchemaError(`Type ${String(ref)} has not been implemented`);
      }
      config2 = this.typeConfigs.get(ref);
    } else if (this.refsToName.has(ref)) {
      config2 = this.typeConfigs.get(this.refsToName.get(ref));
    } else if (ref instanceof ListRef || ref instanceof InputObjectRef2) {
      throw new PothosSchemaError(`Expected a base type but got a ${ref.kind} of ${String(ref.listType)}`);
    } else {
      throw new PothosSchemaError(`Ref ${String(ref)} has not been implemented`);
    }
    if (kind && config2.graphqlKind !== kind) {
      throw new PothosSchemaError(`Expected ref to resolve to a ${kind} type, but got ${config2.kind}`);
    }
    return config2;
  }
  getInputTypeRef(ref) {
    if (ref instanceof BaseTypeRef) {
      if (ref.kind !== "InputObject" && ref.kind !== "Enum" && ref.kind !== "Scalar") {
        throw new PothosSchemaError(`Expected ${ref.name} to be an input type but got ${ref.kind}`);
      }
      return ref;
    }
    if (typeof ref === "string") {
      if (this.scalarsToRefs.has(ref)) {
        return this.scalarsToRefs.get(ref);
      }
      if (this.typeConfigs.has(ref)) {
        const config2 = this.typeConfigs.get(ref);
        if (config2.graphqlKind !== "InputObject" && config2.graphqlKind !== "Enum" && config2.graphqlKind !== "Scalar") {
          throw new PothosSchemaError(`Expected ${config2.name} to be an input type but got ${config2.graphqlKind}`);
        }
        const newRef = new InputTypeRef(config2.graphqlKind, config2.name);
        this.refsToName.set(newRef, config2.name);
        return newRef;
      }
    }
    return ref;
  }
  getOutputTypeRef(ref) {
    if (ref instanceof BaseTypeRef) {
      if (ref.kind === "InputObject" || ref.kind === "InputList") {
        throw new PothosSchemaError(`Expected ${ref.name} to be an output type but got ${ref.kind}`);
      }
      if (ref.kind === "List") {
        throw new PothosSchemaError(`Expected ${ref.name} to be a base type but got a ${ref.kind}`);
      }
      return ref;
    }
    if (typeof ref === "string") {
      if (this.scalarsToRefs.has(ref)) {
        return this.scalarsToRefs.get(ref);
      }
      if (this.typeConfigs.has(ref)) {
        const config2 = this.typeConfigs.get(ref);
        if (config2.graphqlKind === "InputObject") {
          throw new PothosSchemaError(`Expected ${config2.name} to be an output type but got ${config2.graphqlKind}`);
        }
        const newRef = new OutputTypeRef(config2.graphqlKind, config2.name);
        this.refsToName.set(newRef, config2.name);
        return newRef;
      }
    }
    return ref;
  }
  onTypeConfig(ref, cb) {
    if (!ref) {
      throw new PothosSchemaError(`${String(ref)} is not a valid type ref`);
    }
    if (this.refsToName.has(ref)) {
      cb(this.getTypeConfig(ref));
    } else if (typeof ref === "string" && this.typeConfigs.has(ref)) {
      cb(this.typeConfigs.get(ref));
    } else if (!this.pending) {
      throw new PothosSchemaError(`Ref ${String(ref)} has not been implemented`);
    } else if (this.pendingRefResolutions.has(ref)) {
      this.pendingRefResolutions.get(ref).push(cb);
    } else {
      this.pendingRefResolutions.set(ref, [
        cb
      ]);
    }
  }
  onFieldUse(ref, cb) {
    if (!this.fieldRefCallbacks.has(ref)) {
      this.fieldRefCallbacks.set(ref, []);
    }
    this.fieldRefCallbacks.get(ref).push(cb);
    if (this.fieldRefsToConfigs.has(ref)) {
      this.fieldRefsToConfigs.get(ref).forEach((config2) => void cb(config2));
    }
  }
  getFields(name, kind) {
    const typeConfig = this.getTypeConfig(name);
    if (!this.fields.has(name)) {
      this.fields.set(name, new Map);
    }
    const fields5 = this.fields.get(name);
    if (kind && typeConfig.graphqlKind !== kind) {
      throw new PothosSchemaError(`Expected ${name} to be a ${kind} type, but found ${typeConfig.graphqlKind}`);
    }
    return fields5;
  }
  prepareForBuild() {
    this.pending = false;
    const { pendingActions } = this;
    this.pendingActions = [];
    pendingActions.forEach((fn) => void fn());
    if (this.pendingRefResolutions.size > 0) {
      throw new PothosSchemaError(`Missing implementations for some references (${[
        ...this.pendingRefResolutions.keys()
      ].map((ref) => this.describeRef(ref)).join(", ")}).`);
    }
  }
  onPrepare(cb) {
    if (this.pending) {
      this.pendingActions.push(cb);
    } else {
      cb();
    }
  }
  addFields(typeRef, fields5) {
    this.onPrepare(() => void this.onTypeConfig(typeRef, (config2) => {
      this.buildFields(typeRef, typeof fields5 === "function" ? fields5() : fields5);
    }));
  }
  getImplementers(ref) {
    const typeConfig = this.getTypeConfig(ref, "Interface");
    const implementers = [
      ...this.typeConfigs.values()
    ].filter((type2) => type2.kind === "Object" && type2.interfaces.find((i) => this.getTypeConfig(i).name === typeConfig.name));
    return implementers;
  }
  describeRef(ref) {
    var _find;
    if (typeof ref === "string") {
      return ref;
    }
    if (ref.toString !== {}.toString) {
      return String(ref);
    }
    const usedBy = (_find = [
      ...this.pendingFields.entries()
    ].find(([fieldRef, typeRef]) => typeRef === ref)) === null || _find === undefined ? undefined : _find[0];
    if (usedBy) {
      return `<unnamed ref or enum: used by ${usedBy}>`;
    }
    return `<unnamed ref or enum>`;
  }
  buildFields(typeRef, fields5) {
    Object.keys(fields5).forEach((fieldName) => {
      const fieldRef = fields5[fieldName];
      fieldRef.fieldName = fieldName;
      if (this.pendingFields.has(fieldRef)) {
        this.onTypeConfig(this.pendingFields.get(fieldRef), () => {
          this.buildField(typeRef, fieldRef, fieldName);
        });
      } else {
        this.buildField(typeRef, fieldRef, fieldName);
      }
    });
  }
  buildField(typeRef, field, fieldName) {
    const typeConfig = this.getTypeConfig(typeRef);
    const fieldConfig = this.createFieldConfig(field, fieldName, typeConfig);
    const existingFields = this.getFields(typeConfig.name);
    if (existingFields.has(fieldName)) {
      throw new PothosSchemaError(`Duplicate field definition for field ${fieldName} in ${typeConfig.name}`);
    }
    if (fieldConfig.graphqlKind !== typeConfig.graphqlKind) {
      throw new PothosSchemaError(`${typeConfig.name}.${fieldName} was defined as a ${fieldConfig.graphqlKind} field but ${typeConfig.name} is a ${typeConfig.graphqlKind}`);
    }
    existingFields.set(fieldName, fieldConfig);
    if (!this.fieldRefsToConfigs.has(field)) {
      this.fieldRefsToConfigs.set(field, []);
    }
    this.fieldRefsToConfigs.get(field).push(fieldConfig);
    if (this.fieldRefCallbacks.has(field)) {
      this.fieldRefCallbacks.get(field).forEach((cb) => void cb(fieldConfig));
    }
  }
  constructor() {
    _defineProperty12(this, "typeConfigs", new Map);
    _defineProperty12(this, "fieldRefs", new WeakMap);
    _defineProperty12(this, "fields", new Map);
    _defineProperty12(this, "pendingActions", []);
    _defineProperty12(this, "refsToName", new Map);
    _defineProperty12(this, "scalarsToRefs", new Map);
    _defineProperty12(this, "fieldRefsToConfigs", new Map);
    _defineProperty12(this, "pendingFields", new Map);
    _defineProperty12(this, "pendingRefResolutions", new Map);
    _defineProperty12(this, "fieldRefCallbacks", new Map);
    _defineProperty12(this, "pending", true);
    const scalars12 = [
      GraphQLID,
      GraphQLInt,
      GraphQLFloat,
      GraphQLString,
      GraphQLBoolean
    ];
    scalars12.forEach((scalar3) => {
      const ref = new BuiltinScalarRef(scalar3);
      this.scalarsToRefs.set(scalar3.name, ref);
      this.refsToName.set(ref, scalar3.name);
    });
  }
}

// ../../node_modules/@pothos/core/esm/fieldUtils/input.js
var _defineProperty14 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/core/esm/refs/input-field.js
var _defineProperty13 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _inputFieldShapeKey = inputFieldShapeKey;

class InputFieldRef {
  toString() {
    var _this_argFor;
    if (this.kind !== "Arg") {
      if (this.fieldName) {
        return `${this.parentTypename}.${this.fieldName}`;
      }
      return this.parentTypename;
    }
    var _this_argFor_fieldName;
    const fieldName = (_this_argFor_fieldName = (_this_argFor = this.argFor) === null || _this_argFor === undefined ? undefined : _this_argFor.fieldName) !== null && _this_argFor_fieldName !== undefined ? _this_argFor_fieldName : "[unnamed field]";
    var _this_fieldName;
    const argName = (_this_fieldName = this.fieldName) !== null && _this_fieldName !== undefined ? _this_fieldName : "[unnamed argument]";
    return `${this.parentTypename}.${fieldName}(${argName})`;
  }
  constructor(kind, parentTypename) {
    _defineProperty13(this, "kind", undefined);
    _defineProperty13(this, "parentTypename", undefined);
    _defineProperty13(this, "fieldName", undefined);
    _defineProperty13(this, "argFor", undefined);
    _defineProperty13(this, _inputFieldShapeKey, undefined);
    this.kind = kind;
    this.parentTypename = parentTypename;
  }
}

// ../../node_modules/@pothos/core/esm/fieldUtils/input.js
class InputFieldBuilder {
  argBuilder() {
    const builder = this.field.bind(this);
    const protoKeys = Object.keys(Object.getPrototypeOf(this)).filter((key) => typeof this[key] === "function" && Function.prototype[key] === undefined);
    [
      ...Object.keys(this),
      ...protoKeys
    ].forEach((key) => {
      builder[key] = typeof this[key] === "function" ? this[key].bind(this) : this[key];
    });
    return builder;
  }
  field(options) {
    const ref = new InputFieldRef(this.kind, this.typename);
    var _options_required;
    this.builder.configStore.addFieldRef(ref, options.type, {}, (name, parentField, typeConfig) => ({
      name,
      parentField,
      kind: this.kind,
      graphqlKind: this.kind,
      parentType: typeConfig.name,
      type: inputTypeFromParam(options.type, this.builder.configStore, (_options_required = options.required) !== null && _options_required !== undefined ? _options_required : this.builder.defaultInputFieldRequiredness),
      pothosOptions: options,
      description: options.description,
      deprecationReason: options.deprecationReason,
      defaultValue: options.defaultValue,
      extensions: options.extensions
    }));
    return ref;
  }
  helper(type2) {
    return (...args) => {
      const [options = {}] = args;
      return this.field({
        ...options,
        type: type2
      });
    };
  }
  constructor(builder, kind, typename) {
    _defineProperty14(this, "builder", undefined);
    _defineProperty14(this, "kind", undefined);
    _defineProperty14(this, "typename", undefined);
    _defineProperty14(this, "boolean", this.helper("Boolean"));
    _defineProperty14(this, "float", this.helper("Float"));
    _defineProperty14(this, "id", this.helper("ID"));
    _defineProperty14(this, "int", this.helper("Int"));
    _defineProperty14(this, "string", this.helper("String"));
    _defineProperty14(this, "booleanList", this.helper([
      "Boolean"
    ]));
    _defineProperty14(this, "floatList", this.helper([
      "Float"
    ]));
    _defineProperty14(this, "idList", this.helper([
      "ID"
    ]));
    _defineProperty14(this, "intList", this.helper([
      "Int"
    ]));
    _defineProperty14(this, "stringList", this.helper([
      "String"
    ]));
    var _options_required;
    _defineProperty14(this, "listRef", (type2, options) => {
      return new InputObjectRef2(type2, (_options_required = options === null || options === undefined ? undefined : options.required) !== null && _options_required !== undefined ? _options_required : true);
    });
    this.builder = builder;
    this.kind = kind;
    this.typename = typename;
  }
}

// ../../node_modules/@pothos/core/esm/fieldUtils/root.js
var _defineProperty17 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/core/esm/fieldUtils/base.js
var _defineProperty16 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/core/esm/refs/field.js
var _defineProperty15 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _outputFieldShapeKey = outputFieldShapeKey;

class FieldRef {
  toString() {
    if (this.fieldName) {
      return `${this.parentTypename}.${this.fieldName}`;
    }
    return this.parentTypename;
  }
  constructor(kind, parentTypename) {
    _defineProperty15(this, "kind", undefined);
    _defineProperty15(this, "parentTypename", undefined);
    _defineProperty15(this, "fieldName", undefined);
    _defineProperty15(this, _outputFieldShapeKey, undefined);
    this.kind = kind;
    this.parentTypename = parentTypename;
  }
}

// ../../node_modules/@pothos/core/esm/fieldUtils/base.js
class BaseFieldUtil {
  createField(options) {
    const ref = new FieldRef(this.kind, this.typename);
    var _options_args;
    this.builder.configStore.addFieldRef(ref, options.type, (_options_args = options.args) !== null && _options_args !== undefined ? _options_args : {}, (name, parentField, typeConfig) => {
      var _options_extensions;
      const args = {};
      if (options.args) {
        Object.keys(options.args).forEach((argName) => {
          const argRef = options.args[argName];
          args[argName] = this.builder.configStore.createFieldConfig(argRef, argName, typeConfig, name, "Arg");
        });
      }
      var _options_resolve;
      let resolve = (_options_resolve = options.resolve) !== null && _options_resolve !== undefined ? _options_resolve : () => {
        throw new PothosSchemaError(`Not implemented: No resolver found for ${this.typename}.${name}`);
      };
      if (((_options_extensions = options.extensions) === null || _options_extensions === undefined ? undefined : _options_extensions.pothosExposedField) === name) {
        resolve = defaultFieldResolver;
      }
      const { subscribe: subscribe3 } = options;
      var _options_nullable;
      return {
        kind: this.kind,
        graphqlKind: this.graphqlKind,
        parentType: typeConfig.name,
        name,
        args,
        type: typeFromParam(options.type, this.builder.configStore, (_options_nullable = options.nullable) !== null && _options_nullable !== undefined ? _options_nullable : this.builder.defaultFieldNullability),
        pothosOptions: options,
        extensions: {
          pothosOriginalResolve: resolve,
          pothosOriginalSubscribe: subscribe3,
          ...options.extensions
        },
        description: options.description,
        deprecationReason: options.deprecationReason,
        resolve,
        subscribe: subscribe3
      };
    });
    return ref;
  }
  exposeField(name, { extensions, ...options }) {
    return this.createField({
      ...options,
      extensions: {
        pothosExposedField: name,
        ...extensions
      },
      resolve: (parent) => parent[name]
    });
  }
  constructor(name, builder, kind, graphqlKind) {
    _defineProperty16(this, "typename", undefined);
    _defineProperty16(this, "builder", undefined);
    _defineProperty16(this, "kind", undefined);
    _defineProperty16(this, "graphqlKind", undefined);
    this.typename = name;
    this.builder = builder;
    this.kind = kind;
    this.graphqlKind = graphqlKind;
  }
}

// ../../node_modules/@pothos/core/esm/fieldUtils/root.js
class RootFieldBuilder extends BaseFieldUtil {
  boolean(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: "Boolean"
    });
  }
  float(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: "Float"
    });
  }
  id(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: "ID"
    });
  }
  int(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: "Int"
    });
  }
  string(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: "String"
    });
  }
  booleanList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: [
        "Boolean"
      ]
    });
  }
  floatList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: [
        "Float"
      ]
    });
  }
  idList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: [
        "ID"
      ]
    });
  }
  intList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: [
        "Int"
      ]
    });
  }
  stringList(...args) {
    const [options = {}] = args;
    return this.createField({
      resolve: undefined,
      ...options,
      type: [
        "String"
      ]
    });
  }
  field(options) {
    return this.createField(options);
  }
  listRef(type2, options) {
    var _options_nullable;
    return new ListRef(type2, (_options_nullable = options === null || options === undefined ? undefined : options.nullable) !== null && _options_nullable !== undefined ? _options_nullable : false);
  }
  constructor(...args) {
    super(...args);
    _defineProperty17(this, "arg", new InputFieldBuilder(this.builder, "Arg", this.typename).argBuilder());
  }
}

// ../../node_modules/@pothos/core/esm/fieldUtils/builder.js
class FieldBuilder extends RootFieldBuilder {
  exposeBoolean(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "Boolean"
    });
  }
  exposeFloat(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "Float"
    });
  }
  exposeID(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "ID"
    });
  }
  exposeInt(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "Int"
    });
  }
  exposeString(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: "String"
    });
  }
  exposeBooleanList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "Boolean"
      ]
    });
  }
  exposeFloatList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "Float"
      ]
    });
  }
  exposeIDList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "ID"
      ]
    });
  }
  exposeIntList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "Int"
      ]
    });
  }
  exposeStringList(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, {
      ...options,
      type: [
        "String"
      ]
    });
  }
  expose(name, ...args) {
    const [options = {}] = args;
    return this.exposeField(name, options);
  }
}

// ../../node_modules/@pothos/core/esm/fieldUtils/interface.js
class InterfaceFieldBuilder extends FieldBuilder {
  constructor(name, builder2) {
    super(name, builder2, "Interface", "Interface");
  }
}

// ../../node_modules/@pothos/core/esm/fieldUtils/mutation.js
class MutationFieldBuilder extends RootFieldBuilder {
  constructor(builder2) {
    super("Mutation", builder2, "Mutation", "Object");
  }
}

// ../../node_modules/@pothos/core/esm/fieldUtils/object.js
class ObjectFieldBuilder extends FieldBuilder {
  constructor(name, builder3) {
    super(name, builder3, "Object", "Object");
  }
}

// ../../node_modules/@pothos/core/esm/fieldUtils/query.js
class QueryFieldBuilder extends RootFieldBuilder {
  constructor(builder3) {
    super("Query", builder3, "Query", "Object");
  }
}

// ../../node_modules/@pothos/core/esm/fieldUtils/subscription.js
class SubscriptionFieldBuilder extends RootFieldBuilder {
  constructor(builder3) {
    super("Subscription", builder3, "Subscription", "Object");
  }
}

// ../../node_modules/@pothos/core/esm/refs/enum.js
var _defineProperty18 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _outputShapeKey4 = outputShapeKey;
var _inputShapeKey5 = inputShapeKey;

class EnumRef extends BaseTypeRef {
  constructor(name) {
    super("Enum", name);
    _defineProperty18(this, "kind", "Enum");
    _defineProperty18(this, _outputShapeKey4, undefined);
    _defineProperty18(this, _inputShapeKey5, undefined);
  }
}

// ../../node_modules/@pothos/core/esm/refs/interface.js
var _defineProperty19 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _outputShapeKey5 = outputShapeKey;
var _parentShapeKey4 = parentShapeKey;

class InterfaceRef extends BaseTypeRef {
  constructor(name) {
    super("Interface", name);
    _defineProperty19(this, "kind", "Interface");
    _defineProperty19(this, _outputShapeKey5, undefined);
    _defineProperty19(this, _parentShapeKey4, undefined);
  }
}
class ImplementableInterfaceRef extends InterfaceRef {
  implement(options) {
    return this.builder.interfaceType(this, options);
  }
  constructor(builder3, name) {
    super(name);
    _defineProperty19(this, "builder", undefined);
    this.builder = builder3;
  }
}

// ../../node_modules/@pothos/core/esm/refs/object.js
var _defineProperty20 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _outputShapeKey6 = outputShapeKey;
var _parentShapeKey5 = parentShapeKey;

class ObjectRef extends BaseTypeRef {
  constructor(name) {
    super("Object", name);
    _defineProperty20(this, "kind", "Object");
    _defineProperty20(this, _outputShapeKey6, undefined);
    _defineProperty20(this, _parentShapeKey5, undefined);
  }
}
class ImplementableObjectRef extends ObjectRef {
  implement(options) {
    return this.builder.objectType(this, options);
  }
  constructor(builder3, name) {
    super(name);
    _defineProperty20(this, "builder", undefined);
    this.builder = builder3;
  }
}

// ../../node_modules/@pothos/core/esm/refs/union.js
var _defineProperty21 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};
var _outputShapeKey7 = outputShapeKey;
var _parentShapeKey6 = parentShapeKey;

class UnionRef extends BaseTypeRef {
  constructor(name) {
    super("Union", name);
    _defineProperty21(this, "kind", "Union");
    _defineProperty21(this, _outputShapeKey7, undefined);
    _defineProperty21(this, _parentShapeKey6, undefined);
  }
}

// ../../node_modules/@pothos/core/esm/builder.js
class SchemaBuilder {
  static registerPlugin(name, plugin4) {
    if (!this.allowPluginReRegistration && this.plugins[name]) {
      throw new PothosError(`Received multiple implementations for plugin ${name}`);
    }
    this.plugins[name] = plugin4;
  }
  objectType(param, options, fields5) {
    verifyRef(param);
    verifyInterfaces(options.interfaces);
    var _options_name;
    const name = typeof param === "string" ? param : (_options_name = options.name) !== null && _options_name !== undefined ? _options_name : param.name;
    if (name === "Query" || name === "Mutation" || name === "Subscription") {
      throw new PothosSchemaError(`Invalid object name ${name} use .create${name}Type() instead`);
    }
    const ref = param instanceof BaseTypeRef ? param : new ObjectRef(name);
    const config2 = {
      kind: "Object",
      graphqlKind: "Object",
      name,
      interfaces: [],
      description: options.description,
      extensions: options.extensions,
      isTypeOf: options.isTypeOf,
      pothosOptions: options
    };
    this.configStore.addTypeConfig(config2, ref);
    if (options.interfaces) {
      this.configStore.addInterfaces(name, options.interfaces);
    }
    if (typeof param === "function") {
      this.configStore.associateRefWithName(param, name);
    }
    if (fields5) {
      this.configStore.addFields(ref, () => fields5(new ObjectFieldBuilder(name, this)));
    }
    if (options.fields) {
      this.configStore.addFields(ref, () => {
        const t = new ObjectFieldBuilder(name, this);
        return options.fields(t);
      });
    }
    return ref;
  }
  objectFields(ref, fields5) {
    verifyRef(ref);
    this.configStore.onTypeConfig(ref, ({ name }) => {
      this.configStore.addFields(ref, () => fields5(new ObjectFieldBuilder(name, this)));
    });
  }
  objectField(ref, fieldName, field2) {
    verifyRef(ref);
    this.configStore.onTypeConfig(ref, ({ name }) => {
      this.configStore.addFields(ref, () => ({
        [fieldName]: field2(new ObjectFieldBuilder(name, this))
      }));
    });
  }
  queryType(...args) {
    const [options = {}, fields5] = args;
    const config2 = {
      kind: "Query",
      graphqlKind: "Object",
      name: "Query",
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    const ref = new ObjectRef("Query");
    this.configStore.addTypeConfig(config2, ref);
    if (fields5) {
      this.configStore.addFields("Query", () => fields5(new QueryFieldBuilder(this)));
    }
    if (options.fields) {
      this.configStore.addFields("Query", () => options.fields(new QueryFieldBuilder(this)));
    }
    return ref;
  }
  queryFields(fields5) {
    this.configStore.addFields("Query", () => fields5(new QueryFieldBuilder(this)));
  }
  queryField(name, field2) {
    this.configStore.addFields("Query", () => ({
      [name]: field2(new QueryFieldBuilder(this))
    }));
  }
  mutationType(...args) {
    const [options = {}, fields5] = args;
    const config2 = {
      kind: "Mutation",
      graphqlKind: "Object",
      name: "Mutation",
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config2);
    if (fields5) {
      this.configStore.addFields("Mutation", () => fields5(new MutationFieldBuilder(this)));
    }
    if (options.fields) {
      this.configStore.addFields("Mutation", () => options.fields(new MutationFieldBuilder(this)));
    }
  }
  mutationFields(fields5) {
    this.configStore.addFields("Mutation", () => fields5(new MutationFieldBuilder(this)));
  }
  mutationField(name, field2) {
    this.configStore.addFields("Mutation", () => ({
      [name]: field2(new MutationFieldBuilder(this))
    }));
  }
  subscriptionType(...args) {
    const [options = {}, fields5] = args;
    const config2 = {
      kind: "Subscription",
      graphqlKind: "Object",
      name: "Subscription",
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config2);
    if (fields5) {
      this.configStore.addFields("Subscription", () => fields5(new SubscriptionFieldBuilder(this)));
    }
    if (options.fields) {
      this.configStore.addFields("Subscription", () => options.fields(new SubscriptionFieldBuilder(this)));
    }
  }
  subscriptionFields(fields5) {
    this.configStore.addFields("Subscription", () => fields5(new SubscriptionFieldBuilder(this)));
  }
  subscriptionField(name, field2) {
    this.configStore.addFields("Subscription", () => ({
      [name]: field2(new SubscriptionFieldBuilder(this))
    }));
  }
  args(fields5) {
    return fields5(new InputFieldBuilder(this, "Arg", "[unknown]"));
  }
  interfaceType(param, options, fields5) {
    verifyRef(param);
    verifyInterfaces(options.interfaces);
    var _options_name;
    const name = typeof param === "string" ? param : (_options_name = options.name) !== null && _options_name !== undefined ? _options_name : param.name;
    const ref = param instanceof BaseTypeRef ? param : new InterfaceRef(name);
    const typename = ref.name;
    const config2 = {
      kind: "Interface",
      graphqlKind: "Interface",
      name: typename,
      interfaces: [],
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions,
      resolveType: options.resolveType
    };
    this.configStore.addTypeConfig(config2, ref);
    if (options.interfaces) {
      this.configStore.addInterfaces(typename, options.interfaces);
    }
    if (typeof param === "function") {
      this.configStore.associateRefWithName(param, name);
    }
    if (fields5) {
      this.configStore.addFields(ref, () => fields5(new InterfaceFieldBuilder(typename, this)));
    }
    if (options.fields) {
      this.configStore.addFields(ref, () => options.fields(new InterfaceFieldBuilder(typename, this)));
    }
    return ref;
  }
  interfaceFields(ref, fields5) {
    verifyRef(ref);
    this.configStore.onTypeConfig(ref, ({ name }) => {
      this.configStore.addFields(ref, () => fields5(new InterfaceFieldBuilder(name, this)));
    });
  }
  interfaceField(ref, fieldName, field2) {
    verifyRef(ref);
    this.configStore.onTypeConfig(ref, ({ name }) => {
      this.configStore.addFields(ref, () => ({
        [fieldName]: field2(new InterfaceFieldBuilder(name, this))
      }));
    });
  }
  unionType(name, options) {
    const ref = new UnionRef(name);
    if (Array.isArray(options.types)) {
      options.types.forEach((type2) => {
        verifyRef(type2);
      });
    }
    const config2 = {
      kind: "Union",
      graphqlKind: "Union",
      name,
      types: [],
      description: options.description,
      resolveType: options.resolveType,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config2, ref);
    this.configStore.addUnionTypes(name, options.types);
    return ref;
  }
  enumType(param, options) {
    verifyRef(param);
    const name = typeof param === "string" ? param : options.name;
    const ref = new EnumRef(name);
    const values4 = typeof param === "object" ? valuesFromEnum(param, options === null || options === undefined ? undefined : options.values) : normalizeEnumValues(options.values);
    const config2 = {
      kind: "Enum",
      graphqlKind: "Enum",
      name,
      values: values4,
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config2, ref);
    if (typeof param !== "string") {
      this.configStore.associateRefWithName(param, name);
    }
    return ref;
  }
  scalarType(name, options) {
    const ref = new ScalarRef(name);
    const config2 = {
      kind: "Scalar",
      graphqlKind: "Scalar",
      name,
      description: options.description,
      parseLiteral: options.parseLiteral,
      parseValue: options.parseValue,
      serialize: options.serialize,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config2, ref);
    return ref;
  }
  addScalarType(name, scalar4, options) {
    const config2 = scalar4.toConfig();
    return this.scalarType(name, {
      ...config2,
      ...options,
      extensions: {
        ...config2.extensions,
        ...options.extensions
      }
    });
  }
  inputType(param, options) {
    verifyRef(param);
    const name = typeof param === "string" ? param : param.name;
    const ref = typeof param === "string" ? new InputObjectRef(name) : param;
    const config2 = {
      kind: "InputObject",
      graphqlKind: "InputObject",
      name,
      description: options.description,
      pothosOptions: options,
      extensions: options.extensions
    };
    this.configStore.addTypeConfig(config2, ref);
    this.configStore.addFields(ref, () => options.fields(new InputFieldBuilder(this, "InputObject", name)));
    return ref;
  }
  inputRef(name) {
    return new ImplementableInputObjectRef(this, name);
  }
  objectRef(name) {
    return new ImplementableObjectRef(this, name);
  }
  interfaceRef(name) {
    return new ImplementableInterfaceRef(this, name);
  }
  toSchema(...args) {
    const [options = {}] = args;
    const { directives: directives24, extensions } = options;
    const scalars12 = [
      GraphQLID,
      GraphQLInt,
      GraphQLFloat,
      GraphQLString,
      GraphQLBoolean
    ];
    scalars12.forEach((scalar4) => {
      if (!this.configStore.hasConfig(scalar4.name)) {
        this.addScalarType(scalar4.name, scalar4, {});
      }
    });
    const buildCache = new BuildCache(this, options);
    buildCache.plugin.beforeBuild();
    buildCache.buildAll();
    const builtTypes = [
      ...buildCache.types.values()
    ];
    const schema6 = new GraphQLSchema({
      query: buildCache.types.get("Query"),
      mutation: buildCache.types.get("Mutation"),
      subscription: buildCache.types.get("Subscription"),
      extensions: extensions !== null && extensions !== undefined ? extensions : {},
      directives: directives24,
      types: builtTypes
    });
    const processedSchema = buildCache.plugin.afterBuild(schema6);
    return options.sortSchema === false ? processedSchema : lexicographicSortSchema(processedSchema);
  }
  constructor(options) {
    _defineProperty22(this, "configStore", undefined);
    _defineProperty22(this, "options", undefined);
    _defineProperty22(this, "defaultFieldNullability", undefined);
    _defineProperty22(this, "defaultInputFieldRequiredness", undefined);
    this.options = options;
    this.configStore = new ConfigStore;
    var _options_defaultFieldNullability;
    this.defaultFieldNullability = (_options_defaultFieldNullability = options.defaultFieldNullability) !== null && _options_defaultFieldNullability !== undefined ? _options_defaultFieldNullability : false;
    var _options_defaultInputFieldRequiredness;
    this.defaultInputFieldRequiredness = (_options_defaultInputFieldRequiredness = options.defaultInputFieldRequiredness) !== null && _options_defaultInputFieldRequiredness !== undefined ? _options_defaultInputFieldRequiredness : false;
  }
}
_defineProperty22(SchemaBuilder, "plugins", {});
_defineProperty22(SchemaBuilder, "allowPluginReRegistration", false);

// ../../node_modules/@pothos/core/esm/index.js
var SchemaBuilder2 = SchemaBuilder;
var esm_default = SchemaBuilder2;
var RootFieldBuilder2 = RootFieldBuilder;
var QueryFieldBuilder2 = QueryFieldBuilder;
var MutationFieldBuilder2 = MutationFieldBuilder;
var SubscriptionFieldBuilder2 = SubscriptionFieldBuilder;
var ObjectFieldBuilder2 = ObjectFieldBuilder;
var InterfaceFieldBuilder2 = InterfaceFieldBuilder;
var InputFieldBuilder2 = InputFieldBuilder;
var InputObjectRef3 = InputObjectRef;
var InterfaceRef2 = InterfaceRef;
var ObjectRef2 = ObjectRef;
// ../../node_modules/@pothos/plugin-relay/esm/utils/global-ids.js
function encodeGlobalID(typename, id) {
  return encodeBase64(`${typename}:${id}`);
}
function decodeGlobalID(globalID) {
  const [typename, id] = decodeBase64(globalID).split(":");
  if (!typename || !id) {
    throw new TypeError(`Invalid global ID: ${globalID}`);
  }
  return {
    typename,
    id
  };
}
// ../../node_modules/@pothos/plugin-relay/esm/utils/internal.js
function internalEncodeGlobalID(builder5, typename, id, ctx) {
  if (builder5.options.relayOptions.encodeGlobalID) {
    return builder5.options.relayOptions.encodeGlobalID(typename, id, ctx);
  }
  return encodeGlobalID(typename, id);
}
function internalDecodeGlobalID(builder5, globalID, ctx) {
  if (builder5.options.relayOptions.decodeGlobalID) {
    return builder5.options.relayOptions.decodeGlobalID(globalID, ctx);
  }
  return decodeGlobalID(globalID);
}

// ../../node_modules/@pothos/plugin-relay/esm/utils/resolve-nodes.js
async function resolveNodes(builder5, context, info, globalIDs) {
  const requestCache = getRequestCache(context);
  const idsByType = {};
  const results = {};
  globalIDs.forEach((globalID, i) => {
    if (globalID == null) {
      return;
    }
    if (requestCache.has(globalID)) {
      results[globalID] = requestCache.get(globalID);
      return;
    }
    const { id, typename } = internalDecodeGlobalID(builder5, globalID, context);
    idsByType[typename] = idsByType[typename] || new Map;
    idsByType[typename].set(id, globalID);
  });
  await Promise.all(Object.keys(idsByType).map(async (typename) => {
    const ids = [
      ...idsByType[typename].keys()
    ];
    const globalIds = [
      ...idsByType[typename].values()
    ];
    const config2 = builder5.configStore.getTypeConfig(typename, "Object");
    const options = config2.pothosOptions;
    var _brandLoadedObjects, ref;
    const shouldBrandObjects = (ref = (_brandLoadedObjects = options.brandLoadedObjects) !== null && _brandLoadedObjects !== undefined ? _brandLoadedObjects : builder5.options.relayOptions.brandLoadedObjects) !== null && ref !== undefined ? ref : false;
    const resultsForType = await resolveUncachedNodesForType(builder5, context, info, ids, typename);
    resultsForType.forEach((val, i) => {
      if (shouldBrandObjects) {
        brandWithType(val, typename);
      }
      results[globalIds[i]] = val;
    });
  }));
  var _globalID;
  return globalIDs.map((globalID) => globalID == null ? null : (_globalID = results[globalID]) !== null && _globalID !== undefined ? _globalID : null);
}
async function resolveUncachedNodesForType(builder5, context, info, ids, type2) {
  const requestCache = getRequestCache(context);
  const config2 = builder5.configStore.getTypeConfig(type2, "Object");
  const options = config2.pothosOptions;
  if (options.loadMany) {
    const loadManyPromise = Promise.resolve(options.loadMany(ids, context));
    return Promise.all(ids.map((id, i) => {
      const globalID = internalEncodeGlobalID(builder5, config2.name, id, context);
      const entryPromise = loadManyPromise.then((results) => results[i]).then((result) => {
        requestCache.set(globalID, result);
        return result;
      });
      requestCache.set(globalID, entryPromise);
      return entryPromise;
    }));
  }
  if (options.loadOne) {
    return Promise.all(ids.map((id) => {
      const globalID = internalEncodeGlobalID(builder5, config2.name, id, context);
      const entryPromise = Promise.resolve(options.loadOne(id, context)).then((result) => {
        requestCache.set(globalID, result);
        return result;
      });
      requestCache.set(globalID, entryPromise);
      return entryPromise;
    }));
  }
  if (options.loadManyWithoutCache) {
    return options.loadManyWithoutCache(ids, context);
  }
  if (options.loadWithoutCache) {
    return Promise.all(ids.map((id) => Promise.resolve(options.loadWithoutCache(id, context, info))));
  }
  throw new Error(`${config2.name} does not support loading by id`);
}
var getRequestCache = createContextCache(() => new Map);

// ../../node_modules/@pothos/plugin-relay/esm/utils/index.js
function capitalize(s) {
  return `${s.slice(0, 1).toUpperCase()}${s.slice(1)}`;
}

// ../../node_modules/@pothos/plugin-relay/esm/field-builder.js
var fieldBuilderProto = RootFieldBuilder2.prototype;
fieldBuilderProto.globalIDList = function globalIDList({ resolve, ...options }) {
  const wrappedResolve = async (parent, args, context, info) => {
    const result = await resolve(parent, args, context, info);
    if (!result) {
      return result;
    }
    assertArray(result);
    if (Array.isArray(result)) {
      return (await Promise.all(result)).map((item) => item == null || typeof item === "string" ? item : internalEncodeGlobalID(this.builder, this.builder.configStore.getTypeConfig(item.type).name, String(item.id), context));
    }
    return null;
  };
  return this.field({
    ...options,
    type: [
      "ID"
    ],
    resolve: wrappedResolve
  });
};
fieldBuilderProto.globalID = function globalID({ resolve, ...options }) {
  const wrappedResolve = async (parent, args, context, info) => {
    const result = await resolve(parent, args, context, info);
    if (!result || typeof result === "string") {
      return result;
    }
    const item = result;
    return internalEncodeGlobalID(this.builder, this.builder.configStore.getTypeConfig(item.type).name, String(item.id), context);
  };
  return this.field({
    ...options,
    type: "ID",
    resolve: wrappedResolve
  });
};
fieldBuilderProto.node = function node({ id, ...options }) {
  return this.field({
    ...options,
    type: this.builder.nodeInterfaceRef(),
    nullable: true,
    resolve: async (parent, args, context, info) => {
      const rawID = await id(parent, args, context, info);
      if (rawID == null) {
        return null;
      }
      const globalID2 = typeof rawID === "string" ? rawID : internalEncodeGlobalID(this.builder, this.builder.configStore.getTypeConfig(rawID.type).name, String(rawID.id), context);
      return (await resolveNodes(this.builder, context, info, [
        globalID2
      ]))[0];
    }
  });
};
fieldBuilderProto.nodeList = function nodeList({ ids, ...options }) {
  return this.field({
    ...options,
    nullable: {
      list: false,
      items: true
    },
    type: [
      this.builder.nodeInterfaceRef()
    ],
    resolve: async (parent, args, context, info) => {
      const rawIDList = await ids(parent, args, context, info);
      assertArray(rawIDList);
      if (!Array.isArray(rawIDList)) {
        return [];
      }
      const rawIds = await Promise.all(rawIDList);
      const globalIds = rawIds.map((id) => !id || typeof id === "string" ? id : internalEncodeGlobalID(this.builder, this.builder.configStore.getTypeConfig(id.type).name, String(id.id), context));
      return resolveNodes(this.builder, context, info, globalIds);
    }
  });
};
fieldBuilderProto.connection = function connection({ type: type2, edgesNullable, nodeNullable, ...fieldOptions }, connectionOptionsOrRef = {}, edgeOptionsOrRef = {}) {
  var ref;
  const connectionRef = connectionOptionsOrRef instanceof ObjectRef2 ? connectionOptionsOrRef : this.builder.objectRef("Unnamed connection");
  const fieldRef = this.field({
    ...(ref = this.builder.options.relayOptions) === null || ref === undefined ? undefined : ref.defaultConnectionFieldOptions,
    ...fieldOptions,
    type: connectionRef,
    args: {
      ...fieldOptions.args,
      ...this.arg.connectionArgs()
    },
    resolve: fieldOptions.resolve
  });
  if (!(connectionOptionsOrRef instanceof ObjectRef2)) {
    this.builder.configStore.onFieldUse(fieldRef, (fieldConfig) => {
      var _name;
      const connectionName = (_name = connectionOptionsOrRef.name) !== null && _name !== undefined ? _name : `${this.typename}${capitalize(fieldConfig.name)}${fieldConfig.name.toLowerCase().endsWith("connection") ? "" : "Connection"}`;
      this.builder.connectionObject({
        type: type2,
        edgesNullable,
        nodeNullable,
        ...connectionOptionsOrRef,
        name: connectionName
      }, edgeOptionsOrRef instanceof ObjectRef2 ? edgeOptionsOrRef : {
        name: `${connectionName}Edge`,
        ...edgeOptionsOrRef
      });
      this.builder.configStore.associateRefWithName(connectionRef, connectionName);
    });
  }
  return fieldRef;
};

// ../../node_modules/@pothos/plugin-relay/esm/input-field-builder.js
var inputFieldBuilder = InputFieldBuilder2.prototype;
inputFieldBuilder.globalIDList = function globalIDList2(options = {}) {
  return this.idList({
    ...options,
    extensions: {
      ...options.extensions,
      isRelayGlobalID: true
    }
  });
};
inputFieldBuilder.globalID = function globalID2(options = {}) {
  return this.id({
    ...options,
    extensions: {
      ...options.extensions,
      isRelayGlobalID: true
    }
  });
};
inputFieldBuilder.connectionArgs = function connectionArgs() {
  const {
    cursorType = "ID",
    beforeArgOptions = {},
    afterArgOptions = {},
    firstArgOptions = {},
    lastArgOptions = {}
  } = this.builder.options.relayOptions;
  return {
    before: this.field({
      ...beforeArgOptions,
      type: cursorType,
      required: false
    }),
    after: this.field({
      ...afterArgOptions,
      type: cursorType,
      required: false
    }),
    first: this.int({
      ...firstArgOptions,
      required: false
    }),
    last: this.int({
      ...lastArgOptions,
      required: false
    })
  };
};

// ../../node_modules/@pothos/plugin-relay/esm/schema-builder.js
var schemaBuilderProto = esm_default.prototype;
var pageInfoRefMap = new WeakMap;
var nodeInterfaceRefMap = new WeakMap;
var connectionRefs = new WeakMap;
var globalConnectionFieldsMap = new WeakMap;
schemaBuilderProto.pageInfoRef = function pageInfoRef() {
  if (pageInfoRefMap.has(this)) {
    return pageInfoRefMap.get(this);
  }
  const ref = this.objectRef("PageInfo");
  pageInfoRefMap.set(this, ref);
  const { cursorType = "String", hasNextPageFieldOptions = {}, hasPreviousPageFieldOptions = {}, startCursorFieldOptions = {}, endCursorFieldOptions = {} } = this.options.relayOptions;
  ref.implement({
    ...this.options.relayOptions.pageInfoTypeOptions,
    fields: (t) => ({
      hasNextPage: t.exposeBoolean("hasNextPage", {
        nullable: false,
        ...hasNextPageFieldOptions
      }),
      hasPreviousPage: t.exposeBoolean("hasPreviousPage", {
        nullable: false,
        ...hasPreviousPageFieldOptions
      }),
      startCursor: t.expose("startCursor", {
        nullable: true,
        ...startCursorFieldOptions,
        type: cursorType
      }),
      endCursor: t.expose("endCursor", {
        nullable: true,
        ...endCursorFieldOptions,
        type: cursorType
      })
    })
  });
  return ref;
};
schemaBuilderProto.nodeInterfaceRef = function nodeInterfaceRef() {
  if (nodeInterfaceRefMap.has(this)) {
    return nodeInterfaceRefMap.get(this);
  }
  const ref = this.interfaceRef("Node");
  nodeInterfaceRefMap.set(this, ref);
  var ref1;
  ref.implement({
    resolveType: (value, context, info, graphQLType) => {
      if (!value) {
        return defaultTypeResolver(value, context, info, graphQLType);
      }
      const typeBrand = getTypeBrand(value);
      if (typeBrand) {
        const type2 = this.configStore.getTypeConfig(typeBrand);
        return type2.name;
      }
      try {
        if (typeof value === "object") {
          const typename = value.__typename;
          if (typename) {
            return typename;
          }
          const nodeRef = value.__type;
          if (nodeRef) {
            const config2 = this.configStore.getTypeConfig(nodeRef);
            if (config2) {
              return config2.name;
            }
          }
        }
      } catch {
      }
      return defaultTypeResolver(value, context, info, graphQLType);
    },
    ...this.options.relayOptions.nodeTypeOptions,
    fields: (t) => {
      var ref2;
      return {
        [(ref1 = (ref2 = this.options.relayOptions) === null || ref2 === undefined ? undefined : ref2.idFieldName) !== null && ref1 !== undefined ? ref1 : "id"]: t.globalID({
          nullable: false,
          resolve: (parent) => {
            throw new Error("id field not implemented");
          }
        })
      };
    }
  });
  this.queryField("node", (t) => t.field({
    nullable: true,
    ...this.options.relayOptions.nodeQueryOptions,
    type: ref,
    args: {
      id: t.arg.id({
        required: true
      })
    },
    resolve: async (root6, args, context, info) => (await resolveNodes(this, context, info, [
      String(args.id)
    ]))[0]
  }));
  this.queryField("nodes", (t) => t.field({
    nullable: {
      list: false,
      items: true
    },
    ...this.options.relayOptions.nodesQueryOptions,
    type: [
      ref
    ],
    args: {
      ids: t.arg.idList({
        required: true
      })
    },
    resolve: async (root6, args, context, info) => await resolveNodes(this, context, info, args.ids)
  }));
  return ref;
};
schemaBuilderProto.node = function node2(param, { interfaces, ...options }, fields5) {
  verifyRef(param);
  const interfacesWithNode = [
    this.nodeInterfaceRef(),
    ...interfaces !== null && interfaces !== undefined ? interfaces : []
  ];
  let nodeName;
  var _isTypeOf;
  const ref = this.objectType(param, {
    ...options,
    isTypeOf: (_isTypeOf = options.isTypeOf) !== null && _isTypeOf !== undefined ? _isTypeOf : typeof param === "function" ? (maybeNode, context, info) => {
      if (!maybeNode) {
        return false;
      }
      if (maybeNode instanceof param) {
        return true;
      }
      const proto = Object.getPrototypeOf(maybeNode);
      try {
        if (proto === null || proto === undefined ? undefined : proto.constructor) {
          const config2 = this.configStore.getTypeConfig(proto.constructor);
          return config2.name === nodeName;
        }
      } catch {
      }
      return false;
    } : undefined,
    interfaces: interfacesWithNode
  }, fields5);
  this.configStore.onTypeConfig(ref, (nodeConfig) => {
    nodeName = nodeConfig.name;
    var _idFieldName;
    this.objectField(ref, (_idFieldName = this.options.relayOptions.idFieldName) !== null && _idFieldName !== undefined ? _idFieldName : "id", (t) => t.globalID({
      nullable: false,
      ...this.options.relayOptions.idFieldOptions,
      ...options.id,
      args: {},
      resolve: async (parent, args, context, info) => ({
        type: nodeConfig.name,
        id: await options.id.resolve(parent, args, context, info)
      })
    }));
  });
  return ref;
};
schemaBuilderProto.globalConnectionField = function globalConnectionField(name, field2) {
  var ref;
  const onRef = (ref2) => {
    this.objectField(ref2, name, field2);
  };
  (ref = connectionRefs.get(this)) === null || ref === undefined || ref.forEach((ref2) => void onRef(ref2));
  if (!globalConnectionFieldsMap.has(this)) {
    globalConnectionFieldsMap.set(this, []);
  }
  globalConnectionFieldsMap.get(this).push(onRef);
};
schemaBuilderProto.globalConnectionFields = function globalConnectionFields(fields5) {
  var ref;
  const onRef = (ref2) => {
    this.objectFields(ref2, fields5);
  };
  (ref = connectionRefs.get(this)) === null || ref === undefined || ref.forEach((ref2) => void onRef(ref2));
  if (!globalConnectionFieldsMap.has(this)) {
    globalConnectionFieldsMap.set(this, []);
  }
  globalConnectionFieldsMap.get(this).push(onRef);
};
var mutationIdCache = createContextCache(() => new Map);
schemaBuilderProto.relayMutationField = function relayMutationField(fieldName, inputOptionsOrRef, { resolve, ...fieldOptions }, { name: payloadName = `${capitalize(fieldName)}Payload`, outputFields, interfaces, ...paylaodOptions }) {
  var ref;
  const { relayOptions: { clientMutationIdInputOptions = {}, clientMutationIdFieldOptions = {}, mutationInputArgOptions = {} } } = this.options;
  const includeClientMutationId = this.options.relayOptions.clientMutationId !== "omit";
  let inputRef;
  let argName = "input";
  if (inputOptionsOrRef instanceof InputObjectRef3) {
    inputRef = inputOptionsOrRef;
  } else {
    var ref1;
    const { name: inputName = `${capitalize(fieldName)}Input`, argName: argNameFromOptions = "input", inputFields, ...inputOptions } = inputOptionsOrRef;
    argName = argNameFromOptions;
    inputRef = this.inputType(inputName, {
      ...(ref1 = this.options.relayOptions) === null || ref1 === undefined ? undefined : ref1.defaultMutationInputTypeOptions,
      ...inputOptions,
      fields: (t) => ({
        ...inputFields(t),
        ...includeClientMutationId ? {
          clientMutationId: t.id({
            ...clientMutationIdInputOptions,
            required: this.options.relayOptions.clientMutationId !== "optional"
          })
        } : {}
      })
    });
  }
  const payloadRef = this.objectRef(payloadName).implement({
    ...(ref = this.options.relayOptions) === null || ref === undefined ? undefined : ref.defaultPayloadTypeOptions,
    ...paylaodOptions,
    interfaces,
    fields: (t) => ({
      ...outputFields(t),
      ...includeClientMutationId ? {
        clientMutationId: t.id({
          nullable: this.options.relayOptions.clientMutationId === "optional",
          ...clientMutationIdFieldOptions,
          resolve: (parent, args, context, info) => mutationIdCache(context).get(String(info.path.prev.key))
        })
      } : {}
    })
  });
  this.mutationField(fieldName, (t) => t.field({
    ...fieldOptions,
    type: payloadRef,
    args: {
      [argName]: t.arg({
        ...mutationInputArgOptions,
        type: inputRef,
        required: true
      })
    },
    resolve: (root6, args, context, info) => {
      mutationIdCache(context).set(String(info.path.key), args[argName].clientMutationId);
      return resolve(root6, args, context, info);
    }
  }));
  return {
    inputType: inputRef,
    payloadType: payloadRef
  };
};
schemaBuilderProto.connectionObject = function connectionObject({ type: type2, name: connectionName, edgesNullable: edgesNullableField, nodeNullable, ...connectionOptions }, edgeOptionsOrRef) {
  var ref, ref1;
  verifyRef(type2);
  const { edgesFieldOptions: { nullable: edgesNullable = {
    items: true,
    list: false
  }, ...edgesFieldOptions } = {}, pageInfoFieldOptions = {} } = this.options.relayOptions;
  const connectionRef = this.objectRef(connectionName);
  const edgeRef = edgeOptionsOrRef instanceof ObjectRef2 ? edgeOptionsOrRef : this.edgeObject({
    name: `${connectionName.replace(/Connection$/, "")}Edge`,
    ...edgeOptionsOrRef,
    nodeNullable,
    type: type2
  });
  const connectionFields = connectionOptions.fields;
  const { nodesOnConnection } = this.options.relayOptions;
  const edgesNullableOption = edgesNullableField !== null && edgesNullableField !== undefined ? edgesNullableField : edgesNullable;
  const edgeListNullable = typeof edgesNullableOption === "object" ? edgesNullableOption.list : !!edgesNullableOption;
  const edgeItemsNullable = typeof edgesNullableOption === "object" && "items" in edgesNullableOption ? edgesNullableOption.items : false;
  var ref2, ref3, ref4;
  this.objectType(connectionRef, {
    ...(ref = this.options.relayOptions) === null || ref === undefined ? undefined : ref.defaultConnectionTypeOptions,
    ...connectionOptions,
    fields: (t) => {
      var ref5, ref12;
      return {
        pageInfo: t.field({
          nullable: false,
          ...pageInfoFieldOptions,
          type: this.pageInfoRef(),
          resolve: (parent) => parent.pageInfo
        }),
        edges: t.field({
          nullable: edgesNullableField !== null && edgesNullableField !== undefined ? edgesNullableField : edgesNullable,
          ...edgesFieldOptions,
          type: [
            edgeRef
          ],
          resolve: (parent) => parent.edges
        }),
        ...nodesOnConnection ? {
          nodes: t.field({
            ...typeof nodesOnConnection === "object" ? nodesOnConnection : {},
            type: [
              type2
            ],
            nullable: {
              list: edgeListNullable,
              items: (ref3 = (ref2 = edgeItemsNullable !== null && edgeItemsNullable !== undefined ? edgeItemsNullable : nodeNullable) !== null && ref2 !== undefined ? ref2 : (ref5 = this.options.relayOptions) === null || ref5 === undefined ? undefined : (ref12 = ref5.nodeFieldOptions) === null || ref12 === undefined ? undefined : ref12.nullable) !== null && ref3 !== undefined ? ref3 : false
            },
            resolve: (con) => {
              var ref6;
              return (ref4 = (ref6 = con.edges) === null || ref6 === undefined ? undefined : ref6.map((edge) => {
                return edge === null || edge === undefined ? undefined : edge.node;
              })) !== null && ref4 !== undefined ? ref4 : [];
            }
          })
        } : {},
        ...connectionFields === null || connectionFields === undefined ? undefined : connectionFields(t)
      };
    }
  });
  if (!connectionRefs.has(this)) {
    connectionRefs.set(this, []);
  }
  connectionRefs.get(this).push(connectionRef);
  (ref1 = globalConnectionFieldsMap.get(this)) === null || ref1 === undefined || ref1.forEach((fieldFn) => void fieldFn(connectionRef));
  return connectionRef;
};
schemaBuilderProto.edgeObject = function edgeObject({ type: type2, name: edgeName, nodeNullable: nodeFieldNullable, ...edgeOptions }) {
  var ref;
  verifyRef(type2);
  const { cursorType = "String", cursorFieldOptions = {}, nodeFieldOptions: { nullable: nodeNullable = false, ...nodeFieldOptions } = {} } = this.options.relayOptions;
  const edgeRef = this.objectRef(edgeName);
  const edgeFields = edgeOptions.fields;
  this.objectType(edgeRef, {
    ...(ref = this.options.relayOptions) === null || ref === undefined ? undefined : ref.defaultEdgeTypeOptions,
    ...edgeOptions,
    fields: (t) => {
      return {
        node: t.field({
          nullable: nodeFieldNullable !== null && nodeFieldNullable !== undefined ? nodeFieldNullable : nodeNullable,
          ...nodeFieldOptions,
          type: type2,
          resolve: (parent) => parent.node
        }),
        cursor: t.expose("cursor", {
          nullable: false,
          type: cursorType,
          ...cursorFieldOptions
        }),
        ...edgeFields === null || edgeFields === undefined ? undefined : edgeFields(t)
      };
    }
  });
  return edgeRef;
};

// ../../node_modules/@pothos/plugin-relay/esm/index.js
var pluginName = "relay";
var esm_default2 = pluginName;

class PothosRelayPlugin extends BasePlugin {
  wrapResolve(resolver, fieldConfig) {
    const argMappings = mapInputFields(fieldConfig.args, this.buildCache, (inputField) => {
      var ref;
      if ((ref = inputField.extensions) === null || ref === undefined ? undefined : ref.isRelayGlobalID) {
        return true;
      }
      return null;
    });
    if (!argMappings) {
      return resolver;
    }
    const argMapper = createInputValueMapper(argMappings, (globalID3, mappings, ctx) => internalDecodeGlobalID(this.builder, String(globalID3), ctx));
    return (parent, args, context, info) => resolver(parent, argMapper(args, undefined, context), context, info);
  }
  wrapSubscribe(subscribe3, fieldConfig) {
    const argMappings = mapInputFields(fieldConfig.args, this.buildCache, (inputField) => {
      var ref;
      if ((ref = inputField.extensions) === null || ref === undefined ? undefined : ref.isRelayGlobalID) {
        return true;
      }
      return null;
    });
    if (!argMappings || !subscribe3) {
      return subscribe3;
    }
    const argMapper = createInputValueMapper(argMappings, (globalID3, mappings, ctx) => internalDecodeGlobalID(this.builder, String(globalID3), ctx));
    return (parent, args, context, info) => subscribe3(parent, argMapper(args, undefined, context), context, info);
  }
}
esm_default.registerPlugin(pluginName, PothosRelayPlugin);

// ../../node_modules/@pothos/plugin-with-input/esm/schema-builder.js
var capitalize2 = function(s) {
  return `${s.slice(0, 1).toUpperCase()}${s.slice(1)}`;
};
var rootBuilderProto = RootFieldBuilder2.prototype;
rootBuilderProto.fieldWithInput = function fieldWithInput({ typeOptions: { name: typeName, ...typeOptions } = {}, argOptions: { name: argName = "input", ...argOptions } = {}, args, input: input6, ...fieldOptions }) {
  var ref;
  const inputRef = this.builder.inputRef(typeName !== null && typeName !== undefined ? typeName : `UnnamedWithInputOn${this.typename}`);
  const fieldRef = this.field({
    args: {
      ...args,
      [argName]: this.arg({
        required: true,
        ...(ref = this.builder.options.withInput) === null || ref === undefined ? undefined : ref.argOptions,
        ...argOptions,
        type: inputRef
      })
    },
    ...fieldOptions
  });
  this.builder.configStore.onFieldUse(fieldRef, (config2) => {
    var ref2;
    const name = typeName !== null && typeName !== undefined ? typeName : `${this.typename}${capitalize2(config2.name)}Input`;
    this.builder.inputType(name, {
      fields: () => input6,
      ...(ref2 = this.builder.options.withInput) === null || ref2 === undefined ? undefined : ref2.typeOptions,
      ...typeOptions
    });
    this.builder.configStore.associateRefWithName(inputRef, name);
  });
  return fieldRef;
};
Object.defineProperty(rootBuilderProto, "input", {
  get: function getInputBuilder() {
    return new InputFieldBuilder2(this.builder, "InputObject", `UnnamedWithInputOn${this.typename}`);
  }
});

// ../../node_modules/@pothos/plugin-with-input/esm/index.js
var pluginName2 = "withInput";
var esm_default3 = pluginName2;

class PothosWithInputPlugin extends BasePlugin {
}
esm_default.registerPlugin(pluginName2, PothosWithInputPlugin);

// ../../node_modules/@pothos/plugin-scope-auth/esm/errors.js
var _define_property = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/plugin-scope-auth/esm/types.js
var AuthScopeFailureType;
(function(AuthScopeFailureType2) {
  AuthScopeFailureType2["AuthScope"] = "AuthScope";
  AuthScopeFailureType2["AuthScopeFunction"] = "AuthScopeFunction";
  AuthScopeFailureType2["GrantedScope"] = "GrantedScope";
  AuthScopeFailureType2["AnyAuthScopes"] = "AnyAuthScopes";
  AuthScopeFailureType2["AllAuthScopes"] = "AllAuthScopes";
  AuthScopeFailureType2["Unknown"] = "Unknown";
})(AuthScopeFailureType || (AuthScopeFailureType = {}));

// ../../node_modules/@pothos/plugin-scope-auth/esm/errors.js
class ForbiddenError extends PothosValidationError {
  constructor(message, result) {
    super(message);
    _define_property(this, "code", "FORBIDDEN");
    _define_property(this, "result", undefined);
    this.name = "ForbiddenError";
    this.result = result !== null && result !== undefined ? result : {
      kind: AuthScopeFailureType.Unknown
    };
    Object.defineProperty(this, "name", {
      value: "ForbiddenError"
    });
  }
}

// ../../node_modules/@pothos/plugin-scope-auth/esm/request-cache.js
var _define_property2 = function(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
};

// ../../node_modules/@pothos/plugin-scope-auth/esm/util.js
function canCache(map) {
  if (map.$granted) {
    return false;
  }
  return (map.$all ? canCache(map.$all) : true) && (map.$any ? canCache(map.$any) : true);
}
function cacheKey(path) {
  if (!path) {
    return "*";
  }
  let key = String(path.key);
  let current = path.prev;
  while (current) {
    key = `${current.key}.${key}`;
    current = current.prev;
  }
  return key;
}

// ../../node_modules/@pothos/plugin-scope-auth/esm/request-cache.js
var requestCache = new WeakMap;

class RequestCache {
  static fromContext(context, builder5) {
    if (!requestCache.has(context)) {
      requestCache.set(context, new RequestCache(builder5, context));
    }
    return requestCache.get(context);
  }
  getScopes() {
    if (!this.scopes) {
      const scopes = this.builder.options.authScopes(this.context);
      this.scopes = isThenable(scopes) ? scopes.then((resolved) => {
        this.scopes = resolved;
        return resolved;
      }) : scopes;
    }
    return this.scopes;
  }
  withScopes(cb) {
    const scopes = this.getScopes();
    if (isThenable(scopes)) {
      return scopes.then((resolvedScopes) => cb(resolvedScopes));
    }
    return cb(scopes);
  }
  saveGrantedScopes(scopes, path) {
    const key = cacheKey(path);
    if (this.grantCache.has(key)) {
      const set = this.grantCache.get(key);
      scopes.forEach((scope) => set.add(scope));
    } else {
      this.grantCache.set(key, new Set(scopes));
    }
    return null;
  }
  testGrantedScopes(scope, path) {
    var _this_grantCache_get, _path_prev, _this_grantCache_get1;
    if ((_this_grantCache_get = this.grantCache.get(cacheKey(path.prev))) === null || _this_grantCache_get === undefined ? undefined : _this_grantCache_get.has(scope)) {
      return true;
    }
    if (typeof ((_path_prev = path.prev) === null || _path_prev === undefined ? undefined : _path_prev.key) === "number" && ((_this_grantCache_get1 = this.grantCache.get(cacheKey(path.prev.prev))) === null || _this_grantCache_get1 === undefined ? undefined : _this_grantCache_get1.has(scope))) {
      return true;
    }
    return false;
  }
  grantTypeScopes(type2, parent, path, cb) {
    if (!this.typeGrants.has(type2)) {
      this.typeGrants.set(type2, new Map);
    }
    const cache = this.typeGrants.get(type2);
    if (!cache.has(parent)) {
      const result = cb();
      if (isThenable(result)) {
        cache.set(parent, result.then((resolved) => this.saveGrantedScopes(resolved, path)));
      } else {
        cache.set(parent, this.saveGrantedScopes(result, path));
      }
    }
    return cache.get(parent);
  }
  evaluateScopeLoader(scopes, name, arg) {
    if (!this.scopeCache.has(name)) {
      this.scopeCache.set(name, new Map);
    }
    const cache = this.scopeCache.get(name);
    const key = this.cacheKey ? this.cacheKey(arg) : arg;
    if (!cache.has(key)) {
      const loader = scopes[name];
      if (typeof loader !== "function") {
        throw new PothosValidationError(`Attempted to evaluate scope ${String(name)} as scope loader, but it is not a function`);
      }
      let result;
      if (this.treatErrorsAsUnauthorized) {
        try {
          result = loader(arg);
        } catch (error8) {
          cache.set(key, {
            kind: AuthScopeFailureType.AuthScope,
            scope: name,
            parameter: arg,
            error: error8
          });
          return cache.get(key);
        }
      } else {
        result = loader(arg);
      }
      if (isThenable(result)) {
        let promise = result.then((r) => r ? null : {
          kind: AuthScopeFailureType.AuthScope,
          scope: name,
          parameter: arg,
          error: null
        });
        if (this.treatErrorsAsUnauthorized) {
          promise = promise.catch((error8) => ({
            kind: AuthScopeFailureType.AuthScope,
            scope: name,
            parameter: arg,
            error: error8
          }));
        }
        cache.set(key, promise);
      } else {
        cache.set(key, result ? null : {
          kind: AuthScopeFailureType.AuthScope,
          scope: name,
          parameter: arg,
          error: null
        });
      }
    }
    return cache.get(key);
  }
  evaluateScopeMapWithScopes({ $all, $any, $granted, ...map }, scopes, info, forAll) {
    const scopeNames = Object.keys(map);
    const problems = [];
    const failure = {
      kind: forAll ? AuthScopeFailureType.AllAuthScopes : AuthScopeFailureType.AnyAuthScopes,
      failures: problems
    };
    const loaderList = [];
    for (const scopeName of scopeNames) {
      if (scopes[scopeName] == null || scopes[scopeName] === false) {
        problems.push({
          kind: AuthScopeFailureType.AuthScope,
          scope: scopeName,
          parameter: map[scopeName],
          error: null
        });
        if (forAll) {
          return failure;
        }
        continue;
      }
      const scope = scopes[scopeName];
      if (typeof scope === "function") {
        loaderList.push([
          scopeName,
          map[scopeName]
        ]);
      } else if (scope && !forAll) {
        return null;
      } else if (!scope) {
        problems.push({
          kind: AuthScopeFailureType.AuthScope,
          scope: scopeName,
          parameter: map[scopeName],
          error: null
        });
        if (forAll) {
          return failure;
        }
      }
    }
    const promises = [];
    if ($granted) {
      const result = !!info && this.testGrantedScopes($granted, info.path);
      if (result && !forAll) {
        return null;
      }
      if (!result) {
        problems.push({
          kind: AuthScopeFailureType.GrantedScope,
          scope: $granted
        });
        if (forAll) {
          return failure;
        }
      }
    }
    if ($any) {
      const anyResult = this.evaluateScopeMap($any, info, false);
      if (isThenable(anyResult)) {
        promises.push(anyResult);
      } else if (anyResult === null && !forAll) {
        return null;
      } else if (anyResult) {
        problems.push(anyResult);
        if (forAll) {
          return failure;
        }
      }
    }
    if ($all) {
      const allResult = this.evaluateScopeMap($all, info, true);
      if (isThenable(allResult)) {
        promises.push(allResult);
      } else if (allResult === null && !forAll) {
        return resolveAndReturn(null);
      } else if (allResult) {
        problems.push(allResult);
        if (forAll) {
          return resolveAndReturn(failure);
        }
      }
    }
    for (const [loaderName, arg] of loaderList) {
      const result = this.evaluateScopeLoader(scopes, loaderName, arg);
      if (isThenable(result)) {
        promises.push(result);
      } else if (result === null && !forAll) {
        return resolveAndReturn(null);
      } else if (result) {
        problems.push(result);
        if (forAll) {
          return resolveAndReturn(failure);
        }
      }
    }
    if (promises.length === 0) {
      return forAll && problems.length === 0 ? null : failure;
    }
    return Promise.all(promises).then((results) => {
      let hasSuccess = false;
      results.forEach((result) => {
        if (result) {
          problems.push(result);
        } else {
          hasSuccess = true;
        }
      });
      if (forAll) {
        return problems.length > 0 ? failure : null;
      }
      return hasSuccess ? null : failure;
    });
    function resolveAndReturn(val) {
      if (promises.length > 0) {
        return Promise.all(promises).then(() => val);
      }
      return val;
    }
  }
  evaluateScopeMap(map, info, forAll = this.defaultStrategy === "all") {
    if (typeof map === "boolean") {
      return map ? null : {
        kind: AuthScopeFailureType.AuthScopeFunction,
        error: null
      };
    }
    if (!this.mapCache.has(map)) {
      const result = this.withScopes((scopes) => this.evaluateScopeMapWithScopes(map, scopes, info, forAll));
      if (canCache(map)) {
        this.mapCache.set(map, result);
      }
      return result;
    }
    return this.mapCache.get(map);
  }
  evaluateTypeScopeFunction(authScopes, type2, parent, info) {
    const { typeCache } = this;
    if (!typeCache.has(type2)) {
      typeCache.set(type2, new Map);
    }
    const cache = typeCache.get(type2);
    if (!cache.has(parent)) {
      let result;
      if (this.treatErrorsAsUnauthorized) {
        try {
          result = authScopes(parent, this.context);
        } catch (error8) {
          cache.set(parent, {
            kind: AuthScopeFailureType.AuthScopeFunction,
            error: error8
          });
          return cache.get(parent);
        }
      } else {
        result = authScopes(parent, this.context);
      }
      if (isThenable(result)) {
        let promise = result.then((resolved) => this.evaluateScopeMap(resolved, info));
        if (this.treatErrorsAsUnauthorized) {
          promise = promise.catch((error8) => ({
            kind: AuthScopeFailureType.AuthScopeFunction,
            error: error8
          }));
        }
        cache.set(parent, promise);
      } else {
        cache.set(parent, this.evaluateScopeMap(result, info));
      }
    }
    return cache.get(parent);
  }
  constructor(builder5, context) {
    var _builder_options_scopeAuthOptions, _builder_options_scopeAuthOptions1, _builder_options_scopeAuthOptions2;
    _define_property2(this, "builder", undefined);
    _define_property2(this, "context", undefined);
    _define_property2(this, "mapCache", new Map);
    _define_property2(this, "scopeCache", new Map);
    _define_property2(this, "typeCache", new Map);
    _define_property2(this, "typeGrants", new Map);
    _define_property2(this, "grantCache", new Map);
    _define_property2(this, "scopes", undefined);
    _define_property2(this, "cacheKey", undefined);
    _define_property2(this, "treatErrorsAsUnauthorized", undefined);
    _define_property2(this, "defaultStrategy", undefined);
    this.builder = builder5;
    this.context = context;
    this.cacheKey = (_builder_options_scopeAuthOptions = builder5.options.scopeAuthOptions) === null || _builder_options_scopeAuthOptions === undefined ? undefined : _builder_options_scopeAuthOptions.cacheKey;
    var _builder_options_scopeAuthOptions_treatErrorsAsUnauthorized;
    this.treatErrorsAsUnauthorized = (_builder_options_scopeAuthOptions_treatErrorsAsUnauthorized = (_builder_options_scopeAuthOptions1 = builder5.options.scopeAuthOptions) === null || _builder_options_scopeAuthOptions1 === undefined ? undefined : _builder_options_scopeAuthOptions1.treatErrorsAsUnauthorized) !== null && _builder_options_scopeAuthOptions_treatErrorsAsUnauthorized !== undefined ? _builder_options_scopeAuthOptions_treatErrorsAsUnauthorized : false;
    var _builder_options_scopeAuthOptions_defaultStrategy;
    this.defaultStrategy = (_builder_options_scopeAuthOptions_defaultStrategy = (_builder_options_scopeAuthOptions2 = builder5.options.scopeAuthOptions) === null || _builder_options_scopeAuthOptions2 === undefined ? undefined : _builder_options_scopeAuthOptions2.defaultStrategy) !== null && _builder_options_scopeAuthOptions_defaultStrategy !== undefined ? _builder_options_scopeAuthOptions_defaultStrategy : "any";
  }
}

// ../../node_modules/@pothos/plugin-scope-auth/esm/schema-builder.js
var schemaBuilderProto2 = esm_default.prototype;
schemaBuilderProto2.runAuthScopes = function runAuthScopes(context, scopes, unauthorizedError = (result) => new ForbiddenError(result.message, result.failure)) {
  const cache = RequestCache.fromContext(context, this);
  const resultOrPromise = cache.evaluateScopeMap(scopes);
  if (isThenable(resultOrPromise)) {
    return resultOrPromise.then(handleScopeResult);
  }
  handleScopeResult(resultOrPromise);
  function handleScopeResult(result) {
    if (result) {
      const error8 = unauthorizedError({
        message: "Unauthorized",
        failure: result
      });
      if (typeof error8 === "string") {
        throw new ForbiddenError(error8, result);
      }
      throw error8;
    }
  }
};

// ../../node_modules/@pothos/plugin-scope-auth/esm/field-builders.js
var addScopes = function(scopes, builder5) {
  const originalCreateField = builder5.createField;
  builder5.createField = function createField(options) {
    return originalCreateField.call(this, {
      authScopes: scopes,
      ...options
    });
  };
  return builder5;
};
var objectFieldBuilder = ObjectFieldBuilder2.prototype;
objectFieldBuilder.withAuth = function withAuth(scopes) {
  return addScopes(scopes, new ObjectFieldBuilder2(this.typename, this.builder));
};
var interfaceFieldBuilder = InterfaceFieldBuilder2.prototype;
interfaceFieldBuilder.withAuth = function withAuth2(scopes) {
  return addScopes(scopes, new InterfaceFieldBuilder2(this.typename, this.builder));
};
var queryFieldBuilder = QueryFieldBuilder2.prototype;
queryFieldBuilder.withAuth = function withAuth3(scopes) {
  return addScopes(scopes, new QueryFieldBuilder2(this.builder));
};
var mutationFieldBuilder = MutationFieldBuilder2.prototype;
mutationFieldBuilder.withAuth = function withAuth4(scopes) {
  return addScopes(scopes, new MutationFieldBuilder2(this.builder));
};
var subscriptionFieldBuilder = SubscriptionFieldBuilder2.prototype;
subscriptionFieldBuilder.withAuth = function withAuth5(scopes) {
  return addScopes(scopes, new SubscriptionFieldBuilder2(this.builder));
};

// ../../node_modules/@pothos/plugin-scope-auth/esm/is-type-of-helper.js
function isTypeOfHelper(steps, plugin4, isTypeOf) {
  var _plugin_builder_options_scopeAuthOptions;
  const globalUnauthorizedError = (_plugin_builder_options_scopeAuthOptions = plugin4.builder.options.scopeAuthOptions) === null || _plugin_builder_options_scopeAuthOptions === undefined ? undefined : _plugin_builder_options_scopeAuthOptions.unauthorizedError;
  const createError = (parent, context, info, result) => globalUnauthorizedError ? globalUnauthorizedError(parent, context, info, result) : result.message;
  return (parent, context, info) => {
    const cache = RequestCache.fromContext(context, plugin4.builder);
    function runSteps(index) {
      for (let i = index;i < steps.length; i += 1) {
        const { run, errorMessage } = steps[i];
        const stepResult = run(cache, parent, {}, context, info, () => {
        });
        if (isThenable(stepResult)) {
          return stepResult.then((result) => {
            if (result) {
              const error8 = createError(parent, context, info, {
                message: typeof errorMessage === "function" ? errorMessage(parent, {}, context, info) : errorMessage,
                failure: result
              });
              throw typeof error8 === "string" ? new ForbiddenError(error8, result) : error8;
            }
            return runSteps(i + 1);
          });
        }
        if (stepResult) {
          const error8 = createError(parent, context, info, {
            message: typeof errorMessage === "function" ? errorMessage(parent, {}, context, info) : errorMessage,
            failure: stepResult
          });
          throw typeof error8 === "string" ? new ForbiddenError(error8, stepResult) : error8;
        }
      }
      return isTypeOf ? isTypeOf(parent, context, info) : true;
    }
    return runSteps(0);
  };
}

// ../../node_modules/@pothos/plugin-scope-auth/esm/resolve-helper.js
function resolveHelper(steps, plugin4, fieldConfig) {
  var _plugin_builder_options_scopeAuthOptions;
  var _fieldConfig_pothosOptions_unauthorizedResolver;
  const unauthorizedResolver = (_fieldConfig_pothosOptions_unauthorizedResolver = fieldConfig.pothosOptions.unauthorizedResolver) !== null && _fieldConfig_pothosOptions_unauthorizedResolver !== undefined ? _fieldConfig_pothosOptions_unauthorizedResolver : defaultUnauthorizedResolver;
  const globalUnauthorizedError = (_plugin_builder_options_scopeAuthOptions = plugin4.builder.options.scopeAuthOptions) === null || _plugin_builder_options_scopeAuthOptions === undefined ? undefined : _plugin_builder_options_scopeAuthOptions.unauthorizedError;
  const defaultUnauthorizedError = (parent, args, context, info, result) => {
    if (globalUnauthorizedError) {
      return globalUnauthorizedError(parent, context, info, result);
    }
    if ((result.failure.kind === AuthScopeFailureType.AuthScope || result.failure.kind === AuthScopeFailureType.AuthScopeFunction) && result.failure.error) {
      return result.failure.error;
    }
    return result.message;
  };
  var _fieldConfig_pothosOptions_unauthorizedError;
  const createError = (_fieldConfig_pothosOptions_unauthorizedError = fieldConfig.pothosOptions.unauthorizedError) !== null && _fieldConfig_pothosOptions_unauthorizedError !== undefined ? _fieldConfig_pothosOptions_unauthorizedError : defaultUnauthorizedError;
  return (parent, args, context, info) => {
    let resolvedValue;
    const cache = RequestCache.fromContext(context, plugin4.builder);
    function runSteps(index) {
      for (let i = index;i < steps.length; i += 1) {
        const { run, errorMessage } = steps[i];
        const stepResult = run(cache, parent, args, context, info, (val) => {
          resolvedValue = val;
        });
        if (isThenable(stepResult)) {
          return stepResult.then((result) => {
            if (result) {
              const error8 = createError(parent, args, context, info, {
                message: typeof errorMessage === "function" ? errorMessage(parent, args, context, info) : errorMessage,
                failure: result
              });
              return unauthorizedResolver(parent, args, context, info, typeof error8 === "string" ? new ForbiddenError(error8, result) : error8);
            }
            return runSteps(i + 1);
          });
        }
        if (stepResult) {
          const error8 = createError(parent, args, context, info, {
            message: typeof errorMessage === "function" ? errorMessage(parent, args, context, info) : errorMessage,
            failure: stepResult
          });
          return unauthorizedResolver(parent, args, context, info, typeof error8 === "string" ? new ForbiddenError(error8, stepResult) : error8);
        }
      }
      return resolvedValue;
    }
    return runSteps(0);
  };
}
var defaultUnauthorizedResolver = (_root, _args, _context, _info, error8) => {
  throw error8;
};

// ../../node_modules/@pothos/plugin-scope-auth/esm/steps.js
function createTypeAuthScopesStep(authScopes, type2) {
  if (typeof authScopes === "function") {
    return {
      run: (state, parent, args, context, info) => state.evaluateTypeScopeFunction(authScopes, type2, parent, info),
      errorMessage: `Not authorized to read fields for ${type2}`
    };
  }
  return {
    run: (state, parent, args, context, info) => state.evaluateScopeMap(authScopes, info),
    errorMessage: `Not authorized to read fields for ${type2}`
  };
}
function createTypeGrantScopesStep(grantScopes, type2, forField) {
  return {
    run: (state, parent, args, context, info) => state.grantTypeScopes(type2, parent, forField ? info.path.prev : info.path, () => grantScopes(parent, context)),
    errorMessage: `Unknown error creating grants for ${type2}`
  };
}
function createFieldAuthScopesStep(authScopes) {
  if (typeof authScopes === "function") {
    return {
      errorMessage: (parent, args, context, info) => `Not authorized to resolve ${info.parentType}.${info.fieldName}`,
      run: (state, parent, args, context, info) => {
        const scopeMap = authScopes(parent, args, context, info);
        if (isThenable(scopeMap)) {
          return scopeMap.then((resolved) => state.evaluateScopeMap(resolved, info));
        }
        return state.evaluateScopeMap(scopeMap, info);
      }
    };
  }
  return {
    errorMessage: (parent, args, context, info) => `Not authorized to resolve ${info.parentType}.${info.fieldName}`,
    run: (state, parent, args, context, info) => state.evaluateScopeMap(authScopes, info)
  };
}
function createFieldGrantScopesStep(grantScopes) {
  return {
    errorMessage: (parent, args, context, info) => `Unknown issue generating grants for ${info.parentType}.${info.fieldName}`,
    run: (state, parent, args, context, info) => {
      if (typeof grantScopes !== "function") {
        state.saveGrantedScopes(grantScopes, info.path);
        return null;
      }
      const result = grantScopes(parent, args, context, info);
      if (isThenable(result)) {
        return result.then((resolved) => {
          state.saveGrantedScopes(resolved, info.path);
          return null;
        });
      }
      state.saveGrantedScopes(result, info.path);
      return null;
    }
  };
}
function createResolveStep(resolver) {
  return {
    errorMessage: (parent, args, context, info) => `Unknown issue resolving ${info.parentType}.${info.fieldName}`,
    run: (state, parent, args, context, info, setResolved) => {
      const result = resolver(parent, args, context, info);
      if (isThenable(result)) {
        return Promise.resolve(result).then((resolved) => {
          setResolved(resolved);
          return null;
        });
      }
      setResolved(result);
      return null;
    }
  };
}

// ../../node_modules/@pothos/plugin-scope-auth/esm/index.js
var pluginName3 = "scopeAuth";
var esm_default4 = pluginName3;
var inResolveType = false;

class PothosScopeAuthPlugin extends BasePlugin {
  wrapResolve(resolver, fieldConfig) {
    var _this_builder_options_scopeAuthOptions, _this_builder_options_scopeAuthOptions1;
    if (this.options.disableScopeAuth) {
      return resolver;
    }
    const typeConfig = this.buildCache.getTypeConfig(fieldConfig.parentType);
    if (typeConfig.graphqlKind !== "Object" && typeConfig.graphqlKind !== "Interface") {
      throw new PothosSchemaError(`Got fields for ${fieldConfig.parentType} which is a ${typeConfig.graphqlKind} which cannot have fields`);
    }
    const authorizedOnSubscribe = !!((_this_builder_options_scopeAuthOptions = this.builder.options.scopeAuthOptions) === null || _this_builder_options_scopeAuthOptions === undefined ? undefined : _this_builder_options_scopeAuthOptions.authorizeOnSubscribe) && typeConfig.kind === "Subscription";
    const nonRoot = (typeConfig.graphqlKind === "Interface" || typeConfig.graphqlKind === "Object") && typeConfig.kind !== "Query" && typeConfig.kind !== "Mutation" && typeConfig.kind !== "Subscription";
    var _typeConfig_pothosOptions_runScopesOnType, _ref;
    const runTypeScopesOnField = !nonRoot || !((_ref = (_typeConfig_pothosOptions_runScopesOnType = typeConfig.pothosOptions.runScopesOnType) !== null && _typeConfig_pothosOptions_runScopesOnType !== undefined ? _typeConfig_pothosOptions_runScopesOnType : (_this_builder_options_scopeAuthOptions1 = this.builder.options.scopeAuthOptions) === null || _this_builder_options_scopeAuthOptions1 === undefined ? undefined : _this_builder_options_scopeAuthOptions1.runScopesOnType) !== null && _ref !== undefined ? _ref : false);
    const steps2 = this.createResolveSteps(fieldConfig, typeConfig, resolver, runTypeScopesOnField, authorizedOnSubscribe);
    if (steps2.length > 1) {
      return resolveHelper(steps2, this, fieldConfig);
    }
    return resolver;
  }
  wrapSubscribe(subscriber, fieldConfig) {
    var _this_builder_options_scopeAuthOptions;
    if (this.options.disableScopeAuth) {
      return subscriber;
    }
    const typeConfig = this.buildCache.getTypeConfig(fieldConfig.parentType);
    if (typeConfig.graphqlKind !== "Object" && typeConfig.graphqlKind !== "Interface") {
      throw new PothosSchemaError(`Got fields for ${fieldConfig.parentType} which is a ${typeConfig.graphqlKind} which cannot have fields`);
    }
    if (!((_this_builder_options_scopeAuthOptions = this.builder.options.scopeAuthOptions) === null || _this_builder_options_scopeAuthOptions === undefined ? undefined : _this_builder_options_scopeAuthOptions.authorizeOnSubscribe) || typeConfig.kind !== "Subscription") {
      return subscriber;
    }
    const steps2 = this.createSubscribeSteps(fieldConfig, typeConfig, subscriber);
    if (steps2.length > 1) {
      return resolveHelper(steps2, this, fieldConfig);
    }
    return subscriber;
  }
  wrapResolveType(resolveType, typeConfig) {
    return (...args) => {
      inResolveType = true;
      try {
        return resolveType(...args);
      } finally {
        inResolveType = false;
      }
    };
  }
  wrapIsTypeOf(isTypeOf, typeConfig) {
    var _this_builder_options_scopeAuthOptions;
    if (this.options.disableScopeAuth) {
      return isTypeOf;
    }
    var _typeConfig_pothosOptions_runScopesOnType, _ref;
    const shouldRunTypeScopes = (_ref = (_typeConfig_pothosOptions_runScopesOnType = typeConfig.pothosOptions.runScopesOnType) !== null && _typeConfig_pothosOptions_runScopesOnType !== undefined ? _typeConfig_pothosOptions_runScopesOnType : (_this_builder_options_scopeAuthOptions = this.builder.options.scopeAuthOptions) === null || _this_builder_options_scopeAuthOptions === undefined ? undefined : _this_builder_options_scopeAuthOptions.runScopesOnType) !== null && _ref !== undefined ? _ref : false;
    if (!shouldRunTypeScopes) {
      return isTypeOf;
    }
    const steps2 = this.createStepsForType(typeConfig, {
      forField: false
    });
    if (steps2.length === 0) {
      return isTypeOf;
    }
    const runSteps = isTypeOfHelper(steps2, this, isTypeOf);
    return (source2, context, info) => {
      if (inResolveType) {
        var _isTypeOf;
        var _isTypeOf1;
        return (_isTypeOf1 = (_isTypeOf = isTypeOf) === null || _isTypeOf === undefined ? undefined : _isTypeOf(source2, context, info)) !== null && _isTypeOf1 !== undefined ? _isTypeOf1 : false;
      }
      return runSteps(source2, context, info);
    };
  }
  createStepsForType(typeConfig, { skipTypeScopes, skipInterfaceScopes, forField }) {
    const parentAuthScope = typeConfig.pothosOptions.authScopes;
    const parentGrantScopes = typeConfig.pothosOptions.grantScopes;
    const interfaceConfigs = typeConfig.kind === "Object" || typeConfig.kind === "Interface" ? typeConfig.interfaces.map((iface) => this.buildCache.getTypeConfig(iface, "Interface")) : [];
    const steps2 = [];
    if (parentAuthScope && !skipTypeScopes) {
      steps2.push(createTypeAuthScopesStep(parentAuthScope, typeConfig.name));
    }
    if (!skipInterfaceScopes && !(typeConfig.kind === "Object" && typeConfig.pothosOptions.skipInterfaceScopes)) {
      interfaceConfigs.forEach((interfaceConfig) => {
        if (interfaceConfig.pothosOptions.authScopes) {
          steps2.push(createTypeAuthScopesStep(interfaceConfig.pothosOptions.authScopes, interfaceConfig.name));
        }
      });
    }
    if (parentGrantScopes) {
      steps2.push(createTypeGrantScopesStep(parentGrantScopes, typeConfig.name, forField));
    }
    return steps2;
  }
  createResolveSteps(fieldConfig, typeConfig, resolver, shouldRunTypeScopes, authorizedOnSubscribe) {
    var _ref, _ref1;
    const stepsForType = shouldRunTypeScopes && !authorizedOnSubscribe ? this.createStepsForType(typeConfig, {
      skipTypeScopes: (_ref = (fieldConfig.graphqlKind === "Interface" || fieldConfig.graphqlKind === "Object") && fieldConfig.pothosOptions.skipTypeScopes) !== null && _ref !== undefined ? _ref : false,
      skipInterfaceScopes: (_ref1 = (fieldConfig.graphqlKind === "Interface" || fieldConfig.kind === "Object") && fieldConfig.pothosOptions.skipInterfaceScopes) !== null && _ref1 !== undefined ? _ref1 : false,
      forField: true
    }) : [];
    const fieldAuthScopes = fieldConfig.pothosOptions.authScopes;
    const fieldGrantScopes = fieldConfig.pothosOptions.grantScopes;
    const steps2 = [
      ...stepsForType
    ];
    if (fieldAuthScopes && !authorizedOnSubscribe) {
      steps2.push(createFieldAuthScopesStep(fieldAuthScopes));
    }
    steps2.push(createResolveStep(resolver));
    if (fieldGrantScopes) {
      steps2.push(createFieldGrantScopesStep(fieldGrantScopes));
    }
    return steps2;
  }
  createSubscribeSteps(fieldConfig, typeConfig, subscriber) {
    var _ref, _ref1;
    const stepsForType = this.createStepsForType(typeConfig, {
      skipTypeScopes: (_ref = (fieldConfig.graphqlKind === "Interface" || fieldConfig.graphqlKind === "Object") && fieldConfig.pothosOptions.skipTypeScopes) !== null && _ref !== undefined ? _ref : false,
      skipInterfaceScopes: (_ref1 = (fieldConfig.graphqlKind === "Interface" || fieldConfig.kind === "Object") && fieldConfig.pothosOptions.skipInterfaceScopes) !== null && _ref1 !== undefined ? _ref1 : false,
      forField: true
    });
    const fieldAuthScopes = fieldConfig.pothosOptions.authScopes;
    const steps2 = [
      ...stepsForType
    ];
    if (fieldAuthScopes) {
      steps2.push(createFieldAuthScopesStep(fieldAuthScopes));
    }
    steps2.push(createResolveStep(subscriber));
    return steps2;
  }
}
var fieldBuilderProto2 = RootFieldBuilder2.prototype;
fieldBuilderProto2.authField = function authField(options) {
  return this.field(options);
};
esm_default.registerPlugin(pluginName3, PothosScopeAuthPlugin);

// ../../node_modules/@pothos/plugin-simple-objects/esm/index.js
var pluginName4 = "simpleObjects";
var esm_default5 = pluginName4;

class PothosSimpleObjectsPlugin extends BasePlugin {
}
esm_default.registerPlugin(pluginName4, PothosSimpleObjectsPlugin);
var proto = esm_default.prototype;
proto.simpleObject = function simpleObject(name, options, extraFields) {
  const ref = new ObjectRef2(name);
  if (options.fields) {
    const originalFields = options.fields;
    options.fields = (t) => {
      const fields5 = originalFields(t);
      Object.keys(fields5).forEach((key) => {
        this.configStore.onFieldUse(fields5[key], (config2) => {
          if (config2.kind === "Object") {
            config2.resolve = (parent) => parent[key];
          }
        });
      });
      return fields5;
    };
  }
  this.objectType(ref, options);
  if (extraFields) {
    this.objectFields(ref, extraFields);
  }
  return ref;
};
proto.simpleInterface = function simpleInterface(name, options, extraFields) {
  const ref = new InterfaceRef2(name);
  if (options.fields) {
    const originalFields = options.fields;
    options.fields = (t) => {
      const fields5 = originalFields(t);
      Object.keys(fields5).forEach((key) => {
        this.configStore.onFieldUse(fields5[key], (config2) => {
          if (config2.kind === "Interface") {
            config2.resolve = (parent) => parent[key];
          }
        });
      });
      return fields5;
    };
  }
  this.interfaceType(ref, options);
  if (extraFields) {
    this.interfaceFields(ref, extraFields);
  }
  return ref;
};

// ../../node_modules/graphql-scalars/esm/error.js
function createGraphQLError2(message, options) {
  if (versionInfo.major >= 17) {
    return new GraphQLError(message, options);
  }
  return new GraphQLError(message, options === null || options === undefined ? undefined : options.nodes, options === null || options === undefined ? undefined : options.source, options === null || options === undefined ? undefined : options.positions, options === null || options === undefined ? undefined : options.path, options === null || options === undefined ? undefined : options.originalError, options === null || options === undefined ? undefined : options.extensions);
}

// ../../node_modules/graphql-scalars/esm/scalars/iso-date/formatter.js
var parseDate = (date) => {
  return new Date(date);
};
var serializeDate = (date) => {
  return date.toISOString().split("T")[0];
};
var parseDateTime = (dateTime) => {
  return new Date(dateTime);
};

// ../../node_modules/graphql-scalars/esm/scalars/iso-date/validator.js
var leapYear = (year) => {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};
var validateTime = (time) => {
  time = time === null || time === undefined ? undefined : time.toUpperCase();
  const TIME_REGEX = /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])(\.\d{1,})?(([Z])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;
  return TIME_REGEX.test(time);
};
var validateDate = (datestring) => {
  const RFC_3339_REGEX = /^(\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]))$/;
  if (!RFC_3339_REGEX.test(datestring)) {
    return false;
  }
  const year = Number(datestring.substr(0, 4));
  const month = Number(datestring.substr(5, 2));
  const day = Number(datestring.substr(8, 2));
  switch (month) {
    case 2:
      if (leapYear(year) && day > 29) {
        return false;
      } else if (!leapYear(year) && day > 28) {
        return false;
      }
      return true;
    case 4:
    case 6:
    case 9:
    case 11:
      if (day > 30) {
        return false;
      }
      break;
  }
  return true;
};
var validateDateTime = (dateTimeString) => {
  dateTimeString = dateTimeString === null || dateTimeString === undefined ? undefined : dateTimeString.toUpperCase();
  const RFC_3339_REGEX = /^(\d{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60))(\.\d{1,})?(([Z])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;
  if (!RFC_3339_REGEX.test(dateTimeString)) {
    return false;
  }
  const time = Date.parse(dateTimeString);
  if (time !== time) {
    return false;
  }
  const index = dateTimeString.indexOf("T");
  const dateString = dateTimeString.substr(0, index);
  const timeString = dateTimeString.substr(index + 1);
  return validateDate(dateString) && validateTime(timeString);
};
var validateJSDate = (date) => {
  const time = date.getTime();
  return time === time;
};

// ../../node_modules/graphql-scalars/esm/scalars/iso-date/Date.js
var GraphQLDateConfig = {
  name: "Date",
  description: "A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.",
  serialize(value) {
    if (value instanceof Date) {
      if (validateJSDate(value)) {
        return serializeDate(value);
      }
      throw createGraphQLError2("Date cannot represent an invalid Date instance");
    } else if (typeof value === "string") {
      if (validateDate(value)) {
        return value;
      }
      throw createGraphQLError2(`Date cannot represent an invalid date-string ${value}.`);
    } else {
      throw createGraphQLError2("Date cannot represent a non string, or non Date type " + JSON.stringify(value));
    }
  },
  parseValue(value) {
    if (!(typeof value === "string")) {
      throw createGraphQLError2(`Date cannot represent non string type ${JSON.stringify(value)}`);
    }
    if (validateDate(value)) {
      return parseDate(value);
    }
    throw createGraphQLError2(`Date cannot represent an invalid date-string ${value}.`);
  },
  parseLiteral(ast8) {
    if (ast8.kind !== Kind.STRING) {
      throw createGraphQLError2(`Date cannot represent non string type ${"value" in ast8 && ast8.value}`, { nodes: ast8 });
    }
    const { value } = ast8;
    if (validateDate(value)) {
      return parseDate(value);
    }
    throw createGraphQLError2(`Date cannot represent an invalid date-string ${String(value)}.`, {
      nodes: ast8
    });
  },
  extensions: {
    codegenScalarType: "Date | string",
    jsonSchema: {
      type: "string",
      format: "date"
    }
  }
};
var GraphQLDate = new GraphQLScalarType(GraphQLDateConfig);
// ../../node_modules/graphql-scalars/esm/scalars/iso-date/DateTime.js
var GraphQLDateTimeConfig = {
  name: "DateTime",
  description: "A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.",
  serialize(value) {
    if (value instanceof Date) {
      if (validateJSDate(value)) {
        return value;
      }
      throw createGraphQLError2("DateTime cannot represent an invalid Date instance");
    } else if (typeof value === "string") {
      if (validateDateTime(value)) {
        return parseDateTime(value);
      }
      throw createGraphQLError2(`DateTime cannot represent an invalid date-time-string ${value}.`);
    } else if (typeof value === "number") {
      try {
        return new Date(value);
      } catch (e) {
        throw createGraphQLError2("DateTime cannot represent an invalid Unix timestamp " + value);
      }
    } else {
      throw createGraphQLError2("DateTime cannot be serialized from a non string, non numeric or non Date type " + JSON.stringify(value));
    }
  },
  parseValue(value) {
    if (value instanceof Date) {
      if (validateJSDate(value)) {
        return value;
      }
      throw createGraphQLError2("DateTime cannot represent an invalid Date instance");
    }
    if (typeof value === "string") {
      if (validateDateTime(value)) {
        return parseDateTime(value);
      }
      throw createGraphQLError2(`DateTime cannot represent an invalid date-time-string ${value}.`);
    }
    throw createGraphQLError2(`DateTime cannot represent non string or Date type ${JSON.stringify(value)}`);
  },
  parseLiteral(ast8) {
    if (ast8.kind !== Kind.STRING) {
      throw createGraphQLError2(`DateTime cannot represent non string or Date type ${"value" in ast8 && ast8.value}`, {
        nodes: ast8
      });
    }
    const { value } = ast8;
    if (validateDateTime(value)) {
      return parseDateTime(value);
    }
    throw createGraphQLError2(`DateTime cannot represent an invalid date-time-string ${String(value)}.`, { nodes: ast8 });
  },
  extensions: {
    codegenScalarType: "Date | string",
    jsonSchema: {
      type: "string",
      format: "date-time"
    }
  }
};
var GraphQLDateTime = new GraphQLScalarType(GraphQLDateTimeConfig);
// ../../node_modules/graphql-scalars/esm/scalars/utilities.js
var _validateInt = function(value) {
  if (!Number.isFinite(value)) {
    throw createGraphQLError2(`Value is not a finite number: ${value}`);
  }
  if (!Number.isInteger(value)) {
    throw createGraphQLError2(`Value is not an integer: ${value}`);
  }
  if (!Number.isSafeInteger(value)) {
    throw createGraphQLError2(`Value is not a safe integer: ${value}`);
  }
};
var _validateFloat = function(value) {
  if (!Number.isFinite(value)) {
    throw createGraphQLError2(`Value is not a finite number: ${value}`);
  }
};
function processValue(value, scalarName) {
  const { range, type: type2 } = VALIDATIONS[scalarName];
  if (value === null || typeof value === "undefined" || isNaN(value) || Number.isNaN(value) || value === Number.NaN) {
    throw createGraphQLError2(`Value is not a number: ${value}`);
  }
  let parsedValue;
  switch (type2) {
    case VALUE_TYPES.FLOAT:
      parsedValue = parseFloat(value);
      _validateFloat(parsedValue);
      break;
    case VALUE_TYPES.INT:
      parsedValue = parseInt(value, 10);
      _validateInt(parsedValue);
      break;
    default:
  }
  if (range === VALUE_RANGES.NEGATIVE && !(parsedValue < 0) || range === VALUE_RANGES.NON_NEGATIVE && !(parsedValue >= 0) || range === VALUE_RANGES.POSITIVE && !(parsedValue > 0) || range === VALUE_RANGES.NON_POSITIVE && !(parsedValue <= 0)) {
    throw createGraphQLError2(`Value is not a ${VALUE_RANGES[range].toLowerCase().replace("_", "-")} number: ${value}`);
  }
  return parsedValue;
}
var VALUE_RANGES;
(function(VALUE_RANGES2) {
  VALUE_RANGES2[VALUE_RANGES2["NEGATIVE"] = 0] = "NEGATIVE";
  VALUE_RANGES2[VALUE_RANGES2["NON_NEGATIVE"] = 1] = "NON_NEGATIVE";
  VALUE_RANGES2[VALUE_RANGES2["POSITIVE"] = 2] = "POSITIVE";
  VALUE_RANGES2[VALUE_RANGES2["NON_POSITIVE"] = 3] = "NON_POSITIVE";
})(VALUE_RANGES || (VALUE_RANGES = {}));
var VALUE_TYPES;
(function(VALUE_TYPES2) {
  VALUE_TYPES2[VALUE_TYPES2["INT"] = 0] = "INT";
  VALUE_TYPES2[VALUE_TYPES2["FLOAT"] = 1] = "FLOAT";
})(VALUE_TYPES || (VALUE_TYPES = {}));
var VALIDATIONS = {
  NonPositiveInt: {
    range: VALUE_RANGES.NON_POSITIVE,
    type: VALUE_TYPES.INT
  },
  PositiveInt: {
    range: VALUE_RANGES.POSITIVE,
    type: VALUE_TYPES.INT
  },
  NonNegativeInt: {
    range: VALUE_RANGES.NON_NEGATIVE,
    type: VALUE_TYPES.INT
  },
  NegativeInt: {
    range: VALUE_RANGES.NEGATIVE,
    type: VALUE_TYPES.INT
  },
  NonPositiveFloat: {
    range: VALUE_RANGES.NON_POSITIVE,
    type: VALUE_TYPES.FLOAT
  },
  PositiveFloat: {
    range: VALUE_RANGES.POSITIVE,
    type: VALUE_TYPES.FLOAT
  },
  NonNegativeFloat: {
    range: VALUE_RANGES.NON_NEGATIVE,
    type: VALUE_TYPES.FLOAT
  },
  NegativeFloat: {
    range: VALUE_RANGES.NEGATIVE,
    type: VALUE_TYPES.FLOAT
  }
};

// ../../node_modules/graphql-scalars/esm/scalars/PositiveInt.js
var GraphQLPositiveInt = new GraphQLScalarType({
  name: "PositiveInt",
  description: "Integers that will have a value greater than 0.",
  serialize(value) {
    return processValue(value, "PositiveInt");
  },
  parseValue(value) {
    return processValue(value, "PositiveInt");
  },
  parseLiteral(ast8) {
    if (ast8.kind !== Kind.INT) {
      throw createGraphQLError2(`Can only validate integers as positive integers but got a: ${ast8.kind}`, {
        nodes: ast8
      });
    }
    return processValue(ast8.value, "PositiveInt");
  },
  extensions: {
    codegenScalarType: "number",
    jsonSchema: {
      title: "PositiveInt",
      type: "integer",
      minimum: 1
    }
  }
});
// ../../node_modules/graphql-scalars/esm/scalars/json/utils.js
function identity(value) {
  return value;
}
function ensureObject(value, ast8) {
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    throw createGraphQLError2(`JSONObject cannot represent non-object value: ${value}`, ast8 ? {
      nodes: ast8
    } : undefined);
  }
  return value;
}
function parseObject(ast8, variables) {
  if (ast8.kind !== Kind.OBJECT) {
    throw createGraphQLError2(`JSONObject cannot represent non-object value: ${print(ast8)}`, ast8 ? {
      nodes: ast8
    } : undefined);
  }
  const value = Object.create(null);
  ast8.fields.forEach((field2) => {
    value[field2.name.value] = parseLiteral(field2.value, variables);
  });
  return value;
}
function parseLiteral(ast8, variables) {
  switch (ast8.kind) {
    case Kind.STRING:
    case Kind.BOOLEAN:
      return ast8.value;
    case Kind.INT:
    case Kind.FLOAT:
      return parseFloat(ast8.value);
    case Kind.OBJECT:
      return parseObject(ast8, variables);
    case Kind.LIST:
      return ast8.values.map((n) => parseLiteral(n, variables));
    case Kind.NULL:
      return null;
    case Kind.VARIABLE: {
      const name = ast8.name.value;
      return variables ? variables[name] : undefined;
    }
  }
}

// ../../node_modules/graphql-scalars/esm/scalars/json/JSON.js
var specifiedByURL = "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf";
var GraphQLJSONConfig = {
  name: "JSON",
  description: "The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).",
  serialize: identity,
  parseValue: identity,
  parseLiteral,
  specifiedByURL,
  specifiedByUrl: specifiedByURL,
  extensions: {
    codegenScalarType: "any"
  }
};
var GraphQLJSON = new GraphQLScalarType(GraphQLJSONConfig);
// ../../node_modules/graphql-scalars/esm/scalars/json/JSONObject.js
var specifiedByURL2 = "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf";
var GraphQLJSONObjectConfig = {
  name: "JSONObject",
  description: "The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).",
  serialize: ensureObject,
  parseValue: ensureObject,
  parseLiteral: parseObject,
  specifiedByURL: specifiedByURL2,
  specifiedByUrl: specifiedByURL2,
  extensions: {
    codegenScalarType: "Record<string, any>",
    jsonSchema: {
      type: "object",
      additionalProperties: true
    }
  }
};
var GraphQLJSONObject = new GraphQLScalarType(GraphQLJSONObjectConfig);
// src/utils/dayjs.ts
var import_dayjs = __toESM(require_dayjs_min(), 1);
var customParseFormat = __toESM(require_customParseFormat(), 1);
var utc = __toESM(require_utc(), 1);
var timezone = __toESM(require_timezone(), 1);
import_dayjs.default.extend(customParseFormat.default);
import_dayjs.default.extend(utc.default);
import_dayjs.default.extend(timezone.default);
var dayjs = import_dayjs.default;

// src/graphql/builder.ts
var decodeGlobalId = (globalId) => {
  const [typename, ...idElements] = globalId.split("_");
  const id = idElements.join("_");
  if (!typename || !id)
    return null;
  return { typename, id };
};
var $decodeGlobalId = (globalId) => {
  const id = decodeGlobalId(globalId);
  if (!id)
    throw new GraphQLError("Invalid Relay ID");
  return id;
};
var encodeGlobalId = (typename, id) => {
  return `${typename}_${id}`;
};
var builder5 = new esm_default({
  plugins: [esm_default2, esm_default4, esm_default3, esm_default5],
  relayOptions: {
    clientMutationId: "omit",
    cursorType: "ID",
    edgesFieldOptions: {
      nullable: false
    },
    nodeFieldOptions: {
      nullable: false
    },
    encodeGlobalID: encodeGlobalId,
    decodeGlobalID: $decodeGlobalId
  },
  authScopes: async (context) => {
    return {
      public: true,
      authenticated: () => context.isTokenValid()
    };
  },
  scopeAuthOptions: {
    unauthorizedError: (_, __, info) => {
      const errors17 = {
        query: "You need a token to see this.",
        mutation: "You need a token to do this.",
        subscription: "You need a token to see this.",
        _default: "You need a token to do this."
      };
      return new GraphQLError(errors17[info.operation.operation] ?? errors17._default, {
        extensions: {
          code: "UNAUTHENTICATED",
          userFriendlyMessage: errors17[info.operation.operation] ?? errors17._default
        }
      });
    }
  }
});
builder5.queryType();
builder5.mutationType();
builder5.addScalarType("Date", GraphQLDate, {});
builder5.addScalarType("DateTime", GraphQLDateTime, {});
builder5.addScalarType("PositiveInt", GraphQLPositiveInt, {});
builder5.addScalarType("JSON", GraphQLJSON, {});
builder5.addScalarType("JSONObject", GraphQLJSONObject, {});
builder5.scalarType("Time", {
  description: "A time of day, represented as a string in the format `HH:mm`. For example, `16:20`.",
  serialize: (value) => dayjs(value).utc(false).format("HH:mm"),
  parseValue: (value) => {
    const dayjsObj = dayjs(`1970-01-01 ${value}`, "YYYY-MM-DD HH:mm", true).utc(true);
    if (!dayjsObj.isValid()) {
      throw new GraphQLError(`Invalid time "${value}". Should be in the format \`HH:mm\`. For example, \`16:20\`.`);
    }
    return dayjsObj.toDate();
  }
});

// src/utils/index.ts
var spawn = async (args, opts) => {
  const proc = Bun.spawn(args, {
    stdout: "pipe",
    stderr: "pipe",
    onExit: async (proc2) => {
      const exited = await proc2.exited;
      if (exited) {
        const shortCommand = args.join(" ").slice(0, 20);
        const shortErrorMessage = `\`${shortCommand}\` exited with code ${proc2.exitCode ?? exited}`;
        console.log(shortErrorMessage);
        const stderr = proc2.stderr && typeof proc2.stderr !== "number" ? await Bun.readableStreamToText(proc2.stderr) : null;
        const stdout = proc2.stdout && typeof proc2.stdout !== "number" ? await Bun.readableStreamToText(proc2.stdout) : null;
        console.log("stderr:", stderr);
        console.log("stdout:", stdout);
        throw new GraphQLError(shortErrorMessage, {
          extensions: {
            code: "FAILED_TO_SPAWN_PROCESS",
            errorMessage: stderr ?? stdout ?? "Unknown error"
          }
        });
      }
    },
    ...opts
  });
  await proc.exited;
  return proc;
};

// src/utils/git.ts
var basePath = env.PATH_TO_BUILDS ?? "../builds";
var gitPullFlowBuild = async (opts) => {
  const res = await spawn("git pull".split(" "), {
    cwd: await Bun.resolve(`${basePath}/${opts.build}`, import.meta.dir)
  });
  return res;
};
var gitPullFlowNode = async () => {
  console.log("\uD83D\uDD35 updating flow-node repo...");
  const res = await spawn("git pull".split(" "), { cwd: import.meta.dir });
  console.log("\u2705 flow-node is now up to date.");
  return res;
};

// src/graphql/Util.ts
import path from "path";
builder5.queryField("hello", (t) => t.field({
  type: "String",
  resolve: () => "world!"
}));
var values4 = {
  nightly: { value: "nightly" },
  weekly: { value: "weekly" },
  monthly: { value: "monthly" }
};
var BuildEnum = builder5.enumType("BuildType", { values: values4 });
builder5.mutationField("updateFlowNode", (t) => t.field({
  type: "Boolean",
  description: "Update the flow-node repo and restart it once up to date.",
  resolve: async (_, args) => {
    await gitPullFlowNode();
    return true;
  }
}));
builder5.mutationField("udpateFlow", (t) => t.fieldWithInput({
  type: "Boolean",
  description: "Git pull one of the builds and restart any flow instances that started on that build.",
  input: {
    buildType: t.input.field({
      type: BuildEnum,
      required: true,
      description: "Which build to update."
    })
  },
  resolve: async (_, args) => {
    await gitPullFlowBuild({ build: args.input.buildType });
    return true;
  }
}));
var basePath2 = env.PATH_TO_BUILDS ?? "../builds";
builder5.mutationField("setupFlowInstance", (t) => t.fieldWithInput({
  type: "Boolean",
  description: "Set up a new flow instance for a user.",
  input: {
    buildType: t.input.field({
      type: BuildEnum,
      required: true,
      description: "Which build to start the flow instance from."
    }),
    port: t.input.int({
      description: "The port to start the flow instance on.",
      required: true
    }),
    databaseUrl: t.input.string({
      description: "The URL of the Neon database to start the flow instance on.",
      required: true
    }),
    username: t.input.string({
      description: "The username of the Flow instance.",
      required: true
    }),
    domainWithTld: t.input.string({
      description: "The root domain + TLD of the Flow instance (i.e. the [domain.tld] part of `subdomain.[domain.tld]).`",
      required: true
    }),
    maximumRamSize: t.input.int({
      description: "The maximum amount of RAM to use for the Flow instance in bytes.",
      required: false
    })
  },
  resolve: async (_, args) => {
    const domain = `${args.input.username}.${args.input.domainWithTld}`;
    const cwd2 = path.resolve(import.meta.dir, `${basePath2}/${args.input.buildType}`);
    console.log("setupFlowInstance cwd:", cwd2);
    const maxRam = args.input.maximumRamSize ?? 90;
    await spawn([
      "pm2",
      "start",
      `NODE_ENV=production PORT=${args.input.port} DATABASE_URL=${args.input.databaseUrl} ORIGIN=https://${args.input.username}.${args.input.domainWithTld} PATH_TO_PLUGINS=../plugins/${args.input.username} BUN_JSC_forceRAMSize=${maxRam * 1000} bun run index.js`,
      "-f",
      "--watch",
      "-n",
      args.input.username,
      "--max-memory-restart",
      `${maxRam}M`
    ], { cwd: cwd2 }).catch((e) => {
      throw new GraphQLError(e);
    });
    await spawn(["bunx", "pm2", "save"]).catch((e) => {
      throw new GraphQLError(e);
    });
    await spawn([
      "sudo",
      "certbot",
      "certonly",
      "--nginx",
      "-d",
      domain
    ]).catch((e) => {
      throw new GraphQLError(e);
    });
    const nginxConfig = `server {
  listen 80;
  server_name ${domain};
  return 301 https://\$server_name\$request_uri;
}

server {
  listen 443 ssl;
  server_name ${domain};

  ssl_certificate /etc/letsencrypt/live/${domain}/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/${domain}/privkey.pem;

  location / {
    proxy_pass http://localhost:${args.input.port};
  }
}

`;
    await Bun.write(`/etc/nginx/servers/${domain}`, nginxConfig).catch((e) => {
      throw new GraphQLError(e);
    });
    await spawn(["sudo", "nginx", "-t"]).catch((e) => {
      throw new GraphQLError(e);
    });
    await spawn(["sudo", "nginx", "-s", "reload"]).catch((e) => {
      throw new GraphQLError(e);
    });
    return true;
  }
}));
builder5.mutationField("test", (t) => t.field({
  type: "Boolean",
  description: "Test",
  resolve: async (_, args) => {
    await spawn([
      "sudo",
      "certbot",
      "certonly",
      "--nginx",
      "-d",
      "richard2.isflow.in"
    ]);
    return true;
  }
}));

// src/graphql/index.ts
var schema6 = builder5.toSchema();
if (env.NODE_ENV === "development") {
  const schemaAsString = printSchema(schema6);
  console.log(import.meta.dir);
  const graphqlPath = await Bun.resolve("../../../../packages/common/schema.graphql", import.meta.dir);
  await Bun.write(graphqlPath, "# @generated\n" + schemaAsString);
  console.log(`
\u2705 GraphQL schema generated into packages/common/schema.graphql`);
  const tsPath = await Bun.resolve("../../../../packages/common/graphql.ts", import.meta.dir);
  const tsTypes = await codegen({
    documents: [],
    config: {
      enumsAsTypes: true
    },
    filename: tsPath,
    schema: parse(schemaAsString),
    plugins: [
      {
        typescript: {
          enumAsTypes: true
        }
      }
    ],
    pluginMap: {
      typescript: exports_esm
    }
  });
  await Bun.write(tsPath, tsTypes);
  console.log("\u2705 Typescript types of GraphQL schema generated into packages/common/graphql.ts");
}

// src/index.ts
import path2 from "path";
import fs from "fs/promises";
var PORT = env.PORT ?? 5010;
var yogaHandler = async (request) => {
  const res = await createYoga({
    schema: schema6,
    cors: { origin: undefined },
    graphiql: {
      title: "Flow CT API",
      headers: JSON.stringify({
        Authorization: `Bearer PASTE_TOKEN_HERE`
      })
    }
  }).handle(request);
  res.headers.delete("Access-Control-Allow-Origin");
  return res;
};
var app = new c$().use(cors()).get("/graphql", async ({ request }) => yogaHandler(request)).post("/graphql", async ({ request }) => yogaHandler(request), {
  type: "none"
});
if (env.NODE_ENV === "test") {
  app.listen(0);
} else {
  if (env.NODE_ENV === "production") {
    await gitPullFlowNode();
    if (!env.PATH_TO_BUILDS) {
      throw { message: "PATH_TO_BUILDS env var is not set." };
    }
    const pathToBuilds = path2.resolve(import.meta.dir, env.PATH_TO_BUILDS);
    const exists = await fs.exists(pathToBuilds);
    if (!exists) {
      throw {
        message: `PATH_TO_BUILDS env var is set to ${pathToBuilds} but it does not exist.`
      };
    }
    console.log(`\u2705 PATH_TO_BUILDS env var is set to: ${pathToBuilds}`);
  }
  app.listen(PORT, () => {
    console.log(`\u2705 Server started at: http://localhost:${PORT}`);
    console.log(`\uD83D\uDFE3 GraphQL API: http://localhost:${PORT}/graphql`);
  });
}
process.on("SIGINT", () => {
  console.log("\u2705 Server shutting down...");
  console.log("Bye \uD83D\uDC4B");
});
export {
  app
};
